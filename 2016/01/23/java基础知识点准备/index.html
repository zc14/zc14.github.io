

<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <script type="text/javascript" src="http://tajs.qq.com/stats?sId=44218032" charset="UTF-8"></script>
  <script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?7192fa361f5cabb11d8a22de41c1ba8f";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>
  
  <title>java基础知识点准备 | zc14-紫竹林</title>
  <meta name="author" content="周聪">
  
  <meta name="description" content="加班...">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="java基础知识点准备"/>
  <meta property="og:site_name" content="zc14-紫竹林"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/imgs/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="alternate" href="/atom.xml" title="zc14-紫竹林" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//libs.baidu.com/jquery/1.8.0/jquery.min.js"></script>
</head>


<body>
  <header><div>
		
			<div id="imglogo">
				<a href="/"><img src="/imgs/logo.png" alt="zc14-紫竹林" title="zc14-紫竹林"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name">zc14-紫竹林</h1>
				<h2 class="blog-motto">叽里呱啦</h2>
			</div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li> <a href="/atom.xml">RSS</a> </li>
				</ul>
			</nav>			
</div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header class="article-info clearfix">
  <h1 itemprop="name">
	java基础知识点准备
  </h1>
  <p class="article-author">By
    
      <a href="http://zc14.github.io" title="周聪">周聪</a>
    </p>
  <p class="article-time">
    <time datetime="2016-01-23T09:28:22.000Z" itemprop="datePublished">2016-01-23</time>
    更新日期:<time datetime="2016-02-20T03:22:36.572Z" itemprop="dateModified">2016-02-20</time>
    
  </p>
</header>
    <div class="entry">
		
        <h2 id="1-知识点总结">1.知识点总结</h2><ul>
<li><h3 id="常见面试题整理">常见面试题整理</h3><p>1.Aio和Nio区别<br>  <strong>NIO:同步非阻塞；AIO:异步非阻塞</strong><br>  <strong>同步异步是指是否是同一次请求（便于理解，举个例子）。阻塞和非阻塞就是oio和nio的问题，指的是调用一个方法能否立即返回结果。</strong><br>  <em>如果把内核比作快递，NIO就是你要自己时不时到官网查下快递是否已经到了你所在城市，然后自己去取快递；AIO就是快递员送货上门了。</em></p>
<p>2.你做过最得意的项目是什么<br>  <strong>必须想办法突出项目的亮点，并且突出自己在团队中的重要性。</strong></p>
<p>3.HashMap是如何实现的<br>  <strong>本质：数组+链表， 链表的节点就是 k-v 对。H</strong><br>  <strong>Hashmap中有一个饱和因子的变量，默认上是0.75，实际上也是通常情况下不会产生hash冲突的最佳设置（当然凡事也有例外）</strong><br>  <strong>这个扩容会重做整个散列数组+链表，代价很大，所以大牛们都建议使用hashmap时最好指定需要的容量大小。</strong><br>  <strong>一般需要使用大小为N，new HashMap时最好指定（N/饱和因子）的容量，或者指定大于N的最小的2的幂。</strong></p>
<p>4.为什么要使用Spring<br> <strong>与EJB对比。重量级模块耦合度高。/用哪个，配置哪个。 Ioc模块+Aop模块。 润滑剂 让业务功能实现更方便、更优雅。</strong></p>
<p>5.如何减少上下文切换<br> <strong>上下文切换是指CPU的控制权由运行任务转移到另外一个就绪任务时所发生的事件；</strong></p>
<p> <strong>对于任务耗时短的情况，要求线程尽量少，如果线程太多，有可能出现线程切换和管理的时间，大于任务执行的时间，那效率就低了；</strong><br> <strong>耗时长的任务，要分是cpu任务，还是io等类型的任务。如果是cpu类型的任务，线程数不宜太多；但是如果是io类型的任务，线程多一些更好，可以更充分利用cpu</strong><br> <strong>高并发，低耗时的情况，上下文切换 本来就多，并且高并发就意味着CPU是处于繁忙状态的， 增加更多地线程也不会让线程得到执行时间片, 反而会增加线程切换的开销.</strong><br> <strong>低并发，高耗时，保证有空闲线程，接收新任务，可以减少线程切换。</strong><br> <strong>高并发高耗时：1要分析任务类型，2增加排队，3、加大线程数</strong></p>
</li>
</ul>
<p>  6.Spring有什么缺点<br>   <strong>变的复杂。东西越来越多，拆分模块出来，不知道用什么。</strong><br>   <strong>学习源码困难度加大。</strong></p>
<p>  7.有限的资源里处理一个较大的数据<br>   <strong>如果你处理逻辑，跟全量数据有关，例如对全部数据进行排序，这个可以采用bitmap(索引，数据压缩方面有好的应用),堆排序等之类的，网上可以搜到。<br>但是如果你的处理逻辑跟全量数据无关，那就跟简单了，你可以设置一个buffer，每次读满一个buffer，处理完了，再读下一个buffer。</strong></p>
<p>  8.高并发，执行耗时短的任务，还有低并发，执行耗时长的任务，各自选取什么样的线程池会比较合理？为什么？如果业务场景是高并发，且任务耗时长时，有什么解决思路？<br>  <strong>线程池的关键点是：1、尽量减少线程切换和管理的开支； 2、最大化利用cpu。</strong><br>  <strong>对于1，要求线程数尽量少，这样可以减少线程切换和管理的开支；<br>对于2，要求尽量多的线程，以保证CPU资源最大化的利用。</strong><br>  <strong>对于高并发耗时长的情况，我认为，思路就是把一个难以解决的问题转化成我们已知的已经有解决方案的问题，以此来解决。<br>所以 ，高并发又耗时长，可以转化为<br>      1、高并发，耗时短的问题   –&gt;   异步处理+回调，和情况1吻合<br>      2、低并发，耗时长的问题   –&gt;   前端加load balance，把高并发分摊成若干低并发，和情况2吻合<br>其实说到核心，如果真遇到高并发耗时长的场景，只能是加机器，加计算单元（无论是异步加回调还是load balance）</strong></p>
<p>  9.数据库中内连接与外连接的区别<br>  <strong>这个问题从数学的角度更容易理解。<br>inner join：A与B的交集<br>left join：A的全集<br>right join：B的全集<br>full join：A与B的并集<br>cross join：A与B的笛卡尔积</strong></p>
<p>  10.经常看到url中很长的一串请求参数，为什么不采用post方式<br>  <strong>1 浏览器地址栏打开的默认就是GET，所以链接用GET很方便。<br>2 POST的提交需要表单或js提交，麻烦。<br>3 GET可以使用缓存<br>4 GET有利于SEO</strong></p>
<p>  11.有一个生成唯一串的需求，并发请求量非常大<br><strong>1.生成串由单线程批量生成。<br>2.并发获取的线程由队列（队列采用链表的阻塞队列实现）进行控制。<br>串的生成格式：ip+进程号+当前时间(精确到纳秒)+计数器（每次批量生成串的时候重置计数器为0）<br>可以解决，多机多JVM实例的问题，计数器可以解决时间相同的问题</strong></p>
<p>  12.处理大量并发用户访问网页，并且如何跟踪每个用户<br><strong>页面静态化，还有cdn代理等等 总之尽量减少或避免用户加载页面时与服务后台产生动态数据的加载</strong></p>
<p> 13.高并发解决方案<br> <strong>浏览器到前台页面，负载均衡，HTML静态化，缓存，图片服务器分离。数据库，读写分离，垂直拆分数据库，水平拆分数据库。</strong></p>
<p> 14.1亿条数据如何保存<br>  <strong>生成txt或者csv数据文件，再直接通过数据文件导入到数据库中。先删除索引，导入后在重建。</strong></p>
<p>15.1000万条数据如何取出来<br>  分页？</p>
<p>16.有3个线程ABC。按照ABC来运行（A线程输出A，B线程输出B，C线程输出C，以此类推，循环输出）。<br>  <strong>join</strong><br>  <strong>用 Reentrantlock，用它的newCondition() 方法创建3个condition，按顺序调用 condition 的await和signal 方法就可以了，具体看Reentrantlock 和Condition 讲解。</strong></p>
<p>17.threadlocal原理<br> **ThreadLocal 主要目的：<br>1、在同一线程中方法与方法，类与类之间的共享内容传输（也是官方创建ThreadLocal的本意）。<br>2、利用ThreadLocal 规避线程安全问题，这种方式已经大量应用，如Spring mvc 在Controller中注入全局HttpSession对象。</p>
<p>ThreadLocal原理：<br>Thread 类成员变量 ThreadLocal.ThreadLocalMap 详细不说了。**</p>
<p>18.分库分表如何控制事务，也就是分布式事务有什么解决方案<br><strong>所谓分布式事务最终解决的是数据一致性的问题，这也是典型的cap定理里面的东西没啥新鲜的。那么如何解决？<br>1，用redis做一个分布式锁，不过redis集群很麻烦，不太稳定（目前我们公司再用）<br>2，zk锁，推荐使用。：<br>3，数据库层面的东西，有一个mycat的东西，你可以了解下。</strong></p>
<p>19.让您做一个电商平台，您如何设置一个在买家下订单后的”第60秒“发短信通知卖家发货，您需要考虑的是 像淘宝一样的大并发量的订单。<em> ★★★★★★★★★★★★★★★★★<strong>
  </strong><br>  可以通过分布式调度框架来实现,将这种通用的调度任务交给专门的系统来处理,接收下单的时间和订单的基本信息做为触发这个任务的参数即可<br>触发动作可以用过类似kafka的消息中间件进行传递*</em></p>
<p><strong>1、具有排序功能的队列<br>2、Redis+定时器</strong><br><em>原理：第一种思路也就是大家推荐的延迟队列实现的原理，其就是一个按时间排好序的队列，每次put的时候排序，然后take的时候就计算时间是否过期，如果过期则返回队列第一个元素，否则当前线程阻塞X秒，这个也是JDK 自带 DelayQueue 的思路。详细可看源码</em><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pubic E <span class="title">take</span>(<span class="params"></span>) throws InterruptedException</span>&#123;</span><br><span class="line">  final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">  <span class="keyword">lock</span>.lockInterruptibly();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      E first = q.peek();</span><br><span class="line">      <span class="keyword">if</span>(first == <span class="keyword">null</span>)</span><br><span class="line">      available.await();</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> delay = first.getDelay(TimeUnit.NANOSECONFS);</span><br><span class="line">        <span class="keyword">if</span>(delay &lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> q.poll();</span><br><span class="line">        <span class="function"><span class="keyword">else</span> <span class="title">if</span>(<span class="params">leader != <span class="keyword">null</span></span>)</span><br><span class="line">        available.<span class="title">await</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">         Thread thisThread = Thread.currentThread();</span><br><span class="line">         leader = thisThread;</span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line">            available.awaitNanos(delay);</span><br><span class="line">         &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(leader == thisThread)</span><br><span class="line">           leader = <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(leader == <span class="keyword">null</span> &amp;&amp; peek() != <span class="keyword">null</span>)</span><br><span class="line">    available.signal();</span><br><span class="line">    <span class="keyword">lock</span>.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>原理：第二种思路需要利用Redis的有序集合，说到使用 Redis 就不得不考虑Score的设计，因为它直接决定你代码的复杂度，你思路的清晰性，在这我并没有采用 林中漫步 先生的设计，而是通过精确到秒的时间做Score（去掉毫秒），然后使用线程每一秒扫一次，使用当前时间作为zrangeBysocre命令的Score去查询。详细请看代码。<br>业务场景：按京东一天500万的成交量，一天主要成交时间为8小时，计算得出每秒173个订单，当然实际上订单不能均匀分布在每秒，但我们主要为了论证思想的可行性。<br>代码实现：这里首先我简单的利用Spring Scheduled作为订单的生产者，每一秒制造170个订单，放入Redis，注意Score的生成，为当前时间的后60秒，removeMillis()生成去掉毫秒的时间戳作为Rredis的Zadd方法的 Score（不了解的可以百度下）。</em><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Componment</span><br><span class="line"><span class="keyword">public</span> class OrderHanlder&#123;</span><br><span class="line">  <span class="keyword">private</span> Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line">  <span class="keyword">private</span> AtomicLong currentOrderId = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> simpleDateFormat sdformat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> KEY = <span class="string">"orders"</span>;</span><br><span class="line">  </span><br><span class="line">  @Scheduled(cron = <span class="string">"0/1 * * * * *"</span>)</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> initData() <span class="keyword">throws</span> ParseException&#123;</span><br><span class="line">   Calendar cal = <span class="keyword">new</span> Calendar();</span><br><span class="line">   cal.<span class="built_in">add</span>(Calender.SECOND,<span class="number">60</span>);<span class="comment">//获取当前日期的后60秒</span></span><br><span class="line">   Map&lt;<span class="keyword">String</span>,Double&gt; scores = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">//一天500w的成交量，8小时计算，每秒成交173份订单</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;<span class="number">170</span>;i++)&#123;</span><br><span class="line">     currentOrderId.getAndIncrement();</span><br><span class="line">     scores.put(currentOrderId.toString(),(<span class="keyword">double</span>)removeMillis(cal));</span><br><span class="line">     jedis.zadd(<span class="variable">key</span>,scores);</span><br><span class="line">     System.out.<span class="built_in">println</span>(<span class="string">"当前订单ID：---------"</span>+currentOrderId);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> removeMills(Canendar cal) <span class="keyword">throws</span> ParseException&#123;</span><br><span class="line">    <span class="keyword">String</span> date = sdformat.format(cal.getTime());</span><br><span class="line">    Date nowTime = sfformat.parse(date);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"---------当前时间： "</span>+nowTime + <span class="string">"-----毫秒数 "</span>+nowTime.getTime());</span><br><span class="line">    <span class="keyword">return</span> nowTime.getTime();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二步：同样利用Spring Scheduled 一秒钟心跳一次，每次利用当前时间作为Key 从Redis 取数据。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Scheduled</span>(cron=<span class="string">"0/1 * * * * *"</span>)</span><br><span class="line">public <span class="type">void</span> consumer() throws <span class="type">ParseException</span>&#123;</span><br><span class="line">  <span class="type">Calendar</span> cal = <span class="type">Calendar</span>.getInstance();</span><br><span class="line">  long score = removeMills(cal);</span><br><span class="line">  <span class="type">Set</span>&lt;<span class="type">String</span>&gt; orders = <span class="type">Jedis</span>.zrangeByScore(<span class="type">KEY</span>,<span class="number">0</span>,score);//早于当前时间的都应该被发送，因为可能订单太多没有处理过来</span><br><span class="line">  <span class="keyword">if</span>(orders.isEmpty()||orders,size() == <span class="number">0</span>)</span><br><span class="line">    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"========================暂时没有订单，时间："</span>+cal.getTime());</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">String</span> order:orders)&#123;</span><br><span class="line">    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"^^^^^^^^^^^^^^^^^^^^^^^^处理订单，订单ID： "</span>+order);</span><br><span class="line">    long <span class="literal">result</span> = jedis.zrem(<span class="type">KEY</span>,order);</span><br><span class="line">    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"^^^^^^^^^^^^^^^^^^^^^^^^处理完毕，订单ID： "</span>+order+<span class="string">" 删除结果"</span>+(<span class="literal">result</span> ==<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> private long removeMills(<span class="type">Canendar</span> cal) throws <span class="type">ParseException</span>&#123;</span><br><span class="line">    <span class="type">String</span> date = sdformat.format(cal.getTime());</span><br><span class="line">    <span class="type">Date</span> nowTime = sfformat.parse(date);</span><br><span class="line">    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"---------当前时间： "</span>+nowTime + <span class="string">"-----毫秒数 "</span>+nowTime.getTime());</span><br><span class="line">    <span class="keyword">return</span> nowTime.getTime();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>经过测试，没有出现漏单的情况，这只是简单的实现，很多地方可以优化，在实际中用也可能会出现很多问题，需要不断完善，此案例只是提供思路，另外我觉得JDK的 DelayQueue 相对于Redis来说没有那么好，因为Queue毕竟每次取一个，如果同一时间的比较多可能不能符合当前这种时间严谨的需求，另外他是单机的，有时间我去研究下kafka、Rabbit的延迟队列再来补充。</p>
<p>20.多维度查询的解决方案有哪些？<br><em>我们现在的公寓特别多，在页面用户可以根据多种维度进行筛选，比如“面积、房间、豪华程度、小区、新旧、交通、价格……”，这种场景如果放在数据库进行过滤，肯定是作死的节奏。</em><br> 这种一般用Nosql，而不是关系型数据库，比如elasticsearch搜索引擎，k-v键值对，可对同个商品同时建立多个标签进行多维度搜索，支持分页，高性能<br> 一般可以通过搜索引擎的方式来解决,比如ES,性能上无压力,无限集群<br> solr facet</p>
<p>21.集群环境如何保证某个机器挂掉了ng请求不再有访问打到这个机器<br><strong>Nginx有个负载均衡的插件叫做 nginx-upstream-fair：按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br>这种负载策略应该可以解决你那种问题，不用轮询。</strong></p>
<p>22.遇到OOM如何处理<br><strong>首先，要搞清OOM的分类：<br>OMM主要三类： permgen OOM , heap OOM, stack overflow<br>permgen OOM: 这个主要是由于加载的类太多，或者反射的类太多， 还有 调用 String.intend（jdk7之前）也会造成这个问题。所以出现了这个问题，就检查这三个方面；<br>heap OOM： 基本是按照 1楼的方式就可以解决了，主要是因为一些无用对象没有及时释放造成的，检查代码加上 heap dump 去分析吧<br>stack overflow： 这个主要是由于调用层数，或者递归深度太大造成的，看异常信息，基本上就能定位得出来了</strong></p>
<ul>
<li><h3 id="Java_集合类源码_？？？">Java 集合类源码 ？？？</h3><ol>
<li>涉及到堆栈，队列等操作，应该考虑用List。</li>
<li>需要快速插入，删除元素，应该使用LinkedList。</li>
<li>需要快速随机访问元素，应该使用ArrayList。</li>
</ol>
</li>
<li><h3 id="设计模式的实际应用_？？？">设计模式的实际应用 ？？？</h3><p>1.单例模式<br>2.工厂模式<br>3.责任链模式<br>4.代理模式<br>5.模板方法模式-回调函数<br>6.策略模式<br>7.组合模式-递归调用<br>8.门面模式<br>9.观察者模式<br>10.中介者模式<br>11.享元模式<br>12.原型模式<br>13.命令模式<br>14.迭代器模式<br>15.桥接模式<br>16.构造者模式<br>17.适配器模式<br>18.备忘录模式<br>19.访问者模式<br>20.工厂方法模式<br>21.状态模式<br>22.解释器模式<br>23.装饰者模式</p>
</li>
<li><h3 id="Spring">Spring</h3><p>参考黄亿华老师的<strong>1000行代码读懂Spring核心</strong><br>大部分的框架都是由静态配置产生动态代码<br>如何编写一个Spring<br><strong>Spring IoC主线中的大部分重要角色：<br>BeanDefinition,BeanFactory,ApplicationContext<br>Resource,BeanDefinitionReader,PropertyValue,BeanReference</strong></p>
</li>
</ul>
<p>1.Ioc-给你想要的</p>
<ul>
<li><p>最基本的容器-包括注入和获取功能<br>BeanDefinition-保存Bean及配置信息（Bean）<br>BeanFactory-对Bean进行管理（Map-registerBeanDefinition/getBean）<br>核心流程：</p>
<pre><code><span class="number">1.</span> 初始化BeanFactory
<span class="number">2.</span> 注册Bean
<span class="number">3.</span> 获取Bean
</code></pre></li>
<li><p>将Bean创建放入工厂-管理Bean的生命周期<br>抽象BeanFactory-面向接口更易扩展<br>在AbstractBeanFactory内部初始化Bean（BeanFactory-AbstractBeanFactory-AutowireCapableBeanFactory）<br>核心流程:</p>
<pre><code><span class="number">1</span>. 初始化<span class="keyword">BeanFactory </span>面向接口编程 <span class="keyword">BeanFactory </span><span class="keyword">beanFactory </span>= new AutowireCapableBeanFactory()<span class="comment">;</span>
<span class="number">2</span>. 注册<span class="keyword">Bean </span><span class="keyword">BeanDefinition(Bean/BeanClass/BeanClassName) </span>在AutowireCapableBeanFactory中
   实现Class.forName(<span class="keyword">beanClassName).newInstance(); </span>
<span class="number">3</span>. 获取<span class="keyword">Bean</span>
</code></pre></li>
<li><p>为bean注入属性<br>PropertyValue-保存属性注入信息（name/value）<br>PropertyValues（List<propertyvalue> add/getList）<br>AutowireCapableBeanFactory-可自动装配的BeanFactory-newInstance()/applyPropertyValues(Field)<br>BeanDefinition（Bean/BeanClass/BeanClassName/PropertyValues）<br>核心流程：</propertyvalue></p>
<pre><code><span class="number">1</span>. 初始化<span class="keyword">BeanFactory </span>同上
<span class="number">2</span>. <span class="keyword">Bean的定义 </span><span class="keyword">beanDefinition.setBeanClassName("xxxx");
</span><span class="number">3</span>. 属性设置   PropertyValues.<span class="keyword">addPropertyValue(new </span>PropertyValue(<span class="string">"name"</span>,<span class="string">"xxxxx"</span>))<span class="comment">;</span>
<span class="number">4</span>. 注册<span class="keyword">Bean </span> <span class="keyword">beanFactory.registerBeanDefinition(beanName, </span><span class="keyword">beanDefinition);
</span><span class="number">5</span>. 获取<span class="keyword">Bean </span> <span class="keyword">beanFactory.getBean(beanName);</span>
</code></pre><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(Object bean, BeanDefinition mbd)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (PropertyValue propertyValue : mbd.getPropertyValues().getPropertyValues()) &#123;</span><br><span class="line">			Field declaredField = bean.getClass().getDeclaredField(propertyValue.getName());</span><br><span class="line">			declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			declaredField.set(bean, propertyValue.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取xml配置初始化bean<br>从XML中读取BeanDefinition-将代码变为配置<br>BeanDefinitionReader-配置读取者 XmlBeanDefinitionReader extends AbstractBeanDefinitionReader implements BeanDefinitionReader<br>XmlBeanDefinitionReader-从XML中读取配置<br>读取Xml并解析 Element（name/class/property/name/value）<br>Resource-定位资源文件 UrlResource implements Resource<br>核心流程：</p>
<pre><code><span class="number">1.</span> 读取配置
<span class="number">2.</span> 初始化BeanFactory并注册bean
<span class="number">3.</span> 获取bean
</code></pre><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">XmlBeanDefinitionReader</span> xmlBeanDefinitionReader = new XmlBeanDefinitionReader(new ResourceLoader())<span class="comment">;</span></span><br><span class="line"><span class="label">xmlBeanDefinitionReader.loadBeanDefinitions</span>(<span class="string">"tinyioc.xml"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">BeanFactory </span><span class="keyword">beanFactory </span>= new AutowireCapableBeanFactory()<span class="comment">;</span></span><br><span class="line"><span class="label">for</span> (<span class="preprocessor">Map</span>.Entry&lt;<span class="keyword">String, </span><span class="keyword">BeanDefinition&gt; </span><span class="keyword">beanDefinitionEntry </span>: xmlBeanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">	<span class="keyword">beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), </span><span class="keyword">beanDefinitionEntry.getValue());</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>为bean注入bean - 解析依赖<br>BeanReference-保存对Bean的引用 （name/bean）<br>getBean()中调用createBean()-lazy-init<br>XmlBeanDefinitionReader-解析XML的时候增加bean的关联依赖</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//<span class="type">XmlBeanDefinitionReader</span></span><br><span class="line">private <span class="type">void</span> processProperty(<span class="type">Element</span> ele, <span class="type">BeanDefinition</span> beanDefinition) &#123;</span><br><span class="line">		<span class="type">NodeList</span> propertyNode = ele.getElementsByTagName(<span class="string">"property"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; propertyNode.getLength(); i++) &#123;</span><br><span class="line">			<span class="type">Node</span> node = propertyNode.item(i);</span><br><span class="line">			<span class="keyword">if</span> (node instanceof <span class="type">Element</span>) &#123;</span><br><span class="line">				<span class="type">Element</span> propertyEle = (<span class="type">Element</span>) node;</span><br><span class="line">				<span class="type">String</span> name = propertyEle.getAttribute(<span class="string">"name"</span>);</span><br><span class="line">				<span class="type">String</span> value = propertyEle.getAttribute(<span class="string">"value"</span>);</span><br><span class="line">				<span class="keyword">if</span> (value != null &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					beanDefinition.getPropertyValues().addPropertyValue(new <span class="type">PropertyValue</span>(name, value));</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="type">String</span> <span class="keyword">ref</span> = propertyEle.getAttribute(<span class="string">"ref"</span>);</span><br><span class="line">					<span class="keyword">if</span> (<span class="keyword">ref</span> == null || <span class="keyword">ref</span>.length() == <span class="number">0</span>) &#123;</span><br><span class="line">						throw new <span class="type">IllegalArgumentException</span>(<span class="string">"Configuration problem: &lt;property&gt; element for property '"</span></span><br><span class="line">								+ name + <span class="string">"' must specify a ref or value"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="type">BeanReference</span> beanReference = new <span class="type">BeanReference</span>(<span class="keyword">ref</span>);</span><br><span class="line">					beanDefinition.getPropertyValues().addPropertyValue(new <span class="type">PropertyValue</span>(name, beanReference));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">//<span class="type">AutowireCapableBeanFactory</span>    </span><br><span class="line">protected <span class="type">void</span> applyPropertyValues(<span class="type">Object</span> bean, <span class="type">BeanDefinition</span> mbd) throws <span class="type">Exception</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">PropertyValue</span> propertyValue : mbd.getPropertyValues().getPropertyValues()) &#123;</span><br><span class="line">			<span class="type">Field</span> declaredField = bean.getClass().getDeclaredField(propertyValue.getName());</span><br><span class="line">			declaredField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">			<span class="type">Object</span> value = propertyValue.getValue();</span><br><span class="line">			<span class="keyword">if</span> (value instanceof <span class="type">BeanReference</span>) &#123;</span><br><span class="line">				<span class="type">BeanReference</span> beanReference = (<span class="type">BeanReference</span>) value;</span><br><span class="line">				value = getBean(beanReference.getName());</span><br><span class="line">			&#125;</span><br><span class="line">			declaredField.<span class="type">set</span>(bean, value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>同时为了解决循环依赖的问题，我们使用lazy-init的方式，将createBean的事情放到getBean的时候才执行<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractBeanFactory</span></span><br><span class="line">@Override</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">Object</span> getBean(<span class="keyword">String</span> name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		BeanDefinition beanDefinition = beanDefinitionMap.<span class="built_in">get</span>(name);</span><br><span class="line">		<span class="keyword">if</span> (beanDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No bean named "</span> + name + <span class="string">" is defined"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">Object</span> bean = beanDefinition.getBean();</span><br><span class="line">		<span class="keyword">if</span> (bean == <span class="keyword">null</span>) &#123;</span><br><span class="line">			bean = doCreateBean(beanDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>  核心流程：</p>
<pre><code><span class="number">1.</span> 读取配置
<span class="number">2.</span> 初始化BeanFactory并注册bean
<span class="number">3.</span> 初始化bean
<span class="number">4.</span> 获取bean
</code></pre><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line">XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">new</span> ResourceLoader());</span><br><span class="line">xmlBeanDefinitionReader.loadBeanDefinitions(<span class="string">"tinyioc.xml"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line">AbstractBeanFactory beanFactory = <span class="keyword">new</span> AutowireCapableBeanFactory();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : xmlBeanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">	beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.</span></span><br><span class="line"> beanFactory.getBean(<span class="string">"helloWorldService"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>ApplicationContext登场<br>引入ApplicationContext-包装Bean的初始化流程，对应用透明<br>BeanFactory-&gt;ApplicationContext-&gt;AbstractApplicationContext-&gt;ClassPathXmlApplicationContext<br>组合优于继承<br>refresh()-变lazy-init为提前初始化</li>
</ul>
<p>现在BeanFactory的功能齐全了，但是使用起来有点麻烦。于是我们引入熟悉的ApplicationContext接口，并在AbstractApplicationContext的refresh()方法中进行bean的初始化工作。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ClassPathXmlApplicationContext</span></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">new</span> ResourceLoader());</span><br><span class="line">		xmlBeanDefinitionReader.loadBeanDefinitions(configLocation);</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : xmlBeanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">			beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ApplicationContext</span> applicationContext = new ClassPathXmlApplicationContext(<span class="string">"tinyioc.xml"</span>);</span><br><span class="line"><span class="title">HelloWorldService</span> helloWorldService = (HelloWorldService) applicationContext.getBean(<span class="string">"helloWorldService"</span>);</span><br></pre></td></tr></table></figure>
<p>  2.Aop-做你不想做的<br>  常用的几个Aop概念<br>  MethodInvocation&lt;=Joinpoint - 切的是什么<br>  MethodInterceptor&lt;=Advice - 切了做什么<br>  Pointcut - 切哪里<br>  Aspect - 谁在切<br>  Advisor - 只有一个Advice的的Aspect(Spring独有)<br>  知道切哪 - 定义Pointcut<br>  怎么切 - 定义Advisor<br>  开始切 - Weave<br>  Spring的AOP只是方法级别的</p>
<ul>
<li>使用JDK动态代理实现AOP织入<br>先从织入开始<ol>
<li>AdvisedSupport - 保存AOP配置</li>
<li>TargetSource - 保存被代理的数据<br>织入和代理</li>
<li>AopProxy- 对目标对象做代理，在调用目标方法前线调用它</li>
<li>JdkDynamicAopProxy- 使用JDK动态代理对接口做代理</li>
<li>RelectiveMethodInvocation - 将反射的Method封装为Joinpoint</li>
</ol>
</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">testInterceptor</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// --------- helloWorldService without AOP</span></span><br><span class="line">		ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"tinyioc.xml"</span>);</span><br><span class="line">		HelloWorldService helloWorldService = (HelloWorldService) applicationContext.getBean(<span class="string">"helloWorldService"</span>);</span><br><span class="line">		helloWorldService.helloWorld();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// --------- helloWorldService with AOP</span></span><br><span class="line">		<span class="comment">// 1. 设置被代理对象(Joinpoint)</span></span><br><span class="line">		AdvisedSupport advisedSupport = <span class="keyword">new</span> AdvisedSupport();</span><br><span class="line">		TargetSource targetSource = <span class="keyword">new</span> TargetSource(helloWorldService, HelloWorldService.class);</span><br><span class="line">		advisedSupport.setTargetSource(targetSource);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 设置拦截器(Advice)</span></span><br><span class="line">		TimerInterceptor timerInterceptor = <span class="keyword">new</span> TimerInterceptor();</span><br><span class="line">		advisedSupport.setMethodInterceptor(timerInterceptor);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3. 创建代理(Proxy)</span></span><br><span class="line">		JdkDynamicAopProxy jdkDynamicAopProxy = <span class="keyword">new</span> JdkDynamicAopProxy(advisedSupport);</span><br><span class="line">		HelloWorldService helloWorldServiceProxy = (HelloWorldService) jdkDynamicAopProxy.getProxy();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 4. 基于AOP的调用</span></span><br><span class="line">		helloWorldServiceProxy.helloWorld();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function">Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">"Invocation of Method "</span> + invocation.getMethod().getName() + <span class="string">" start!"</span>);</span><br><span class="line">		Object <span class="keyword">proceed</span> = invocation.<span class="keyword">proceed</span>();</span><br><span class="line">		System.out.println(<span class="string">"Invocation of Method "</span> + invocation.getMethod().getName() + <span class="string">" end! takes "</span> + (System.nanoTime() - time)</span><br><span class="line">				+ <span class="string">" nanoseconds."</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">proceed</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于jdk的动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> AdvisedSupport advised;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">JdkDynamicAopProxy</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.advised = advised;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(getClass().getClassLoader(), <span class="keyword">new</span> Class[] &#123; advised.getTargetSource()</span><br><span class="line">				.getTargetClass() &#125;, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Object proxy, <span class="keyword">final</span> Method method, <span class="keyword">final</span> Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		MethodInterceptor methodInterceptor = advised.getMethodInterceptor();</span><br><span class="line">		<span class="keyword">return</span> methodInterceptor.invoke(<span class="keyword">new</span> ReflectiveMethodInvocation(advised.getTargetSource().getTarget(), method,</span><br><span class="line">				args));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用AspectJ管理切面<br>AspectJ 基于表达式的Java AOP扩展<br>定义Pointcut - 在哪里切<br>ClassFilter &amp; MethodMatcher - 对类和方法调用做判断<br>AspectJExpressionPointcut - 基于Aspectj表达式的Poingcut</li>
</ul>
<ul>
<li>将AOP融入Bean的创建过程<br>将AOP融入BeanFactory<br>BeanPostProcessor - 提供Bean生命周期中的扩展点<br>BeanPostProcessor - 需要先加载？ - DefaultListableBeanFactory.getBeanNamesForType(Class),按类型扫描，优先于其他Bean的初始化进行<br>BeanFactoryAware - 在Bean中获知BeanFactory<br>Advisor = Advice + Pointcut<br>AspectJAeareAdvisorAutoProxyCreator - 自动完成Pointcut扫描，并将Bean替换成Proxy实现</li>
<li>使用CGLIB进行类的织入<br>前面的JDK动态代理只能对接口进行代理，对于类则无能为力。这里我们需要一些字节码操作技术。这方面大概有几种选择：ASM，CGLib和javassist，后两者是对ASM的封装。Spring中使用了CGLib。<ul>
<li><h3 id="Tomcat">Tomcat</h3>参考前面总结的内容</li>
</ul>
</li>
</ul>
<ul>
<li><h3 id="Openfire源码_-_10天">Openfire源码 - 10天</h3></li>
<li><h3 id="Mysql_sql优化_-_3天">Mysql sql优化 - 3天</h3></li>
<li><h3 id="Java_多线程_-_？？">Java 多线程 - ？？</h3></li>
<li><h3 id="Redis">Redis</h3><p>五种数据类型</p>
<ol>
<li>String</li>
<li>List  - 链表 push/pop 栈和队列</li>
<li>Hash - 适用于存储 对象</li>
<li>Set  - 集合 并差交补操作</li>
<li>Sort Set<br><strong>★★★在正式环境中的应用★★★</strong></li>
</ol>
</li>
</ul>
<ul>
<li><h3 id="脚本经验_-_nutch启动脚本">脚本经验 - nutch启动脚本</h3></li>
<li><h3 id="Jvm调优">Jvm调优</h3><p>实战例子？？？</p>
</li>
<li><h3 id="TCP/HTTP_协议，粘包，拆包问题_Socket/ServerSocket">TCP/HTTP 协议，粘包，拆包问题 Socket/ServerSocket</h3><p>自己实现简单的web服务器 ？？？</p>
</li>
</ul>
<h2 id="2-简历准备">2.简历准备</h2><h2 id="3-工作总结">3.工作总结</h2><h2 id="4-小故事贮备">4.小故事贮备</h2><h2 id="5-职业规划">5.职业规划</h2><h2 id="6-心态调整">6.心态调整</h2><h2 id="7-准备面试">7.准备面试</h2><h3 id="常见面试题目整理">常见面试题目整理</h3><p>1.自我介绍<br>2.hashMap原理-&gt;线程安全ConcurrentHashMap原理<br>3.可重入锁- Java内存模型<br>4.volatile变量的用法<br>5.算法字符串翻转<br>6.mysqlB-树索引的优点，为什么不用二叉树<br>7.项目中有什么困难，如何解决<br>8.jvm内存模型<br>9.定义二叉树，判断此二叉树是否对称<br>10.mysql组合索引，什么时候组合索引失效<br>11.https实现过程<br>12.tcp/udp区别，tcp的三次握手<br>13.innodb和myisam区别<br>14.自己实现一个线程池，要考虑的点<br>15.目前项目中的优化<br>16.linux命令<br>17.jvm的gc机制<br>18.多线程同步怎么做<br>19.Spring的AOP是如何实现的<br>20.缓存机制，项目中用到过吗<br>21.”如果出现大面积并发，在不增加服务器的基础上，如何解决服务器响应不及时问题“。性能调优<br>22.强引用，软引用，弱引用<br>23.你对mysql熟悉吗？说说mysql索引如何建立的<br>24.什么时候使用字节流、什么时候使用字符流<br>25.适配器模式的类图知道吗？<br>26.你觉得你还有哪里比较擅长，在这次面试中没有聊起来的吗？</p>
<p>一、Java基础<br>1.String类为什么是final的。<br>2.HashMap的源码，实现原理，底层结构。<br>3.反射中，Class.forName和classloader的区别<br>4.session和cookie的区别和联系，session的生命周期，多个服务部署时session管理。<br>5.Java中的队列都有哪些，有什么区别。<br>6.Java的内存模型以及GC算法<br>7.Java7、Java8的新特性(baidu问的,好BT)<br>8.Java数组和链表两种结构的操作效率，在哪些情况下(从开头开始，从结尾开始，从中间开始)，哪些操作(插入，查找，删除)的效率高<br>9.Java内存泄露的问题调查定位：jmap，jstack的使用等等 </p>
<p>二、框架<br>1.struts1和struts2的区别<br>2.struts2和springMVC的区别<br>3.spring框架中需要引用哪些jar包，以及这些jar包的用途<br>4.srpingMVC的原理<br>5.springMVC注解的意思<br>6.spring中beanFactory和ApplicationContext的联系和区别<br>7.spring注入的几种方式<br>8.spring如何实现事物管理的<br>9.springIOC和AOP的原理<br>10.hibernate中的1级和2级缓存的使用方式以及区别原理<br>11.spring中循环注入的方式 </p>
<p>三、多线程<br>1.Java创建线程之后，直接调用start()方法和run()的区别<br>2.常用的线程池模式以及不同线程池的使用场景<br>3.newFixedThreadPool此种线程池如果线程数达到最大值后会怎么办，底层原理。<br>4.多线程之间通信的同步问题，synchronized锁的是对象，衍伸出和synchronized相关很多的具体问题，例如同一个类不同方法都有synchronized锁，一个对象是否可以同时访问。或者一个类的static构造方法加上synchronized之后的锁的影响。<br>5.了解可重入锁的含义，以及ReentrantLock 和synchronized的区别<br>6.同步的数据结构，例如concurrentHashMap的源码理解以及内部实现原理，为什么他是同步的且效率高<br>7.atomicinteger和volatile等线程安全操作的关键字的理解和使用<br>8.线程间通信，wait和notify<br>9.定时线程的使用<br>10.场景：在一个主线程中，要求有大量(很多很多)子线程执行完之后，主线程才执行完成。多种方式，考虑效率。 </p>
<p>四、网络通信<br>1.http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么。<br>2.socket通信，以及长连接，分包，连接异常断开的处理。<br>3.socket通信模型的使用，AIO和NIO。<br>4.socket框架netty的使用，以及NIO的实现原理，为什么是异步非阻塞。<br>5.同步和异步，阻塞和非阻塞。 </p>
<p>五、Linux<br>1.常用的linux下的命令<br>2.大的log文件中，统计异常出现的次数、排序，或者指定输出多少行多少列的内容。(主要考察awk)<br>3.linux下的调查问题思路：内存、CPU、句柄数、过滤、查找、模拟POST和GET请求等等场景<br>4.shell脚本中#！的作用 </p>
<p>六、数据库MySql<br>1.MySql的存储引擎的不同<br>2.单个索引、联合索引、主键索引<br>3.Mysql怎么分表，以及分表后如果想按条件分页查询怎么办(如果不是按分表字段来查询的话，几乎效率低下，无解)<br>4.分表之后想让一个id多个表是自增的，效率实现<br>5.MySql的主从实时备份同步的配置，以及原理(从库读主库的binlog)，读写分离<br>6.写SQL语句。。。<br>7.索引的数据结构，B+树<br>8.事物的四个特性，以及各自的特点（原子、隔离）等等，项目怎么解决这些问题 </p>
<p>七、设计模式(写代码)<br>1.单例模式：饱汉、饿汉。以及饿汉中的延迟加载<br>2.工厂模式、装饰者模式、观察者模式。 </p>
<p>八、算法<br>1.使用随机算法产生一个数，要求把1-1000W之间这些数全部生成。（考察高效率，解决产生冲突的问题）<br>2.两个有序数组的合并排序<br>3.一个数组的倒序<br>4.计算一个正整数的正平方根<br>5.说白了就是常见的那些查找排序算法（排序转载：<a href="http://mp.weixin.qq.com/s?__biz=MjM5MTAzMTE4Nw==&amp;mid=204838393&amp;idx=2&amp;sn=e9b50c8ef689e2cb6436110a8dc148a3&amp;scene=5#rd）" target="_blank" rel="external">http://mp.weixin.qq.com/s?__biz=MjM5MTAzMTE4Nw==&amp;mid=204838393&amp;idx=2&amp;sn=e9b50c8ef689e2cb6436110a8dc148a3&amp;scene=5#rd）</a> </p>
<p>九、缓存<br>1.为什么用缓存，用过哪些缓存，redis和memcache的区别<br>2.redis的数据结构<br>3.redis的持久化方式，以及项目中用的哪种，为什么<br>4.redis集群的理解，怎么动态增加或者删除一个节点，而保证数据不丢失。（一致性哈希问题） </p>
<p>5.Linux使用与问题分析排查</p>
<p>1）. grep，awk，sed； 是否自己写过shell脚本；<br>2）. 常见的cpu load过高，us过高，一般是什么问题。引申出是否用过top，jstat，jstack等。 常见的内存问题一般有哪些。 引申出是否用过free，top， jmap等。</p>
<ol>
<li><p>框架使用 spring aop的底层实验原理。 aop与cglib，与asm的关系。 spriong ioc的生命周期，（init-method，intilizingbean接口方法afterPropertiesSet的先后顺序）等。 Hibernate对一二级缓存的使用，Lazy-Load的理解；</p>
</li>
<li><p>数据库相关： 1. mysql存储引擎中索引的实现机制； 2.数据库事务的几种粒度； 3.行锁，表锁；乐观锁，悲观锁</p>
</li>
</ol>
<p>8.网络协议： HTTP协议； HTTPS协议，SSL协议及完整交互过程；</p>
<ol>
<li>redis redis，memcache底层客户端使用一致性Hash，看是否了解； redis的事件驱动多路复用底层实现；引申到NIO编程， 看对Netty，或mina是否了解。 如果候选者同时用过memcache，redis，看下是否了解两者在使用场景上的区别。以考察使用深度，以及是否有好奇精神。</li>
</ol>
<p>10.什么是CDN？如果实现？DNS起到什么作用？</p>
<p>1、滴滴<br>    先吐槽下滴滴面试安排，如果你通过了一面，那么就优先安排后面的面试，所以导致还没一面的人就得一直苦等。那会儿我是下午一点去的，大概到了快4点才进行一面，后面就嗖嗖嗖地过关斩将到了hr面，也算是运气不错吧。<br>交叉1面<br>垃圾回收算法<br>(代码)01矩阵，相邻的1是一个岛屿，找出所有岛屿数（递归解决）<br>有关注过开源社区吗，都看过哪些源码<br>AtomicInteger实现原理(CAS自旋)<br>synchronized和reentrantLock区别<br>介绍spring的IOC和AOP，分别如何实现(classloader、动态代理)<br>redis如何处理分布式服务器并发造成的不一致(本身就是单线程序列化的隔离级别)，如果数据库不提供隔离呢<br>OSGi的机制(因为简历写了)<br>交叉2面<br>2个鸡蛋，100高的楼，最少的次数测出鸡蛋碎掉的临界层，没碎的鸡蛋可以反复用（没做出，应该是14次，网上有解法）<br>大量字符串找出数量最多的K个，考虑内存放得下和放不下两种情况<br>解释mysql索引、b树，为啥不用平衡二叉树、红黑树(磁盘和内存的存储方式不同)<br>垃圾回收算法，为什么要分代处理<br>跳表(不熟，没继续)<br>IO(不熟，没继续)<br>epoll(不熟，没继续)<br>一致性hash<br>zookeeper如何同步配置(不熟，没继续)<br>讲下java锁的原理<br>ConcurrentHashMap原理<br>BOSS面<br>(代码)最长回文子串<br>GC停顿原因，如何降低停顿<br>JVM如何调优、参数怎么调<br>如何用工具分析jvm状态（visualVM看堆中对象的分配，对象间的引用、是否有内存泄漏，jstack看线程状态、是否死锁等等）<br>进程和线程区别<br>epoll和select区别(不熟，没继续)<br>解释mysql索引、b树<br>hr面<br>五个词来描述自己<br>长期的计划<br>兴趣爱好<br>期望薪水<br>对岗位的要求<br>已经拿到的offer<br>   hr告诉我滴滴主要还是用c和php（看来我这次算是误打误撞），然后和我说php多快呀，多容易呀，要不要到碗里来？呵呵呵<br>java岗面<br>（代码）含Double数据的list，找出最长连续递增序列的长度（连续递增比较简单，看你代码质量）<br>找出最长递增子序列的长度，说思路（dp算法，复杂度O(n)）<br>mysql中int的最大填充长度（我记得是255，被告知是错的），varchar不同编码下的存储字符个数<br>写SQL，多表连接查昨天的第二多的值<br>js题，考察闭包</p>
<p>2、美团<br>    美团的面试安排在下午，不用早起真好~ 等候区就在1楼，工作人员供了面包和一次性杯子，旁边就是运动区，有跑步机、乒乓球桌、桌上足球及一些运动器材，感觉环境还是很不错的（此处应该吐槽下京东，场面极其混乱）。<br>       面试一共三轮，会有工作人员叫名字让你进去面试，就是中间的等待有点久。每轮通过的话就会留下来接着下一面，没过的话工作人员会告诉你“很抱歉，你今天的面试已经结束了”，特别是在漫长的等待中，周围的人一个个被“很抱歉”，那个心理压力可不是一般大。然后就是全部的面试经过，大概整理了下，发现运气还不错，都可以答得上来。面试问题只是参照，面试官会根据你的简历来问针对性的问题，而你也可以引导他来问你擅长的领域，当然有些基础的东西还是必须了解的，比如jvm、spring框架、持久化框架、数据库之类的。<br>一面<br>介绍实习经历，讲项目<br>解释https (先公私钥加密，再对称加密) 为什么不直接公私钥<br>jvm中类加载过程，解释双亲委派加载，及类是在哪个加载器加载的<br>传值、传引用 传入对象引用，指向一个new的对象，问主函数里的会变吗<br>找出数组中最多的那个数，除了hashset还有没其他方法（只想到蒙特卡罗法）<br>(代码)输入合法的数字字符串，输出货币字符，就是每隔3位加个逗号，考虑边界处理<br>(代码)有1-10 10个数，和一个数sum，计算用10个数连加得到sum有多少种系数组合（递归）<br>二面<br>自我介绍，讲项目<br>spring中bean加载机制，bean生成的具体步骤<br>ioc注入的方式<br>spring何时创建applicationContext(web.xml中使用listener)<br>listener是监听哪个事件(ServletContext创建事件)<br>springMVC流程具体叙述下<br>synchronized和reentrantLock的区别，synchronized用在代码快、方法、静态方法时锁的都是什么<br>介绍ConcurrentHashMap原理，用的是哪种锁，segment有没可能增大（不会，只会增大每个segment中的entry数组）<br>如何实现高效的同步链表<br>(代码)层次遍历二叉树，偶数层输出逆序输出(队列，用一个标记记录每一层的结束，统一输出当前层)<br>三面<br>介绍实习经历，讲项目<br>(代码)给定一个字符串，写出所有可能的全排列(递归)<br>剩下的就是问一下hr面的问题：<br>怎么理解踏实，你在项目中哪儿体现到了<br>最近最有成就感的事<br>你的优点 缺点<br>最近在看的技术<br>是否写过其他个人兴趣的小项目<br>写技术博客吗，github呢<br>个人职位目标<br>    三面的面试官还是很nice的，最后的部门好像也是由三面的来挑。面试结束第二天就让签了两方，待遇也没得谈。</p>
<p>3、网易<br>   面试等待时间赶超了滴滴，上午10点等到下午两点才刚开始一面。hr面结束都5点多了，正赶上下班高峰期，公交又堵了好久，回去后感觉浑身都已经无力了。<br>一面<br>介绍了下阿里的实习项目，问了下对SOA和OSGi的认识，以及之间的关系<br>项目中遇到的最难忘的问题，如何解决的（网上搜索、问经验丰富的、断点调试跟进源码、技术论坛发帖）<br>问了擅长的java领域，针对性提问（jvm、容器、并发）<br>介绍jvm内存机制（把各个内存区域作用、回收算法、收集器分类统统说了一遍）<br>创建线程方式（实现runnable接口、集成Thread、线程池）<br>java都有哪些加锁方式（synchronized、ReentrantLock、共享锁、读写锁等）<br>想让所有线程都等到一个时刻同时执行有哪些方法（介绍了下CountDownLatch和CyclicBarrier）<br>volatile的作用（使变量对所有线程可见，同时禁止指令重排序）<br>都用过哪些java容器，LinkedList都一般都在什么时候用到（经常插入删除时、实现队列和栈时）<br>介绍ConcurrentHashMap（分段加锁，几乎每个面试都问这个。。。）<br>Object里头都有哪些方法，着重问了clone(深复制还是浅复制)、finalize（一般在什么时候用，回收时一定能被运行）<br>二面<br>问题和一面差不多，很多重复的就不说了<br>如何管理线程（介绍了各种线程池的实现）<br>如何让线程A等待线程B结束后再执行（join、单线程池），还反问单线程池真的可以吗，所以大致和他介绍了下阻塞队列的机制<br>如何优化jvm参数（堆大小、xmx一般和xms设成一样大、永久代大小、收集器选择、收集器参数、新生代对象年龄阈值等）<br>hr面<br>很少见的男hr，性格温和，谈起来很轻松愉快<br>介绍所有的项目<br>对在阿里的实习如何评价，对mentor如何评价<br>在阿里有没什么让你比较惋惜的地方（内部论坛资源非常丰富，都是大牛的知识帖，后悔看得太少）<br>喜欢何种风格的领导，是严格的技术型还是宽松的管理型<br>你的职业规划，转管理还是一直技术<br>喜欢的兴趣爱好<br>针对我写到的旅游又问了，去哪儿旅游过，通常都是如何准备一次旅行的（查各种攻略、做旅行计划，叫上小伙伴），是否写游记呢（很少），对写游记的人如何评价（为他们点赞~）<br>最近在看什么书籍呢（各种技术类书籍）<br>是否能提前来实习<br>已经拿到的offer<br>目标薪资</p>
<p>4、58赶集<br>  58就在798旁边，面试完后特地去在寒风中感受了下艺术气息。签到的时候可以看到自己笔试的分数，貌似是按分数排的面试顺序。不想更加纠结所以放弃了二面。<br>一面<br>终于遇到一位年轻且头发还算茂密的面试官了，还蛮热情的<br>闲扯了下项目<br>介绍spring的IOC和AOP，容器的概念（本质就是applicationContext管理了classloader）<br>bean的创建过程<br>手写TCP三次握手（最好把状态也写出来），每次请求的序号是如何变化的<br>TCP如何控制拥塞（拥塞窗口、慢开始、拥塞避免、快重传、快恢复）<br>（代码）N个男生，N个女生，给出所有排列方式，其满足在任意i处（范围在[0,2n-1]），0-i的女生数都大于男生数（递归实现）<br>知道哪些排序算法，介绍一下快排</p>
<p>5、京东<br>   在某天晚上突然收到第二天早上去京东面试的通知，而且用的还是电话语音，9月22日读成九点二二 是什么鬼！面试现场比较混乱，一边的人在排着队，一边是有负责人出来循环播放“XXX在吗”……当天只安排一轮面试，大约等了一小时才见到面试官，面试官貌似是做管理的，技术性问题不多。介绍完项目后提出了一些场景问你如何解决，如何实现分布式，一般在哪儿用redis等等，面试过程很短一下就结束了。回去后半夜又收二面通知，又是那个电话语音，我当时的内心是崩溃的……但是面试时间和美团的冲突了，并且根本找不到hr联系方式，京东的面试就在此止步了。</p>
<pre><code>还有几家公司的面试，要么不大合适，要么就是跪了，就不细说了。希望大伙儿都能找到满意的工作，特别是到了校招后期，心态可能会变化比较大，可以来场说走就走的短途旅行缓解下压力，不要过于苛求自己，祝一切顺利！
</code></pre><p>一面（电话面 1一个小时左右 ）<br>约投递一周后接到电话，问了大概以下问题，时间比较长了，记得不太清楚了<br>1 ArrayList和LinkedList有什么区别，能否序列化<br>2 如何判断链表是否有环<br>3 concurrentHashMap如何实现<br>4 集群服务器 如何application 共享<br>5 四个表 记录成绩，每个大约十万条记录，如何找到成绩最好的同学<br>6 AIO与BIO的区别<br>7 DirectMemory是否了解<br>8 对JVM了解多少？我当时提到了内存模型 ，他问我工作线程的内存如何释放<br>9 JVM的垃圾收集算法了解多少？有哪些垃圾收集器<br>10 是否了解红黑树<br>11 session的生命周期是多久<br>12 关于Mina框架了解多少？（因为我在项目里用到了Mina，所以提到了这个部分）<br>13 是否了解Linux<br>由于大概四个月过去了，能记住的只有这么多了。一面大概持续了一个小时吧，总的来说问题广而杂，而且会比较深入。这就是大家所谓的压力面试，面试基本在一个聊天+面试的氛围中进行。面试官的跳跃性很强，时不时地聊天，又会突然提问。印象中还有更多的问题吧，实在记不清了，而且我当时也没有全部回答上来。<br>二面（电话面 20多分钟）<br>本以为一面挂了，结果还是在几天后接到二面电话。他首先自我介绍是XX事业群的总监，基本就是聊天，没有任何技术问题。比较关心如果发offer能否全职实习的事。很轻松，也很意外。<br>三面（交叉面 30分钟）<br>第三面是杭州的电话（前两面都是北京），很明显就是大家所说的交叉面（前面的叫部门内部面试）。从他的问题中我能感觉到他完全不知道前面的面试官问过我什么问题，后来事实证明在面试系统里面应该只有评价，所以不要以为面试过的问题不会再问了。<br>1 介绍自己的项目，问我项目中用到的websocket，问我websocket有哪些优缺点<br>2 HashMap和ConcurrentHashMap的实现<br>3 JVM内存都分为哪些<br>4  是否了解数据库的索引是如何实现的<br>5  对Linux是否实践过？（几乎没有问，因为我只说我会用简单的命令）<br>三面总体说比较机械，没有过多的废话在里面，一个问题接着一个问题，不会就过，感觉有点无情。而且也没有最后的提问环节<br>四面（北京终面 1小时左右 ）<br>首先说为啥要去北京。其实我也不知道，当时以为是内推挂了，没想到收到短信邀请参加现场面试，内推的姐姐也让准备一下HR面之类的，但是我当时就觉得肯定还有一轮技术面。而且当时已经知道要拥抱变化了，所以这个技术面肯定不好过。记得去北京的时候，准备了厚厚一摞的复习资料，全部都是自己的博客总结以及自己想的问题，事实证明基本命中了技术面的全部题。<br>面试的场面就不说了，略显冷清（大家都知道原因）。被叫号后领入一个大厅，跟面试官1V1，一个小桌，一个Apple（真想问问他苹果笔记本怎么样，忍住了），桌子上有几张纸，没有很紧张。<br>首先讲了自己的项目，而且在纸上画了画结构图，项目引出的问题<br>1 BIO与NIO的区别<br>2 为什么要用Mina框架<br>3 Mina框架的实现原理<br>项目讲了很久，总得来说这个过程是我来主导的，我有意在说出了一些点，然后他就问了我相关的东西。<br>然后让我在纸上也一个HashMap的实现，set get方法，不要求线程安全。因为真的看过hashmap源代码，没什么压力，不过hash传播算法确实没写出来，不过他也不太在乎。在我写的时候，他在看我的技术博客（博客地址是我写在开放性问题里面的）。写完之后他看了一下，也没说什么，不得不说写的挺乱的，没有特意练过笔写代码，只说一个判断可以进行短路优化。<br>后面他又问我一个博客上写的问题，volatile和synchronized的区别。<br>问题不止这些，确实记不住了。后面跟他聊天中我就知道自己过了，能看出来他比较欣赏我的技术水平吧，尤其是对一些细节的掌握<br>五面（HR面 20分钟左右吧）</p>
<p>HR面嘛，大家都知道就是聊天，然后她不断对你评估。说一些问题吧<br>1 自己做过的项目<br>2 自己在大学期间有哪些做到了0到1<br>3 如果去问同学，他们会对你有什么评价<br>4 遇到了什么困难<br>5 喜欢哪个城市 </p>
<p>总结</p>
<p>以上说了那么多，当然我要说这应该只有所问的题目的一半吧，因为确实忘了。我觉得大家如果实在想知道到底都问的是什么，可以看看其他人的面经，在我看来这些问题真的差不多。我最后没有拿到阿里的offer，这不能说自己在拥抱变化，只能说自己还不够优秀，下面讲一下如何准备面试吧：<br>（1） 平时多看书，面试前看面经。有人说这不是废话吗？但我敢说大部分只做到了后半句，甚至有人都不知道还可以有面经可以看。我承认面试可以突击，可以看看别人的面经问了什么，自己查一点答案就背。但是这样在面试官前面你首先就没有自信，你会觉得那是我背的，在不断回忆的过程中怕的是背错，而不是一个正确的回答问题的过程。你以为面试官真的看不出来嘛，那他对比一下也知道谁在背了。<br>（2） 好好包装自己的项目。确实不是每个人都有很好项目，但你应该知道面试中总考的点是什么。看我的面试经历，有多次提到NIO与BIO，这是一个热门考点，但我要说的是所有的NIO与BIO问题都是我引导面试官问我的。因为我在介绍Mina框架的时候，我有意的提到NIO，那么他们马上就会去问这个知识点。所谓的项目，我觉得面试官是想知道你在项目中学习了什么。不是说你学习了哪些编写代码的规范，而是说你学到了哪些他们感兴趣的点。<br>（3）养成写博客的习惯。阿里的简历选项中有一个让提交github地址的地方，悲剧了我没有。但是我仍然想让面试官了解我，那么只能通过开放性问题了。在一个显眼的位置写上自己的博客地址。曾经在一个腾讯的面经里面看到，面试官对面试者说我们看了你全部的技术博客。博客不是让面试官看到你技术有多牛，而是让他们看你是如何学习的。把你的学习的点滴写在博客上，哪怕只是Integer类的缓存，他们一旦get到这个点，就会觉得你的学习能力很强，会对你有一个很好的印象。PS：面试我的技术官都有看过我的博客，我相信它给我加分了。<br>（4）利用好“你想问我什么？”。这个问题一般出现在面试的结尾，不要以为自己没用的，你能了解到很多。记得我在终面的时候问那个面试官“你对我的技术有些建议？我未来应该朝哪个方向努力。”他对我的面试过程以及博客进行了点评，而且把前面的面试评价给我讲了讲，简单了提了一些建议。我觉得这建议胜过读几本书。据说阿里的终面面试官一般都是P10（可能不是哈），他们是牛P了，有多少人有这样的机会去接触到这些牛人，并且给你做指导呢？有这样的机会为什么不抓住呢。</p>
<p>大概就写这么多吧，写在牛客网因为它让我学到了很多东西，我应该回馈给大家。感谢牛客的CEO叶神能给大家提供这样一个平台，大家多刷题，都能拿到理想的offer！</p>
<p><strong><a href="http://www.nowcoder.com/discuss?type=4" target="_blank" rel="external">http://www.nowcoder.com/discuss?type=4</a></strong></p>
<p>去哪儿网面试题<br>一面： 面试官先看试卷上做的题目，然后开始问<br>一面主要问的还是数据结构，算法到是没有问太多具体如下：<br>1.HashMap和TreeMap的区别以及底层实现<br>主要考散列表和红黑树的知识（HashMao用的散列表，解决冲突的方式是拉链法，TreeMap底层用的红黑树，红黑树与2-3树是一一对应的，然后简单介绍了一下这些数据结构）</p>
<p>2.有一个Person类里面有三个属性，name，sex，age。现在有一个Person数组，要求按照Person的age属性排序<br>让Person实现comparable接口，在compareTo方法中使用age作为比较条件，然后使用快排即可（Arrays.sort（）方法）<br>紧接着问，两个对象的equals方法相等，他们的hashCode可不可以不相等？<br>可以，但是不能将元素插入到HashSet中，因为相同的元素会被散列到不同的地方</p>
<p>3.SQL语句，问题我不记得了，主要考group by，count聚集函数，和having</p>
<p>4.servlet是不是单例的，为什么？怎么设计程序证明它是单例还是多例？<br>这个问题我没有回答好，我回答是servlet是多例的，为了让请求可以并发</p>
<p>5.如果一个类继承servlet，这个类需要实现那些方法<br>get和post，其他的我不记得了</p>
<p>6.linux你了解多少<br>linux一直是我的软肋，我目前只能死记硬背一下简单命令（建议如实回答）</p>
<p>7.static的使用方式，final和finally的区别<br>static可以用来修饰类，成员或者方法，然后分别描述一下各自的作用即可<br>final同样可以用来修饰类，成员或者方法，然后分别描述一下各自的作用<br>finally主要用于try-catch中，用于资源的清理工作或者执行某些必须执行的代码</p>
<p>8.用过哪些开源的jar，简述一下作用<br>回答实际情况即可</p>
<p>9.Java的堆栈有哪些区别？<br>我简单的说了一下，然后把java的内存模型简单的说了 一下，面试官还算比较满意</p>
<p>10.编码实现一个最大元素为100的阻塞队列<br>这个java的api上有demo的，大家可以翻一下，写出来后面试官很满意</p>
<p>中间穿插了其他的一下基本问题吧，象征性的问了一下项目问题不算太难<br>大概面了50分钟吧，估计一面分数很高，因为我二面不是很好</p>
<p>接着大概等了一刻钟吧，二面开始<br>二面就没有一面这么顺利了<br>1.你认为你做的最好的那个项目是哪个？<br>只要如实回答，并给出理由即可<br>你做的事导师的项目吗，你对跟着导师做项目怎么看？<br>我回答说，不如出去实习。。然后给出理由</p>
<p>2.你认为你Java哪一方面学的比较好？<br>我回答是Java集合类，结果悲剧了<br>面试官问Set接口继承了Collection，为什么要有Set接口？Set接口中比Collection中多了哪些方法？<br>好吧，这个问题我回答的不好，大家可以各抒己见</p>
<p>3.你还有哪些方面比较好呢？<br>我本来想说多线程的，后来想想还是算了，我问面试官数据结构算不算，他说算<br>然后问了红黑树的问题，问我自己实现过哪些数据结构，我回答链表，栈，队列，然后问了一句，我刚刚写的那个阻塞队列算不算？<br>面试官说算，然后就开始看代码，接着问了一个问题？生产者在await的时候会发生死锁吗？<br>我回答说不会，因为await的时候会释放已经持有的锁资源<br>又问为什么不用读写锁呢？<br>答：读写锁一般用于单个对象的cache<br>为什么不能用于数组呢？<br>答：如果用于数组，那么将会允许多个消费者并发的从队列中取元素，那么有可能会出现多个消费者消费同一个产品的现象</p>
<p>4.你的代码量不少吧<br>我写过不少代码</p>
<p>5.如何培养自己的代码风格？<br>答的一般，我回答说一般都是看iteye上和csdn上一些大牛的代码风格，然后就是java api中的demo</p>
<p>6.你看过开元框架或者jvm的源代码么<br>我当时心里一沉，玩了，阿里的二面我就是挂在这个问题上了，但是我还是如实回答了<br>我使用较多，但是底层源码看的少</p>
<p>7.你还有什么问题要问我吗？<br>于是我很诚恳的问了一个问题？<br>老师，站在您的角度，您认为我有哪些方面的知识需要加强，或者说需要特别的学习<br>面试官说，平时最好能多看看jar中的源码，google有很多优秀的开源框架，这样可以养成很好的代码风格和编程习惯</p>
<p>然后让我出去等通知，大概等了20分钟吧，hr过来了给我一份公司的FAQ，让我看几分钟，然后我问了几个问题</p>
<p>然后他说问我的期望薪酬，我大概说了一下，然后他说其实我们已经给你定薪了，然后问我的意愿，好吧，我假装深沉的说了一句，我妹妹在北京工作，我先回去征求一下父母的意见，明天早上过来。。hr说没关系，他们这几天都在这里，就这样拿到offer了</p>
<p>面试已经告一段落了。从最初的一无所有，到国庆前后4.5个offer，只能说一切来的太突然。也不打算再找其他的了，毕竟还有很多同学没有心仪的offer。各位同学也不要担心，等到后期还有三方的才是大爷。由此，在牛客也来篇百度，阿里，去哪儿，美团，网易，京东，华为的面经吧。已经拿到百度，去哪儿，华为的offer，京东offer审核中不知道是什么状态。这篇面经会很长，把心理因素，所看书籍，以及面试技巧都写进去了，最重要的是有很多题。。。<br>先自我介绍一下：水硕一枚，对互联网比较感兴趣，所以面试的都是互联网公司。无实习经历，没有参加过任何比赛，只有3等奖学金。。。唯一比较拿的出手的项目是导师的与搜索有关的项目，这个项目还是自己争取拿到的（当时老师有两个选择：一个是知识库，一个是全文检索系统。我看第二个比较有技术含量，且我比较感兴趣，就建议导师选第二个。并花了1个月时间做了个demo，并成为了项目组长）。其他专业知识可能停留在考研时的水平。。。并且一直没有找准方向，不知道想做C++还是java（本人想做C++，奈何项目全部java），完完全全的水货。自我介绍完毕，面经开始。</p>
<p>【阿里巴巴内推实习】java研发工程师<br>一面跪（30分钟），当时项目正处在技术攻关期，根本没时间复习。所以打算先试试水，了解一下面试问哪些问题，然后找准复习方向。<br>问题1：项目遇到的最大困难等几个问题。<br>问题2：说说红黑树（瞬间变sb，还没复习）。<br>问题3：大文件读取并排序（题目没弄清楚，就开始盲目说算法，后来发现他可能考察的是java内存映射文件，不过没办法当时java编程思想都没看，什么都不知道）。<br>面后总结：阿里巴巴项目占的比重较大，语言也很重要，数据结构及算法很重要。根据这三点结合自己的项目，开始复习并选择了java，毕竟项目用的java。当时的复习计划：thinking in java（语言），程序员面试宝典（笔试），深入理解java虚拟机（还是语言），算法导论（算法及数据结构，神书），计算机网络（潘爱民版，神书），剑指offer（算法，神书），unix网络编程（兴趣），设计模式（项目），数学之美与解密搜索引擎技术实战（项目）。看完这几本书基本有底了。。。<br>【阿里巴巴校招内推】java研发工程师,HR面跪,呜呜<del>一生阿里黑了。。<br>HR面跪，这个地方要注意一下，校招内推和实习内推是冲突的，如果实习内推没过校招内推是直接reject的，多亏师兄找hr以及经理求情才能有这次机会。虽然最终没有拿到offer，但是收获了自信，也受到的沉重打击。<br>    一面 （这可能是所有面试发挥最好，1小时）<br>问题1：项目难点。说了一下用到java反射机制的地方以及多线程建索引。<br>问题2：项目中用到的最复杂数据结构，回答没有。。。然后他问TreeMap听过没有，为什么查询速度会很快<br>答：treemap底层实现是红黑树，红黑树是一种平衡二叉树，它的时间复杂度是O(H)，h为树的高度，而红黑树通过它五个性质保证了树的高度为O(logn)，所以它的查询速度快(注意此处，故意提到5个性质，之前内推实习问到红黑树)。果不其然。<br>问题3：红黑树的5个性质是什么，快速回答之。<br>问题4：Object类的方法有哪些。这个问题恰巧被寝室的问到过<br>答：getClass/hashCode/equals/clone/toString/notify/notifyAll/wait/finalize<br>问题5：你刚才提到了hashCode方法，如果不重写hashCode方法会导致什么问题<br>答：java编程思想上面有，object的hashcode方法是根据内存地址来hash的，如果你需要根据对象的某个属性来存取的话，就会找不到该对象，重写hashcode一般必须重写equals。。。<br>问题6：TCP建立连接之后怎么保持连接<br>答：之前没有了解过，不知道是通过心跳包来保持连接的，随便扯了下TCP的三路握手。。。囧</del><br>问题7：说一下java集合框架<br>答：balabalabala，最后提到并发库，concurrentHashMap（当时紧张，还忘了怎么拼）。<br>问题8：concurrentHashMap为什么性能高<br>答：分段锁，16个写锁，重复读锁。并说了一下hashtable的性能为什么低（整表加锁）。<br>问题9：了解存储过程么，说一下优缺点。<br>答：无语。。。缺点还真没想过，先说的优点，缓存提高性能、精简代码、增加安全性、降低网络流量。本想蒙混过关，结果追问缺点呢。。。呃，可能就是存储过程没写好不好用吧，而且不灵活。。。= =！ 面试官：好的，下一题。。。<br>问题9：数据库优化性能<br>答：这个在java面试宝典上面有，建立索引，建立分区，尽量使用固定长度的字段，限制字段长度；增加缓存使用连接池；减少SQL语句的比较次数，限制返回的条目数。。。还有一条想不起来，面试官提示：你刚从数据库，IO，语句方面说了可以优化，还有没有其他方面可以优化呢？ 突然想到了java方面，对于反复使用的语句，使用preparedStatement。追问：preparedStatement与普通的statement有什么不同。答：preparedStatement会预先编译语句，并缓存改善性能。（阿里面试官就是不错，不仅提示，还帮总结的）。<br>问题10：简述一下tcp/ip协议<br>问题11：应用层有哪些协议<br>问题12：听过DNS劫持么<br>答：听过。。。怎么预防，不知道，随便说了个MAC地址绑定。。。无语~~后来发现潘爱民版的计算机网络上面有。<br>问题13：中国最大的DNS提供商<br>答：不知道，之后查资料发现，DNS提供商有360，阿里巴巴…好吧。。。<br>问题14：http端口，tomcat端口<br>问题15：Http响应状态号，服务器错误状态号是多少。<br>答：只知道404 not found。后来查阅发现服务器错误是5XX，请求错误是4XX，重定向是3XX，成功是2XX，消息是1XX。<br>问题16：get和post的区别<br>答：从逻辑上get是安全的，post是不安全的。get一般用于获取数据，post可以用来提交数据，如表单。追问：get不能提交数据么，可以，不过需要跟在url后面，这样安全性会降低，如果使用url传递用户名，密码的话会非常不安全，因为全部为明文的。而且get有最大长度限制，因为url每种浏览器都有一个最大长度。<br>问题17：开放性问题，如果让你设计淘宝架构，用于支持双11的访问量，你怎么设计。<br>答：1、减少http请求，将js,css文件打包成一个文件。其实还有页面静态化，之前项目有涉及。<br>2、内容分发CDN，我回答的是根据用户的IP，将用户请求负载均衡到就近的数据中心。追问：如何负载均衡？可以根据IP hash生成，根据请求响应延时负载均衡。追问：这几种负载均衡属于哪种负载均衡，答不知道。他说属于软负载均衡。然后我问他还有哪种负载均衡策略。他说还有硬负载均衡。然后我再问，这样的话是不是用软件做负载均衡就是软负载，硬件做负载均衡就是硬负载。他说也可以这么理解，哈哈。最后提示我其实可以用DNS做负载均衡，这就是内容分发的思想了。<br>3、在每个数据中心中建立缓存。web代理的思想（详见计算机网络，潘爱民版，神书，师弟师妹不要错过）。<br>4、tomcat使用短连接，或者降低keep-alive时间。追问长连接和短连接的区别，哪个版本使用长连接。（此处也故意提高短连接，这是一个面试技巧，尽量提到相关的技术）。<br>5、数据库优化，具体方法之前问过。<br>问题18：还有什么补充的。说了一下项目用到的主从复制思想。<br>    二面 （比较水，只问了30分钟，我以为挂了，失败从此开始）<br>问了下项目经历，项目，索引是怎么存储的。作为项目组长人员怎么分工的。爬虫。jdk源码（说了个hashmap），Lucene源码。一面二面总结：可能一面表现太好，二面问的比较简单，发现计算机网络，数据库，以及java并发比较重要，jdk源码，以及项目源码也很重要。二面完了，8天，杳无音讯，我以为挂了。开始新的一轮复习：补了一下网络，数据库，effective java，java并发（java并发编程实战），看jdk源码，复习项目，看lucene源码。这个时候千万别放弃。。。因为阿里状态一直不会变，特别是有些一面明显挂了得同学，状态一直是面试中，所以这时候对阿里开始有点反感。再加上看到阿里有个搜索部，而我想做搜索。最最重要的是我知道自己的性格，如果阿里过了，我肯定是提不起劲复习的，因为我喜欢搜索，所以百度是我的理想选择。总之，这个时候心里就已经放弃阿里了，开始全身心投入源码学习中了。<br>    HR面（在心情失落的状态下看了几天书之后，晚上7点突然接到电话，30分钟）<br>因为之前已经放弃阿里了，接到电话还没有反应过来。。。态度一直比较冷淡。注定失败。失败了才开始后悔放弃的太早了。。问：本科到研究生的经历<br>因为二面介绍过，所以我几句话说完。。。面试官大呼，不要那么快。。。好吧，这就是失败的开始。这个地方要注意了，没有经验的师弟师妹肯定会觉得一面问过的问题，二面问相关的可以回答的粗略一点。实际上这种想法不好，首先二面面试官根本不知道一面问的什么问题，即便是有记录也是简短的1、2条，粗略的回答会让面试官觉得你不了解，或者不自信。<br>问：兴趣爱好<br>看书。。。好吧，只说了这一点，加上当时非常累，表现出不爱说话的样子，可能面试官觉得我比较孤僻。。。兴趣爱好最好加上一条运动，因为运动容易让人觉得乐观。<br>问：项目遇到的问题相关的几个问题<br>这个同样没有回答好。。。<br>问：你还有其他什么问题<br>问了个入职培训。。。这个同样是败笔，也许是前面表现不好，这个时候问什么都是败笔。。。<br>总结：因为太累了，把话语主动权叫给了HR是一大失败。后来发现，面试也要遵循28定理。面试官只说20%的话，自己最少要说80%的话。黄金法则：80/20—你要承担起80%的谈话而面试官只会说20%。白金法则：你必须试着控制面试的节奏和话题。钻石法则：对于没有把握的问题，抛回给面试官。注意这三个法则。。。在hr跪了之后，心情极度郁闷，甚至到了睡觉突然想到hr跪了就失眠的地步。。。这个时候同学有各种内推面试，内推offer，而我其他的一个也没有（美团，网易，蘑菇街内推简历没过），压力极大。。。这个时期可能是最艰难的时期，压力大，各种口腔溃疡，各种吃不下饭，都感觉有点内分泌失调。。。感觉再这样不行，之前看过村上春树关于跑步的散文，对跑步慕名已久，借此契机就每天晚上去跑步，发现效果不错，跑步的时候还能做总结，做计划。总算调节过来了。</p>
<p>9月正式校招开始，以下面试大部分是穿插进行的，为阅读方便我还是一个公司一个公司写吧，去哪儿最爽快，面完直接发offer。<br>笔试就不说了，直接说面试。</p>
<p>【华为提前批】收到offer，我是不是精神病？<br>    笔试<br>华为笔试还是要谈一谈，在编程题做完之后，就是华为鼎鼎有名的性格测试了。第一遍性格测试到后面太捉急了，别人全部测完，我还在那测，后面几题乱选的。提交，hr看了之后让再测一遍，并提示注意前后一致。然后做完第二遍直接让走。。。路上一度以为自己真的是不是性格有点不正常，阿里hr挂，这个性格测试又跪。。。<br>    一面<br>终于还是收到面试通知，第一次去大酒店面试，有点紧张，后来发现太水了。。。我就写了2个项目，让我画了这2个项目的架构图，问会一些什么，都没细问的，就过了。。。<br>    二面，综合面试<br>也基本上没问什么问题，问家里在哪，在成都待了多久，之类的。。。。最后问面试官缺点是什么。。。说我太瘦了！ = =！！华为只要性格测试过了，被刷的概率非常小。</p>
<p>【美团】最差的三面经历，三面跪<br>    一面（1小时，面试官挺好的，不过上午面完百度被虐，下午通知4点面试等到6点才开始，这时候已经意识模糊了，遇到智力题脑袋已经不能动了）<br>1、虚拟内存的目的。我说是为了解决内存不足和提高内存利用率，他说不是，然后我给他扯了一堆原理。最后勉强算过了。。。<br>2、DNS欺诈。计算机网络有，利用dns的缓存，因为DNS是基于udp的，它不需要建立连接，导致欺骗的发生。现在已经有安全的DNS协议，好像是DNSsec，基于加密的。然后跟他扯了很多对称加密，和非对称加密，公钥私钥的概念，最后他还问我这些从哪里看的= =。<br>3、说一下TCP，建立连接，超时重传，流量控制（滑动窗口），拥塞控制（慢启动，快速重传，加法增乘法减，快速恢复）。<br>4、为什么是三路握手。这个题目刚开始吓我一跳，仔细一想，二路握手不能确保连接已经建立，四路握手的效果和三路握手是一样的。<br>5、50% 15元 60% 20元 求打折最多的金额。这个智力题，因为已经不能思考了，一直让他提示，最后差不多是他直接讲出答案的。<br>6、打印文件结构，按树形结构。写代码。。。用递归实现，然后让用非递归实现，表示不太会。。。<br>7、项目遇到的难点。<br>    二面（1小时左右）<br>concurrentHashMap的原理及结构，16个分段锁，允许写锁与读锁同时存在。<br>blockingQueue一个性能优化问题，引入缓存的概念。感觉这题出的不好。<br>看了什么书，数学之美，讲了一些与搜索相关的知识，扯了点信息熵，相对熵，互信息，以及TF-IDF算法。<br>merge rebare: git merge 会生成一个新的合并节点，而rebase不会。。。没答上<br>项目架构。<br>数组循环移位。 剑指offer上面有。<br>项目bug、性能优化。<br>    三面（好像是美团外卖的leader，较胖。可能看我不顺眼吧~~回答问题看都不看我一眼）<br>觉得最难的设计模式<br>用过异步IO没有<br>说一下nio<br>如何动态加载架包<br>一直问我知道什么，我说jvm，jdk源码，java并发，计算机网络，操作系统，数据库，搜索引擎。。。结果一个也不问，还问了我两遍会什么，感觉没有他想要的兴趣点吧，他好像对SSH比较感兴趣，我只懂一点皮毛，会用而已（没有技术含量高的项目的一定要看看spring源码）。。。嗯，还问了本科，感觉BAT不看本科只看能力，其他公司反而看重学历。。。</p>
<p>【百度】第一个offer，吓死了。。。百度看中解决问题的思路以及编码能力<br>    一面<br>只问了几个问题，两道代码题全部没有写出来，结果居然让我过了。。。面试前问过其他面过一面的同学，但是没有尝试把代码写出来，结果面试第一题就是。<br>自我介绍完，我们写写个代码吧。。。呜呜呜呜呜~~<br>问：求1~n所有不能被素数相加得到的偶数。<br>这个题之前同学说了，没想到真出一样的题，瞬间感觉要哭了。。。没办法，只能硬上了，先说了思路，先求出1~n的所有素数，然后遍历1-n的偶数看能否由任意两个素数相加获得。面试官认可思路，开始写。。。写了好久，卡在求所有素数这了。。。其实之前在leetcode写过类似代码，但是第一次在纸上写代码完全没有经验，脑袋一片空白。面试官凑过来的时候，赶紧跟他说了一下思路。。。最后写完这个函数，面试官拿过草稿纸发现漏洞百出。。。<br>问：java集合类，比较简单。。。<br>问：OSI与TCP/IP模型，哪些层相互对应。<br>问：TCP分组，TCP IP包结构。IP包头和TCP包头，哪个在外面。<br>问：既然你对多线程比较了解，写个生产者消费者吧~~<br>呜呜<del>还嘴贱的问不能用blockingqueue？，因为用阻塞队列的话就可以避免协作了，面试官想了一下，说不能。然后问有几个缓存空间。。。答：5个。。。然后在那想了很久，代码还是没写出来，被java编程思想上面那个复杂但效率高的误导 ，其实完全可以只对一个对象加锁，但是效率就低了。。。最后面试官说没时间了，就到这里了。<br>最后问我有什么问题<br>我问他我这次的表现怎么样。。。他说编码能力太差了，两道算法题全部没有写出来，哪怕求素数那个函数写出来了也行。。。感觉就是跪了得节奏。。。然后我说是的，各种边界没有考虑到。他说不是边界问题，是逻辑都错了。。。好吧，我只能说，嗯，是的，主要是第一次在纸上写代码，完全没有习惯，最后道谢，满脸失落的离开。。。不知道是我的解释起作用了还是最后的卖可怜让面试官动了恻隐之心，一面居然让我过了。。。<br>    二面，比较舒服，面完就知道应该过了<br>1、一上来就是智力题。赛马问题，在牛客网有做过，30匹马，6条跑道，没有计时器，需要最少多少次比较才能找出最快的3匹马。思路：36分成6组分别比较并排序，然后找出每组最快的马比较并排序。<br>a1 a2 a3 a4 a5 a6<br>b1 b2 b3 b4 b5 b6<br>c1 c2 c3 c4 c5 c6<br>d1 d2 d3 d4 d5 d6<br>e1 e2 e3 e4 e5 e6<br>根据上表，a1肯定是最快的。a4,a5,a6,b3,b3,b5,b6,c2,c3,c4,c5,c6以及d,e全部不可能为前3名。所以最后比较一次既能得出结果。题目可能有点出路，具体多少匹马，几个跑道记不清了。<br>2、面试官可能看我回答的太容易了，继续问了一道智力题。给定12 ，-12， 7， -7， 5， -5这6个数字，求任意数A到B的最短路径。比如12到24只要一个12就能到。1个12就是最短路径。<br>这道题比较有意思，各位可以想想。最后想了个笨办法，分别求这6个数字的两两组合，三三组合。。。到NN组合。然后将A与B的差对12取余，在这些组合中查找该余数。。。方法效率低。。。面试官提示，如果相差2，最短路径是什么？ 回答并想了之后表示还是没找到头绪。。。最后直接告诉我，2出来了，3能不能出来，3出来了1出来没有？好吧</del>没想到2也能用。。。太失败了。<br>3、最长不重复子串（最长重复子串）<br>这道题刚开始我理解错了，以为是最长不重复公共子串。。。说了一下动态规划的方法，然后发现是我理解错了，然后他在解释题目的时候，他也混乱了。。。最后让写了一道最长重复子串。还是用暴力方法O（n^3），具体方法有很多。。。各位同学可以自行百度。顺便说一下常考的字符串题型：最长公共子序列（动态规划），最长公共子串（动态规划），最长回文子串（动态规划，后缀数组），最长重复子串（后缀数组），最长不重复子串（hash,动态规划，hash+动态规划）。花了一天研究字符串题型后，京东居然问了~~哈哈。<br>4、项目问题，问了个字典大小问题。。。还算错了。= =~。<br>5、最后问了自己面试缺点，说可能太紧张了，第二题没答出来。。。最后谈了点为什么百度开百度邮箱的问题。。。<br>    三面，面试官感冒了。。。成都天气阴沉沉的，刚来确实有点受不了<br>自我介绍完直接上系统设计。。。吓屎了。<br>大访问量系统站内搜索设计。（内容分发，dns做负载均衡，缓存，zookeeper）<br>7个人 1个月完成一个项目，人员怎么分工，怎么保证项目按时完成。<br>判断IDE的括号是否匹配，需要多方面考虑（失败，没有考虑注释，往项目名称考虑了）。<br>三个问题选一个：设计模式，接口设计原则，数据库范式。选一个熟悉点的，我选的设计模式，讲一下最难的。。。<br>继续三选一：SQL注入攻击、XSS，图片盗链。选的SQL注入。<br>索引新建的方法（增量索引、全量索引），如果在索引提交的频率很高怎么办。引入缓冲区，在索引不一定立刻更新，等一段时间再更新。追问：但是有些更新需要立刻能查到怎么办？ 可以将更新写入内存，之后再将索引更新写入磁盘。lucene采用的方法。</p>
<p>【网易互联网】offer，从高中开始玩梦幻，奈何网易游戏刷我简历网易一直比较喜欢，人文关怀做的比较好，内推投的数据挖掘，简历被刷了，无奈投的java，网易java对SSH要求是精通，本来是打算不去的，但是当时一个offer也没有，只能上了。。。<br>    一面，果然是SSH<br>1、事务的隔离级别，没答上。。。= =~<br>2、struts1.0和2.0的区别，没答上。。。<br>3、struts的Action，没答上。。。说了一下servlet<br>4、单例模式和多例模式的优缺点，随便扯了点<br>5、linux命令查看文件、查找文件<br>6、java集合<br>7、java IO框架<br>8、ConcurrentHashMap<br>    二面，问的比较广<br>1、服务器端建立连接过程<br>socket bind listen accept。。。然后就不知道了，他说还有。。。<br>2、fork的特性和execute的区别<br>一次调用2次返回。。。<br>3、文件加锁<br>文件锁对其他的操作系统进程是可见的。因为java的文件加锁直接映射到了本地操作系统的加锁工具。使用isShared设置共享或独占。对映射文件可以部分加锁。<br>4、synchronized与lock的区别<br>synchronized是jvm提供的加锁，悲观锁，lock是java语言实现的，而且是乐观锁。lock实现阻塞可中断，可以设置等待时间。公平锁，锁可以绑定多个条件。<br>5、lucene基本元素<br>6、单线程下ConcurrentHashMap与hashtable性能<br>这个问题有点意思，后来一想应该是hashtable性能高点，因为它只有一个可重入锁，另外一个有16个。<br>7、进程间文件描述符<br>进程间同一个文件描述符是相同的么？这个还真不知道。。。猜测应该是不同，求大神解答。。。<br>8、分布式系统设计<br>双11类似，服务器宕机了，怎么保证用户数据不丢失。session共享服务器。<br>9、统计站点访问量<br>刚开始说采用http数据包统计。。。后来转眼一看，刚才的session共享服务器，可以使用session啊。<br>10、一级缓存与二级缓存<br>11、数据库可以使用缓存服务器吗<br>12、git创建一个分支<br>13、niginx内部实现<br>14、框架的优点<br>开发效率高，扩展性高（hibernate换数据库）。在低水平的程序员面前效率高，因为内部会有一些优化。在高水平程序员面前效率低，因为高水平程序员会根据自己需求做优化。<br>15、负载均衡实现方式<br>    HR面，诚实不吃亏？<br>难道是hr看我太诚实了，给我offer？她问我百度给我offer我会选择网易吗？我说不会<del>问我女朋友找到哪的工作，我说北京。期间说网易说成百度</del>（自我介绍背太多了。。。情不自禁就。。。 = =）。面完我一度怀疑自己情商是否有问题，回来测了一下。。。</p>
<p>【去哪儿】offer，最爽快的面试经历<br>本人离面试地点有点远，8点半。。。好吧，6点多起床跑去，结果刷二维码签到出问题了，算我迟到，11点才安排面试。太惨了~~<br>    一面<br>hashmap和treemap的区别，hashmap内部实现（说了一下1.8把entry改成了node）<br>hashmap性能优化，resize，容量，负载因子。<br>递归写斐波那契数列。。。太太简单了。。。<br>为什么需要内核态和用户态，安全性，提供统一的系统调用。。。其他的就不知道了，求大神解答。<br>项目问题<br>cpu什么时候负载特别高。计算量大的任务，线程或进程频繁切换？大量复制？<br>    二面<br>问分布式设计，我说不知道，然后问项目怎么实现分布式的，我说主从复制设计，并说了一下设计。然后面试官说不就是这样么？不是挺简单的嘛= =。<br>数据库内联和外联<br>数据库外键，为什么要用外键而不能直接存一个对应表主键。想了一会说是数据一致性的问题。<br>get和post的区别。<br>get和post可以同时发送么。完全不知道。。。扯了很多。。。说了一下自己的看法，最后问他可不可以，他说可以。<br>笔试题性能优化，重写concurrentHashMap，将数组改成队列。并设置一个值返回最大值。感觉这道题回答的他比较满意。思维还是挺快的。<br>有使用redmine管理bug么？没有。。。然后说项目遇到很多bug，但都是解决了就算了，这个确实没有考虑到。<br>计划任务返回值如何处理，还是没有考虑到。<br>人员分工，怎么保证项目按时完成。分配任务，定时询问结果，帮其解决问题。<br>    HR面<br>直接发offer，还说二面面试官评分给的比较高，特意强调了会进他部门，二面面试官是做广告搜索的。待遇还挺高15*16。。。</p>
<p>【京东商城】offer待审核是个什么状态？<br>    一面，面试官太累了，说完问题就打瞌睡，我能怎么办。。。<br>1、lucene字典结构<br>把跳链表，FST，trie 树，三叉trie树。<br>2、字符串旋转的实现（太简单了，所以让再写一道）<br>3、最长公共子串<br>之前百度遇过，动态规划解决之。。。一说完题目，面试官秒睡。。。= =！无奈提高音量继续说。然后让我说原理，画了图，讲了两遍，边讲他边睡，无奈。。。可能看我比较耐心的讲了两遍不好意思了，才出了下一道题。<br>4、suggest自动补全功能，类似于百度输入提示功能。<br>一说完题目，又秒睡。。。好吧，面试官也确实辛苦，我就让他睡，自己在那里慢慢想，慢慢画，把trie 树和三叉trie树结构以及示例都弄出来后，他醒了，让我描述了一下，然后下一道题。出完题就说他太累了，出去走走。。。<br>5、好友提示，拼音，类似于QQ的好友搜索提示。<br>第一个想法还是使用trie树，不过有个缺点就是，好友变化了需要重建trie树。让我再想想。<br>想法二是字符串前缀匹配。效率低，还让想。<br>最后使用hash。但是感觉hash效率还是有点低。。。问他通常的做法是什么，他说就是hash。<br>    二面，问的最全的，挨着简历一条一条的问，问完说，还有没有我没问到的。。。= =！！我说没有，您是问的最全的面试官了。。<br>lucene倒排索引结构<br>字典怎么查询，存储。<br>凸多边形怎么用一条线把面积分成1:2（最初没有理解题意，然后给提示，直接告诉我方法了= =！）<br>中文分词（三种方法，机械匹配，统计方法，基于规则的方法）<br>网络tcp udp，拥塞控制，滑动窗口<br>nagle算法（顺便说了clark算法）<br>让画网络状态转移图（= =！没有记，只画了后面一点点）<br>unix网络编程epoll poll的区别，书上没有epoll直接说不了解。<br>排序TF-IDF，相关度排序<br>JVM内存管理（怎么学习的，项目例子，jconsole发现bug）。<br>Git<br>一致性hash原理。<br>负载均衡：DNS，hash，响应。<br>lucene怎么实现布尔查询（交并集）。</p>
<p>虽然目标是百度做搜索。。。但是百度做java的不多，而且搜索是用的C++，所以分到流程信息管理部了，不过也算得偿所愿了，希望以后内部调岗吧。以上即为本人全部面经，各位同学加油！！</p>

    </div>
    <footer>
        
        
		<div class="bdsharebuttonbox">
	<a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
	<a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a>
	<a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a>
	<a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="bds_more" data-cmd="more"></a>
	<a href="#" class="bds_count" data-cmd="count"></a>
</div>
<script>
window._bd_share_config=
{
	"common":{
		"bdSnsKey":{},
		"bdText":"",
		"bdMini":"2",
		"bdMiniList":false,
		"bdPic":"",
		"bdStyle":"0",
		"bdSize":"24"
	},
	"share":{},
	"image":{
		"viewList":["qzone","tsina","tqq","renren","weixin","fbook","twi"],
		"viewText":"分享到：",
		"viewSize":"24"
	},
	"selectShare":{
		"bdContainerClass":null,
		"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin","fbook","twi"]
	}
};
with(document)0[
	(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)
];
</script>    
        <div class="clearfix"></div>
    </footer>
  </div>
</article>

 <nav id="pagination" >
    
    <a href="/2016/02/19/java集合类/" class="alignleft prev" title="java集合类">java集合类</a>
    
    
    <a href="/2016/01/17/Tomcat知识点总结/" class="alignright next" title="Tomcat源码知识点总结">Tomcat源码知识点总结</a>
    
    <div class="clearfix"></div>
</nav>



	
	<section id="comment">
		<!-- 多说评论框 start -->
		<div class="ds-thread" data-thread-key="2016/01/23/java基础知识点准备/" data-title="java基础知识点准备" data-url="http://zc14.github.io/2016/01/23/java基础知识点准备/"></div>
		<!-- 多说评论框 end -->
		<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
		<script type="text/javascript">
		var duoshuoQuery = {short_name:"http://zc14.github.io/"};
		(function() {
			var ds = document.createElement('script');
			ds.type = 'text/javascript';ds.async = true;
			ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
			ds.charset = 'UTF-8';
			(document.getElementsByTagName('head')[0] 
			 || document.getElementsByTagName('body')[0]).appendChild(ds);
		})();
		</script>
		<!-- 多说公共JS代码 end -->
	</section>
	
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" id="zc14-search-input" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:zc14.github.io">
  </form>
</div>


  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/hello/">hello</a><small>1</small></li>
  
    <li><a href="/categories/markdown/">markdown</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/并发编程/" style="font-size: 10px;">并发编程</a> <a href="/tags/开始/" style="font-size: 10px;">开始</a> <a href="/tags/金典/" style="font-size: 20px;">金典</a> <a href="/tags/面试/" style="font-size: 10px;">面试</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <!--
  <footer id="footer"><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/huangjunhui/concise" target="_blank" title="Concise">Concise</a> © 2016 
		
		<a href="http://zc14.github.io/about" target="_blank" title="周聪">周聪</a>
		
		</p>
</div>
</footer>
  -->
  <script src="//libs.baidu.com/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/counter.js"></script>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
        })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

	  _st('install','ZsQjP1Wjp4ayEpx825-R','2.0.0');
</script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

<div id="totop" style="position:fixed;bottom:100px;right:10px;cursor: pointer;">
<a title="返回顶部"><img src="/imgs/scrollup.png"/></a>
</div>
<script src="/js/totop.js"></script>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>


