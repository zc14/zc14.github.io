<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[zc14-紫竹林]]></title>
  <subtitle><![CDATA[叽里呱啦]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://zc14.github.io/"/>
  <updated>2016-01-24T05:49:33.832Z</updated>
  <id>http://zc14.github.io/</id>
  
  <author>
    <name><![CDATA[周聪]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[面试知识点准备]]></title>
    <link href="http://zc14.github.io/2016/01/23/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E5%87%86%E5%A4%87/"/>
    <id>http://zc14.github.io/2016/01/23/面试知识点准备/</id>
    <published>2016-01-23T09:28:22.000Z</published>
    <updated>2016-01-24T05:49:33.832Z</updated>
    <content type="html"><![CDATA[<h2 id="1-知识点总结">1.知识点总结</h2><ul>
<li><h3 id="常见面试题整理">常见面试题整理</h3><p>1.Aio和Nio区别<br>  <strong>NIO:同步非阻塞；AIO:异步非阻塞</strong><br>  <strong>同步异步是指是否是同一次请求（便于理解，举个例子）。阻塞和非阻塞就是oio和nio的问题，指的是调用一个方法能否立即返回结果。</strong><br>  <em>如果把内核比作快递，NIO就是你要自己时不时到官网查下快递是否已经到了你所在城市，然后自己去取快递；AIO就是快递员送货上门了。</em></p>
<p>2.你做过最得意的项目是什么<br>  <strong>必须想办法突出项目的亮点，并且突出自己在团队中的重要性。</strong></p>
<p>3.HashMap是如何实现的<br>  <strong>本质：数组+链表， 链表的节点就是 k-v 对。H</strong><br>  <strong>Hashmap中有一个饱和因子的变量，默认上是0.75，实际上也是通常情况下不会产生hash冲突的最佳设置（当然凡事也有例外）</strong><br>  <strong>这个扩容会重做整个散列数组+链表，代价很大，所以大牛们都建议使用hashmap时最好指定需要的容量大小。</strong><br>  <strong>一般需要使用大小为N，new HashMap时最好指定（N/饱和因子）的容量，或者指定大于N的最小的2的幂。</strong></p>
<p>4.为什么要使用Spring<br> <strong>与EJB对比。重量级模块耦合度高。/用哪个，配置哪个。 Ioc模块+Aop模块。 润滑剂 让业务功能实现更方便、更优雅。</strong></p>
<p>5.如何减少上下文切换<br> <strong>上下文切换是指CPU的控制权由运行任务转移到另外一个就绪任务时所发生的事件；</strong></p>
<p> <strong>对于任务耗时短的情况，要求线程尽量少，如果线程太多，有可能出现线程切换和管理的时间，大于任务执行的时间，那效率就低了；</strong><br> <strong>耗时长的任务，要分是cpu任务，还是io等类型的任务。如果是cpu类型的任务，线程数不宜太多；但是如果是io类型的任务，线程多一些更好，可以更充分利用cpu</strong><br> <strong>高并发，低耗时的情况，上下文切换 本来就多，并且高并发就意味着CPU是处于繁忙状态的， 增加更多地线程也不会让线程得到执行时间片, 反而会增加线程切换的开销.</strong><br> <strong>低并发，高耗时，保证有空闲线程，接收新任务，可以减少线程切换。</strong><br> <strong>高并发高耗时：1要分析任务类型，2增加排队，3、加大线程数</strong></p>
</li>
</ul>
<p>  6.Spring有什么缺点<br>   <strong>变的复杂。东西越来越多，拆分模块出来，不知道用什么。</strong><br>   <strong>学习源码困难度加大。</strong></p>
<p>  7.有限的资源里处理一个较大的数据<br>   <strong>如果你处理逻辑，跟全量数据有关，例如对全部数据进行排序，这个可以采用bitmap(索引，数据压缩方面有好的应用),堆排序等之类的，网上可以搜到。<br>但是如果你的处理逻辑跟全量数据无关，那就跟简单了，你可以设置一个buffer，每次读满一个buffer，处理完了，再读下一个buffer。</strong></p>
<p>  8.高并发，执行耗时短的任务，还有低并发，执行耗时长的任务，各自选取什么样的线程池会比较合理？为什么？如果业务场景是高并发，且任务耗时长时，有什么解决思路？<br>  <strong>线程池的关键点是：1、尽量减少线程切换和管理的开支； 2、最大化利用cpu。</strong><br>  <strong>对于1，要求线程数尽量少，这样可以减少线程切换和管理的开支；<br>对于2，要求尽量多的线程，以保证CPU资源最大化的利用。</strong><br>  <strong>对于高并发耗时长的情况，我认为，思路就是把一个难以解决的问题转化成我们已知的已经有解决方案的问题，以此来解决。<br>所以 ，高并发又耗时长，可以转化为<br>      1、高并发，耗时短的问题   –&gt;   异步处理+回调，和情况1吻合<br>      2、低并发，耗时长的问题   –&gt;   前端加load balance，把高并发分摊成若干低并发，和情况2吻合<br>其实说到核心，如果真遇到高并发耗时长的场景，只能是加机器，加计算单元（无论是异步加回调还是load balance）</strong></p>
<p>  9.数据库中内连接与外连接的区别<br>  <strong>这个问题从数学的角度更容易理解。<br>inner join：A与B的交集<br>left join：A的全集<br>right join：B的全集<br>full join：A与B的并集<br>cross join：A与B的笛卡尔积</strong></p>
<p>  10.经常看到url中很长的一串请求参数，为什么不采用post方式<br>  <strong>1 浏览器地址栏打开的默认就是GET，所以链接用GET很方便。<br>2 POST的提交需要表单或js提交，麻烦。<br>3 GET可以使用缓存<br>4 GET有利于SEO</strong></p>
<p>  11.有一个生成唯一串的需求，并发请求量非常大<br><strong>1.生成串由单线程批量生成。<br>2.并发获取的线程由队列（队列采用链表的阻塞队列实现）进行控制。<br>串的生成格式：ip+进程号+当前时间(精确到纳秒)+计数器（每次批量生成串的时候重置计数器为0）<br>可以解决，多机多JVM实例的问题，计数器可以解决时间相同的问题</strong></p>
<p>  12.处理大量并发用户访问网页，并且如何跟踪每个用户<br><strong>页面静态化，还有cdn代理等等 总之尽量减少或避免用户加载页面时与服务后台产生动态数据的加载</strong></p>
<p> 13.高并发解决方案<br> <strong>浏览器到前台页面，负载均衡，HTML静态化，缓存，图片服务器分离。数据库，读写分离，垂直拆分数据库，水平拆分数据库。</strong></p>
<p> 14.1亿条数据如何保存<br>  <strong>生成txt或者csv数据文件，再直接通过数据文件导入到数据库中。先删除索引，导入后在重建。</strong></p>
<p>15.1000万条数据如何取出来<br>  分页？</p>
<p>16.有3个线程ABC。按照ABC来运行（A线程输出A，B线程输出B，C线程输出C，以此类推，循环输出）。<br>  <strong>join</strong><br>  <strong>用 Reentrantlock，用它的newCondition() 方法创建3个condition，按顺序调用 condition 的await和signal 方法就可以了，具体看Reentrantlock 和Condition 讲解。</strong></p>
<p>17.threadlocal原理<br> **ThreadLocal 主要目的：<br>1、在同一线程中方法与方法，类与类之间的共享内容传输（也是官方创建ThreadLocal的本意）。<br>2、利用ThreadLocal 规避线程安全问题，这种方式已经大量应用，如Spring mvc 在Controller中注入全局HttpSession对象。</p>
<p>ThreadLocal原理：<br>Thread 类成员变量 ThreadLocal.ThreadLocalMap 详细不说了。**</p>
<p>18.分库分表如何控制事务，也就是分布式事务有什么解决方案<br><strong>所谓分布式事务最终解决的是数据一致性的问题，这也是典型的cap定理里面的东西没啥新鲜的。那么如何解决？<br>1，用redis做一个分布式锁，不过redis集群很麻烦，不太稳定（目前我们公司再用）<br>2，zk锁，推荐使用。：<br>3，数据库层面的东西，有一个mycat的东西，你可以了解下。</strong></p>
<p>19.让您做一个电商平台，您如何设置一个在买家下订单后的”第60秒“发短信通知卖家发货，您需要考虑的是 像淘宝一样的大并发量的订单。<em> ★★★★★★★★★★★★★★★★★<strong>
  </strong><br>  可以通过分布式调度框架来实现,将这种通用的调度任务交给专门的系统来处理,接收下单的时间和订单的基本信息做为触发这个任务的参数即可<br>触发动作可以用过类似kafka的消息中间件进行传递*</em></p>
<p><strong>1、具有排序功能的队列<br>2、Redis+定时器</strong><br><em>原理：第一种思路也就是大家推荐的延迟队列实现的原理，其就是一个按时间排好序的队列，每次put的时候排序，然后take的时候就计算时间是否过期，如果过期则返回队列第一个元素，否则当前线程阻塞X秒，这个也是JDK 自带 DelayQueue 的思路。详细可看源码</em><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pubic E <span class="title">take</span>(<span class="params"></span>) throws InterruptedException</span>&#123;</span><br><span class="line">  final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">  <span class="keyword">lock</span>.lockInterruptibly();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      E first = q.peek();</span><br><span class="line">      <span class="keyword">if</span>(first == <span class="keyword">null</span>)</span><br><span class="line">      available.await();</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> delay = first.getDelay(TimeUnit.NANOSECONFS);</span><br><span class="line">        <span class="keyword">if</span>(delay &lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> q.poll();</span><br><span class="line">        <span class="function"><span class="keyword">else</span> <span class="title">if</span>(<span class="params">leader != <span class="keyword">null</span></span>)</span><br><span class="line">        available.<span class="title">await</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">         Thread thisThread = Thread.currentThread();</span><br><span class="line">         leader = thisThread;</span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line">            available.awaitNanos(delay);</span><br><span class="line">         &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(leader == thisThread)</span><br><span class="line">           leader = <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(leader == <span class="keyword">null</span> &amp;&amp; peek() != <span class="keyword">null</span>)</span><br><span class="line">    available.signal();</span><br><span class="line">    <span class="keyword">lock</span>.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>原理：第二种思路需要利用Redis的有序集合，说到使用 Redis 就不得不考虑Score的设计，因为它直接决定你代码的复杂度，你思路的清晰性，在这我并没有采用 林中漫步 先生的设计，而是通过精确到秒的时间做Score（去掉毫秒），然后使用线程每一秒扫一次，使用当前时间作为zrangeBysocre命令的Score去查询。详细请看代码。<br>业务场景：按京东一天500万的成交量，一天主要成交时间为8小时，计算得出每秒173个订单，当然实际上订单不能均匀分布在每秒，但我们主要为了论证思想的可行性。<br>代码实现：这里首先我简单的利用Spring Scheduled作为订单的生产者，每一秒制造170个订单，放入Redis，注意Score的生成，为当前时间的后60秒，removeMillis()生成去掉毫秒的时间戳作为Rredis的Zadd方法的 Score（不了解的可以百度下）。</em><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Componment</span><br><span class="line"><span class="keyword">public</span> class OrderHanlder&#123;</span><br><span class="line">  <span class="keyword">private</span> Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line">  <span class="keyword">private</span> AtomicLong currentOrderId = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> simpleDateFormat sdformat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> KEY = <span class="string">"orders"</span>;</span><br><span class="line">  </span><br><span class="line">  @Scheduled(cron = <span class="string">"0/1 * * * * *"</span>)</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> initData() <span class="keyword">throws</span> ParseException&#123;</span><br><span class="line">   Calendar cal = <span class="keyword">new</span> Calendar();</span><br><span class="line">   cal.<span class="built_in">add</span>(Calender.SECOND,<span class="number">60</span>);<span class="comment">//获取当前日期的后60秒</span></span><br><span class="line">   Map&lt;<span class="keyword">String</span>,Double&gt; scores = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">//一天500w的成交量，8小时计算，每秒成交173份订单</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;<span class="number">170</span>;i++)&#123;</span><br><span class="line">     currentOrderId.getAndIncrement();</span><br><span class="line">     scores.put(currentOrderId.toString(),(<span class="keyword">double</span>)removeMillis(cal));</span><br><span class="line">     jedis.zadd(<span class="variable">key</span>,scores);</span><br><span class="line">     System.out.<span class="built_in">println</span>(<span class="string">"当前订单ID：---------"</span>+currentOrderId);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> removeMills(Canendar cal) <span class="keyword">throws</span> ParseException&#123;</span><br><span class="line">    <span class="keyword">String</span> date = sdformat.format(cal.getTime());</span><br><span class="line">    Date nowTime = sfformat.parse(date);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"---------当前时间： "</span>+nowTime + <span class="string">"-----毫秒数 "</span>+nowTime.getTime());</span><br><span class="line">    <span class="keyword">return</span> nowTime.getTime();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二步：同样利用Spring Scheduled 一秒钟心跳一次，每次利用当前时间作为Key 从Redis 取数据。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Scheduled</span>(cron=<span class="string">"0/1 * * * * *"</span>)</span><br><span class="line">public <span class="type">void</span> consumer() throws <span class="type">ParseException</span>&#123;</span><br><span class="line">  <span class="type">Calendar</span> cal = <span class="type">Calendar</span>.getInstance();</span><br><span class="line">  long score = removeMills(cal);</span><br><span class="line">  <span class="type">Set</span>&lt;<span class="type">String</span>&gt; orders = <span class="type">Jedis</span>.zrangeByScore(<span class="type">KEY</span>,<span class="number">0</span>,score);//早于当前时间的都应该被发送，因为可能订单太多没有处理过来</span><br><span class="line">  <span class="keyword">if</span>(orders.isEmpty()||orders,size() == <span class="number">0</span>)</span><br><span class="line">    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"========================暂时没有订单，时间："</span>+cal.getTime());</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">String</span> order:orders)&#123;</span><br><span class="line">    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"^^^^^^^^^^^^^^^^^^^^^^^^处理订单，订单ID： "</span>+order);</span><br><span class="line">    long <span class="literal">result</span> = jedis.zrem(<span class="type">KEY</span>,order);</span><br><span class="line">    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"^^^^^^^^^^^^^^^^^^^^^^^^处理完毕，订单ID： "</span>+order+<span class="string">" 删除结果"</span>+(<span class="literal">result</span> ==<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> private long removeMills(<span class="type">Canendar</span> cal) throws <span class="type">ParseException</span>&#123;</span><br><span class="line">    <span class="type">String</span> date = sdformat.format(cal.getTime());</span><br><span class="line">    <span class="type">Date</span> nowTime = sfformat.parse(date);</span><br><span class="line">    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"---------当前时间： "</span>+nowTime + <span class="string">"-----毫秒数 "</span>+nowTime.getTime());</span><br><span class="line">    <span class="keyword">return</span> nowTime.getTime();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>经过测试，没有出现漏单的情况，这只是简单的实现，很多地方可以优化，在实际中用也可能会出现很多问题，需要不断完善，此案例只是提供思路，另外我觉得JDK的 DelayQueue 相对于Redis来说没有那么好，因为Queue毕竟每次取一个，如果同一时间的比较多可能不能符合当前这种时间严谨的需求，另外他是单机的，有时间我去研究下kafka、Rabbit的延迟队列再来补充。</p>
<p>20.多维度查询的解决方案有哪些？<br><em>我们现在的公寓特别多，在页面用户可以根据多种维度进行筛选，比如“面积、房间、豪华程度、小区、新旧、交通、价格……”，这种场景如果放在数据库进行过滤，肯定是作死的节奏。</em><br> 这种一般用Nosql，而不是关系型数据库，比如elasticsearch搜索引擎，k-v键值对，可对同个商品同时建立多个标签进行多维度搜索，支持分页，高性能<br> 一般可以通过搜索引擎的方式来解决,比如ES,性能上无压力,无限集群<br> solr facet</p>
<p>21.集群环境如何保证某个机器挂掉了ng请求不再有访问打到这个机器<br><strong>Nginx有个负载均衡的插件叫做 nginx-upstream-fair：按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br>这种负载策略应该可以解决你那种问题，不用轮询。</strong></p>
<p>22.遇到OOM如何处理<br><strong>首先，要搞清OOM的分类：<br>OMM主要三类： permgen OOM , heap OOM, stack overflow<br>permgen OOM: 这个主要是由于加载的类太多，或者反射的类太多， 还有 调用 String.intend（jdk7之前）也会造成这个问题。所以出现了这个问题，就检查这三个方面；<br>heap OOM： 基本是按照 1楼的方式就可以解决了，主要是因为一些无用对象没有及时释放造成的，检查代码加上 heap dump 去分析吧<br>stack overflow： 这个主要是由于调用层数，或者递归深度太大造成的，看异常信息，基本上就能定位得出来了</strong></p>
<ul>
<li><h3 id="Java_集合类源码_？？？">Java 集合类源码 ？？？</h3></li>
<li><h3 id="设计模式的实际应用_？？？">设计模式的实际应用 ？？？</h3><p>1.单例模式<br>2.工厂模式<br>3.责任链模式<br>4.代理模式<br>5.模板方法模式-回调函数<br>6.策略模式<br>7.组合模式-递归调用<br>8.门面模式<br>9.观察者模式<br>10.中介者模式<br>11.享元模式<br>12.原型模式<br>13.命令模式<br>14.迭代器模式<br>15.桥接模式<br>16.构造者模式<br>17.适配器模式<br>18.备忘录模式<br>19.访问者模式<br>20.工厂方法模式<br>21.状态模式<br>22.解释器模式<br>23.装饰者模式</p>
</li>
<li><h3 id="Spring">Spring</h3><p>参考黄亿华老师的<strong>1000行代码读懂Spring核心</strong></p>
</li>
<li><h3 id="Tomcat">Tomcat</h3><p>参考前面总结的内容</p>
</li>
<li><h3 id="Openfire源码_-_10天">Openfire源码 - 10天</h3></li>
<li><h3 id="Mysql_sql优化_-_3天">Mysql sql优化 - 3天</h3></li>
<li><h3 id="Java_多线程_-_？？">Java 多线程 - ？？</h3></li>
<li><h3 id="Redis_-_1天">Redis - 1天</h3><p>回顾下红丸的教程</p>
</li>
<li><h3 id="脚本经验_-_nutch启动脚本">脚本经验 - nutch启动脚本</h3></li>
<li><h3 id="Jvm调优">Jvm调优</h3><p>实战例子？？？</p>
</li>
<li><h3 id="TCP/HTTP_协议，粘包，拆包问题_Socket/ServerSocket">TCP/HTTP 协议，粘包，拆包问题 Socket/ServerSocket</h3><p>自己实现简单的web服务器 ？？？</p>
</li>
</ul>
<h2 id="2-简历准备">2.简历准备</h2><h2 id="3-工作总结">3.工作总结</h2><h2 id="4-小故事贮备">4.小故事贮备</h2><h2 id="5-职业规划">5.职业规划</h2><h2 id="6-心态调整">6.心态调整</h2><h2 id="7-准备面试">7.准备面试</h2>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-知识点总结">1.知识点总结</h2><ul>
<li><h3 id="常见面试题整理">常见面试题整理</h3><p>1.Aio和Nio区别<br>  <strong>NIO:同步非阻塞；AIO:异步非阻塞</strong><br>  <strong>同步异]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tomcat源码知识点总结]]></title>
    <link href="http://zc14.github.io/2016/01/17/Tomcat%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://zc14.github.io/2016/01/17/Tomcat知识点总结/</id>
    <published>2016-01-17T01:38:32.000Z</published>
    <updated>2016-01-17T09:57:04.075Z</updated>
    <content type="html"><![CDATA[<h2 id="基于JMX的资源管理">基于JMX的资源管理</h2><p>   JMX可用于管理一个应用程序，一种实现，一个服务，一个设备，一个用户等。<br>   标准Bean–需要修改原来的类，实现一个MBean接口，灵活性不高，但是比较容易实现。<br>   模型Bean–灵活性高，Tomcat采用的就是这种方式。最大的挑战在于告诉ModelMBean对象托管资源的哪些属性和方法可以暴露给代理。这些方法写起来还是比较复杂的，为了简化工作，Apache基金会造就了<strong>Commons Modeler</strong>。通过解析配置文件xml的形式简化代码。</p>
<h2 id="StringManager-单例模式(内部类)">StringManager-单例模式(内部类)</h2><p>   ResourceBundle-实现国际化–每个核心包下面有三个properties文件，错误的粒度最小化</p>
<h2 id="使用字符数组提单字符串–提高效率。跟自己的想法又出入，正则。">使用字符数组提单字符串–提高效率。跟自己的想法又出入，正则。</h2><h2 id="coyote_tomcat默认的连接器">coyote tomcat默认的连接器</h2><h2 id="HTTP/1-1_特性_长连接/块编码/状态码100">HTTP/1.1 特性 长连接/块编码/状态码100</h2><h2 id="采用对象池来代替频繁的对象创建工作">采用对象池来代替频繁的对象创建工作</h2><h2 id="URLClassLoader">URLClassLoader</h2><p>   File file = new File(jar文件全路径);<br>   URL url = file.toURI().toURL();<br>   URLClassLoader loader = new URLClassLoader(new URL[]{url});<br>   Class tidyClazz = loader.loadClass(所需class的含包名的全名);</p>
<h2 id="代码分模块-降低耦合度_HttpConnector–Container">代码分模块-降低耦合度 HttpConnector–Container</h2><h2 id="容器Container是在哪儿与Connector建立连接的">容器Container是在哪儿与Connector建立连接的</h2><h2 id="老版本的Pipeline_与_Valve_在新版本中是怎么流转的">老版本的Pipeline 与 Valve 在新版本中是怎么流转的</h2><h2 id="组件生命周期-观察者模式">组件生命周期-观察者模式</h2><ul>
<li>管理org.apache.catalina.Lifecycle </li>
<li>事件监听器  org.apache.catalina.LifecycleListener </li>
<li>事件  org.apache.catalina.LifecycleEvent <ul>
<li>工具类 org.apache.catalina.util.LifecycleSupport<br>Tomcat组件可以嵌套，所以启动一个大容器，小容器也跟着启动。关闭上同样的</li>
</ul>
</li>
</ul>
<h2 id="自定义类的载入器">自定义类的载入器</h2><ol>
<li>安全 WEB-INF/classes 目录及其子目录</li>
<li>灵活，支持自动重载。老版本的设计理念<strong>类载入器使用一个额外的线程来不断得检查servlet类和其他类的文件的时间戳。</strong></li>
<li>org.apache.catalina.Loader/org.apache.catalina.loader.WebappLoader</li>
<li>提供缓存功能 protected final Map<string, resourceentry=""> resourceEntries = new ConcurrentHashMap&lt;&gt;()</string,></li>
</ol>
<h2 id="后台线程的统一管理_org-apache-catalina-core-StandardContext_—_backgroundProcess(),被org-apache-catalina-core-ContainerBase类中的一个专用线程周期性地调用。">后台线程的统一管理 org.apache.catalina.core.StandardContext — <strong>backgroundProcess()</strong>,被org.apache.catalina.core.ContainerBase类中的一个专用线程周期性地调用。</h2><h2 id="Session_管理">Session 管理</h2><ol>
<li>Session管理器组件负责管理Session对象。例如，创建和销毁Session对象。Session管理器是org.apache.catalina.Manager接口的实例。</li>
<li>用了外观模式StandardSessionFacade</li>
<li>session对象可以备份，也可以换出。org.apache.catalina.session.PersistentManagerBase-Store/FileStore/JDBCStore</li>
</ol>
<h2 id="Digester库的使用">Digester库的使用</h2><p>Apache基金会子项目，用于映射配置文件，创建对象</p>
<h2 id="钩子函数-回调函数，用于不正常退出造成的数据没处理完的情况_在tomcat的Catalina类中start方法就有体现">钩子函数-回调函数，用于不正常退出造成的数据没处理完的情况  在tomcat的Catalina类中start方法就有体现</h2><p>   <strong>Runtime.getRuntime().addShutdownHook(xxx implements Runnable);</strong></p>
<h2 id="统一启动/关闭服务的_服务器Server组件和服务Service组件">统一启动/关闭服务的 服务器Server组件和服务Service组件</h2><p>   org.apache.catalina.Server—org.apache.catalina.core.StandardServer<br>   org.apache.catalina.Service—org.apache.catalina.core.StandardService<br>   另外还有与生命周期有关的方法</p>
<h2 id="参考我的另外一篇文章，在为知笔记上，可以说总结的比较全。">参考我的另外一篇文章，在为知笔记上，可以说总结的比较全。</h2>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="基于JMX的资源管理">基于JMX的资源管理</h2><p>   JMX可用于管理一个应用程序，一种实现，一个服务，一个设备，一个用户等。<br>   标准Bean–需要修改原来的类，实现一个MBean接口，灵活性不高，但是比较容易实现。<br>   模型Bean]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tomcat8 源码解读]]></title>
    <link href="http://zc14.github.io/2016/01/16/Tomcat8-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://zc14.github.io/2016/01/16/Tomcat8-源码解读/</id>
    <published>2016-01-16T02:36:59.000Z</published>
    <updated>2016-01-16T10:51:29.814Z</updated>
    <content type="html"><![CDATA[<p>关于学习tomcat源码的一些知识总结<br><a id="more"></a></p>
<h2 id="总体介绍">总体介绍</h2><p>  <em><a href="http://tomcat.apache.org/tomcat-8.0-doc/config/http.html" target="_blank" rel="external">http://tomcat.apache.org/tomcat-8.0-doc/config/http.html</a></em><br>  1.AJP性能优于HTTP，网上有很多测试案例。所以正式环境优先使用二进制数据的AJP(需要Apache/ngnix配合使用)<br>  2.官方描述简单介绍</p>
<h3 id="[Connectors-HTTP]">[Connectors-HTTP]</h3><p><strong>Each incoming request requires a thread for the duration of that request.</strong><br><em>每个请求是会有一个对应的线程去进行处理。</em> If more simultaneous requests are received than can be handled by the currently available request processing threads, additional threads will be created up to the configured maximum (the value of the <strong>maxThreads</strong> attribute). If still more simultaneous requests are received, they are stacked up inside the server socket created by the Connector, up to the configured maximum (the value of the <strong>acceptCount</strong> attribute). Any further simultaneous requests will receive “connection refused” errors, until resources are available to process them.</p>
<h3 id="[Connectors-AJP]">[Connectors-AJP]</h3><p>The AJP Connector element represents a Connector component that communicates with a web connector via the AJP protocol. This is used for cases where you wish to invisibly integrate Tomcat into an existing (or new) Apache installation, and you want Apache to handle the <strong>static content</strong> contained in the web application, and/or utilize Apache’s SSL processing.可以看出AJP需要与Apache配合使用，访问静态资源文件有优势。Tomcat的作用更适合解析处理Servlet/Jsp。</p>
<h3 id="[Executor]">[Executor]</h3><p><strong>The Executor represents a thread pool that can be shared between components in Tomcat. Historically there has been a thread pool per connector created</strong> but this allows you to share a thread pool, between (primarily) connector but also other components when those get configured to support executors.Executor代表在tomcat组件之间共享的一个线程池。历史版本一个connector有一个自己的线程池。在tomcat6改变。<br>The executor has to implement the <strong>org.apache.catalina.Executor</strong> interface.<br>The executor is a <strong>nested element to the Service element</strong>. And in order for it to be picked up by the connectors, the Executor element has to appear prior to the Connector element in <em>server.xml</em>。<br>在Service接口中有对Executor提供方法操作声明：addExecutor/findExecutors/getExecutor/removeExecutor。<br><strong>线程池是在服务中配置的，在connector之间共享的。</strong>而且如果没有传递，会有一个默认的Executor(internalExecutor)在AbstractEndpoing类中供使用。</p>
<h2 id="首先一览众山小，介绍下tomcat架构中的几个组件">首先一览众山小，介绍下tomcat架构中的几个组件</h2><ul>
<li>Server  <em>服务器，web容器，Tomcat中最大的</em></li>
<li>Service <em>web容器能提供的服务</em></li>
<li>Connector <em>请求执行的通道，拿到新请求，扔给Container</em></li>
<li>Container <em>真正做事的地方，包含赫赫有名的四大组件</em><br>  1.Engine   <em>虚拟引擎</em><br>  2.Host     <em>虚拟主机</em><br>  3.Context  <em>web application</em><br>  4.Wrapper <em>servlet</em></li>
<li>Pipeline-Valve <em>责任链的完美诠释，各种StandardEngineValve，StandardHostValve，StandardContextValve，StandardWrpperValve</em></li>
<li>LifeCycle   <em>组件生命周期接口</em></li>
<li>JMX   <em>JavaBean动态管理</em></li>
<li>Realm  <em>权限模块</em></li>
</ul>
<p><strong>额外赠送serverStartupUML类图<a href="https://tomcat.apache.org/tomcat-8.0-doc/architecture/startup/serverStartup.pdf" target="_blank" rel="external">https://tomcat.apache.org/tomcat-8.0-doc/architecture/startup/serverStartup.pdf</a></strong><br>通过阅读此pdf，结合代码，总结一下tomcat在启动过程中需要做的几件事情：<br>1.加载配置文件catalina.properties<br>2.设置classLoader，从配置文件获取类的加载路径<br>3.利用classLoader，加载org.apache.catalina.startup.Catalina.<br>4.Catalina类加载，并解析servlet.xml</p>
<h2 id="休息一下，进入源码的解读">休息一下，进入源码的解读</h2><p>从标准的server开始<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Standard implementation of the &lt;b&gt;Server&lt;/b&gt; interface, available for use</span><br><span class="line"> * (but not required) when deploying and starting Catalina.</span><br><span class="line"> */</span></span><br><span class="line">public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardServer</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">LifecycleMBeanBase</span> <span class="title">implements</span> <span class="title">Server</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span><br><span class="line">     * The set of Services associated with this Server.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Service</span> services[] = <span class="keyword">new</span> <span class="type">Service</span>[<span class="number">0</span>];<span class="comment">//当前Server拥有的Service</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> servicesLock = <span class="keyword">new</span> <span class="type">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Add a new Service to the set of defined Services.</span><br><span class="line">     *</span><br><span class="line">     * @param service The Service to be added</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    public void addService(<span class="type">Service</span> service) &#123;</span><br><span class="line">	......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Standard implementation of the &lt;code&gt;Service&lt;/code&gt; interface.  The</span><br><span class="line"> * associated Container is generally an instance of Engine, but this is</span><br><span class="line"> * not required.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StandardService</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">LifecycleMBeanBase</span> <span class="title">implements</span> <span class="title">Service</span> &#123;</span></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">     * The &lt;code&gt;Server&lt;/code&gt; that owns this Service, if any.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Server</span> server = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/**</span><br><span class="line">     * The set of Connectors associated with this Service.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Connector</span> connectors[] = <span class="keyword">new</span> <span class="type">Connector</span>[<span class="number">0</span>];<span class="comment">//当前Service拥有的Connector</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> connectorsLock = <span class="keyword">new</span> <span class="type">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">ArrayList</span>&lt;<span class="type">Executor</span>&gt; executors = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();<span class="comment">//这个服务配置的线程池，可在多个Connector之间共享</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span><br><span class="line">     * The Container associated with this Service.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Container</span> container = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上文提到的官方启动UML类图,我们先从Connector开始入手<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Implementation of a Coyote connector.</span><br><span class="line"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Connector</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">LifecycleMBeanBase</span>  &#123;</span></span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/**</span><br><span class="line">     * Coyote Protocol handler class name.</span><br><span class="line">     * Defaults to the Coyote HTTP/1.1 protocolHandler.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> protocolHandlerClassName =</span><br><span class="line">        <span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span>;</span><br><span class="line"></span><br><span class="line">  public <span class="type">Connector</span>(<span class="type">String</span> protocol) &#123;</span><br><span class="line">        setProtocol(protocol);</span><br><span class="line">        <span class="comment">// Instantiate protocol handler</span></span><br><span class="line">        <span class="type">ProtocolHandler</span> p = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span>&lt;?&gt; clazz = <span class="type">Class</span>.forName(protocolHandlerClassName);</span><br><span class="line">            p = (<span class="type">ProtocolHandler</span>) clazz.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">Exception</span> e) &#123;</span><br><span class="line">            log.error(sm.getString(</span><br><span class="line">                    <span class="string">"coyoteConnector.protocolHandlerInstantiationFailed"</span>), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.protocolHandler = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="type">Globals</span>.<span class="type">STRICT_SERVLET_COMPLIANCE</span>) &#123;</span><br><span class="line">            <span class="type">URIEncoding</span> = <span class="string">"UTF-8"</span>;</span><br><span class="line">            <span class="type">URIEncodingLower</span> = <span class="type">URIEncoding</span>.toLowerCase(<span class="type">Locale</span>.<span class="type">ENGLISH</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Coyote protocol handler.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">ProtocolHandler</span> protocolHandler;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void initInternal() <span class="keyword">throws</span> <span class="type">LifecycleException</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize adapter</span></span><br><span class="line">        adapter = <span class="keyword">new</span> <span class="type">CoyoteAdapter</span>(<span class="keyword">this</span>);</span><br><span class="line">        protocolHandler.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure parseBodyMethodsSet has a default</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="literal">null</span> == parseBodyMethodsSet ) &#123;</span><br><span class="line">            setParseBodyMethods(getParseBodyMethods());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (protocolHandler.isAprRequired() &amp;&amp;</span><br><span class="line">                !<span class="type">AprLifecycleListener</span>.isAprAvailable()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">LifecycleException</span>(</span><br><span class="line">                    sm.getString(<span class="string">"coyoteConnector.protocolHandlerNoApr"</span>,</span><br><span class="line">                            getProtocolHandlerClassName()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            protocolHandler.init();<span class="comment">//方法核心ProtocolHandler.init</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">Exception</span> e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">LifecycleException</span></span><br><span class="line">                (sm.getString</span><br><span class="line">                 (<span class="string">"coyoteConnector.protocolHandlerInitializationFailed"</span>), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Begin processing requests via this Connector.</span><br><span class="line">     *</span><br><span class="line">     * @exception LifecycleException if a fatal startup error occurs</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void startInternal() <span class="keyword">throws</span> <span class="type">LifecycleException</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Validate settings before starting</span></span><br><span class="line">        <span class="keyword">if</span> (getPort() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">LifecycleException</span>(sm.getString(</span><br><span class="line">                    <span class="string">"coyoteConnector.invalidPort"</span>, <span class="type">Integer</span>.valueOf(getPort())));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setState(<span class="type">LifecycleState</span>.<span class="type">STARTING</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            protocolHandler.start();<span class="comment">//方法核心ProtocolHandler.start</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">Exception</span> e) &#123;</span><br><span class="line">            <span class="type">String</span> errPrefix = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.service != <span class="literal">null</span>) &#123;</span><br><span class="line">                errPrefix += <span class="string">"service.getName(): \""</span> + <span class="keyword">this</span>.service.getName() + <span class="string">"\"; "</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">LifecycleException</span></span><br><span class="line">                (errPrefix + <span class="string">" "</span> + sm.getString</span><br><span class="line">                 (<span class="string">"coyoteConnector.protocolHandlerStartFailed"</span>), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProtocolHandler是干嘛的，接着跟代码<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Abstract the protocol implementation, including threading, etc.</span><br><span class="line"> * Processor is single threaded and specific to stream-based protocols,</span><br><span class="line"> * will not fit Jk protocols like JNI.</span><br><span class="line"> *</span><br><span class="line"> * This is the main interface to be implemented by a coyote connector.</span><br><span class="line"> * Adapter is the main interface to be implemented by a coyote servlet</span><br><span class="line"> * container.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ProtocolHandler</span> &#123;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/**</span><br><span class="line">     * The adapter, used to call the connector.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdapter</span>(<span class="params">Adapter adapter</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * The executor, provide access to the underlying thread pool.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这边走到头了，返回上个类Connector，定位到protocolHandlerClassName = “org.apache.coyote.http11.Http11NioProtocol”，我们来看看Http11NioProtocol<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Abstract the protocol implementation, including threading, etc.</span><br><span class="line"> * Processor is single threaded and specific to stream-based protocols,</span><br><span class="line"> * will not fit Jk protocols like JNI.</span><br><span class="line"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Http11NioProtocol</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractHttp11JsseProtocol&lt;NioChannel&gt;</span> &#123;</span></span><br><span class="line">  public <span class="type">Http11NioProtocol</span>() &#123;</span><br><span class="line">        endpoint=<span class="keyword">new</span> <span class="type">NioEndpoint</span>();<span class="comment">//核心代码</span></span><br><span class="line">        cHandler = <span class="keyword">new</span> <span class="type">Http11ConnectionHandler</span>(<span class="keyword">this</span>);<span class="comment">//核心代码</span></span><br><span class="line">        ((<span class="type">NioEndpoint</span>) endpoint).setHandler(cHandler);</span><br><span class="line">        setSoLinger(<span class="type">Constants</span>.<span class="type">DEFAULT_CONNECTION_LINGER</span>);</span><br><span class="line">        setSoTimeout(<span class="type">Constants</span>.<span class="type">DEFAULT_CONNECTION_TIMEOUT</span>);</span><br><span class="line">        setTcpNoDelay(<span class="type">Constants</span>.<span class="type">DEFAULT_TCP_NO_DELAY</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过构造函数发现，在Http11NioProtocol中使用的是NioEndpoint，为这个endpoint指定的Handler是Http11ConnectionHandler类型。继续追踪父类<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHttp11JsseProtocol</span>&lt;<span class="title">S</span>&gt;</span><br><span class="line">        <span class="keyword">extends</span> <span class="title">AbstractHttp11Protocol</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不是不写注释，源码中并未添加对这个类的注解，可见这个类也不是核心，查看代码可知基本是setter和getter，接着跟<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHttp11Protocol&lt;S&gt;</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractProtocol&lt;S&gt;</span> &#123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProtocol</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">ProtocolHandler</span>,</span><br><span class="line">        <span class="title">MBeanRegistration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Endpoint that provides low-level network I/O - must be matched to the</span><br><span class="line">     * ProtocolHandler implementation (ProtocolHandler using BIO, requires BIO</span><br><span class="line">     * Endpoint etc.).</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> AbstractEndpoint&lt;S&gt; endpoint = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * The adapter provides the link between the ProtocolHandler and the</span><br><span class="line">     * connector.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Adapter adapter;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> MBeanServer mserver;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// ------------------------------------------------------- Lifecycle methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * <span class="doctag">NOTE:</span> There is no maintenance of state or checking for valid transitions</span><br><span class="line">     * within this class. It is expected that the connector will maintain state</span><br><span class="line">     * and prevent invalid state transitions.</span><br><span class="line">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getLog().isInfoEnabled())</span><br><span class="line">            getLog().info(sm.getString(<span class="string">"abstractProtocolHandler.init"</span>,</span><br><span class="line">                    getName()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oname == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Component not pre-registered so register it</span></span><br><span class="line">            oname = createObjectName();</span><br><span class="line">            <span class="keyword">if</span> (oname != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(<span class="keyword">this</span>, oname,</span><br><span class="line">                    <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.domain != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                tpOname = <span class="keyword">new</span> ObjectName(domain + <span class="string">":"</span> +</span><br><span class="line">                        <span class="string">"type=ThreadPool,name="</span> + getName());</span><br><span class="line">                Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(endpoint,</span><br><span class="line">                        tpOname, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                getLog().<span class="keyword">error</span>(sm.getString(</span><br><span class="line">                        <span class="string">"abstractProtocolHandler.mbeanRegistrationFailed"</span>,</span><br><span class="line">                        tpOname, getName()), e);</span><br><span class="line">            &#125;</span><br><span class="line">            rgOname=<span class="keyword">new</span> ObjectName(domain +</span><br><span class="line">                    <span class="string">":type=GlobalRequestProcessor,name="</span> + getName());</span><br><span class="line">            Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(</span><br><span class="line">                    getHandler().getGlobal(), rgOname, <span class="keyword">null</span> );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String endpointName = getName();</span><br><span class="line">        endpoint.setName(endpointName.substring(<span class="number">1</span>, endpointName.length()-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            endpoint.init();<span class="comment">//核心代码，endpoint.init</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            getLog().<span class="keyword">error</span>(sm.getString(<span class="string">"abstractProtocolHandler.initError"</span>,</span><br><span class="line">                    getName()), ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getLog().isInfoEnabled())</span><br><span class="line">            getLog().info(sm.getString(<span class="string">"abstractProtocolHandler.start"</span>,</span><br><span class="line">                    getName()));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            endpoint.start();<span class="comment">//核心代码，endpoint.start</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            getLog().<span class="keyword">error</span>(sm.getString(<span class="string">"abstractProtocolHandler.startError"</span>,</span><br><span class="line">                    getName()), ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码上看AbstractProtocol本身并不做太多请求解析处理相关的事情，它是把事情委托给了一个AbstractEndpoint对象来完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEndpoint</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * counter for nr of connections handled by an endpoint</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> LimitLatch connectionLimitLatch = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Threads used to accept new connections and pass them to worker threads.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Acceptor[] acceptors;<span class="comment">//意义很明确，接收新链接，扔给工作线程去执行。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//典型的模板方法，从createAcceptor()由子类去实现可以看出。骨架+钩子函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startAcceptorThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = getAcceptorThreadCount();</span><br><span class="line">        acceptors = <span class="keyword">new</span> Acceptor[count];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            acceptors[i] = createAcceptor();<span class="comment">//核心</span></span><br><span class="line">            String threadName = getName() + <span class="string">"-Acceptor-"</span> + i;</span><br><span class="line">            acceptors[i].setThreadName(threadName);</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(acceptors[i], threadName);</span><br><span class="line">            t.setPriority(getAcceptorThreadPriority());</span><br><span class="line">            t.setDaemon(getDaemon());<span class="comment">//true 守护线程</span></span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Hook to allow Endpoints to provide a specific Acceptor implementation.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Acceptor <span class="title">createAcceptor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxConnections = <span class="number">10000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Are we using an internal executor</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> internalExecutor = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * External Executor based thread pool.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> Executor executor = <span class="keyword">null</span>;<span class="comment">//此线程池可由外部指定，如果外部不指定，则由AbstractEndpoint自己来创建。由参数internalExecutor决定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExecutor</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">        <span class="keyword">this</span>.internalExecutor = (executor == <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> executor; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//AbstractEndpoint自己创建线程池的实现方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        internalExecutor = <span class="keyword">true</span>;</span><br><span class="line">        TaskQueue taskqueue = <span class="keyword">new</span> TaskQueue();</span><br><span class="line">        TaskThreadFactory tf = <span class="keyword">new</span> TaskThreadFactory(getName() + <span class="string">"-exec-"</span>, daemon, getThreadPriority());</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), <span class="number">60</span>, TimeUnit.SECONDS,taskqueue, tf);</span><br><span class="line">        taskqueue.setParent( (ThreadPoolExecutor) executor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Allows the server developer to specify the backlog that</span><br><span class="line">     * should be used for server sockets. By default, this value</span><br><span class="line">     * is 100.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> backlog = <span class="number">100</span>;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// ------------------------------------------------------- Lifecycle methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * <span class="doctag">NOTE:</span> There is no maintenance of state or checking for valid transitions</span><br><span class="line">     * within this class other than ensuring that bind/unbind are called in the</span><br><span class="line">     * right place. It is expected that the calling code will maintain state and</span><br><span class="line">     * prevent invalid state transitions.</span><br><span class="line">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        testServerCipherSuitesOrderSupport();</span><br><span class="line">        <span class="keyword">if</span> (bindOnInit) &#123;</span><br><span class="line">            bind();</span><br><span class="line">            bindState = BindState.BOUND_ON_INIT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bindState == BindState.UNBOUND) &#123;</span><br><span class="line">            bind();</span><br><span class="line">            bindState = BindState.BOUND_ON_START;</span><br><span class="line">        &#125;</span><br><span class="line">        startInternal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Http11NioProtocol的构造函数中指定的是使用NioEndpoint实例，因此这里通过分析AbstractEndpoint的子类NioEndpoint来做进一步的了解。这个是个加工厂，用于组装<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * NIO tailored thread pool, providing the following services:</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> * &lt;li&gt;Socket acceptor thread&lt;/li&gt;</span><br><span class="line"> * &lt;li&gt;Socket poller thread&lt;/li&gt;</span><br><span class="line"> * &lt;li&gt;Worker threads pool&lt;/li&gt;</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> *</span><br><span class="line"> * When switching to Java 5, there's an opportunity to use the virtual</span><br><span class="line"> * machine's thread pool.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEndpoint</span> <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------- Acceptor Inner Class</span></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * The background thread that listens for incoming TCP/IP connections and</span><br><span class="line">     * hands them off to an appropriate processor.</span><br><span class="line">     * Acceptor负责接收网络请求，建立连接。连接建立之后，将这个socket连接交给Poller。由Poller来负责执行数据的读取和业务执行</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span>.<span class="title">Acceptor</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span><br><span class="line">     * Process the specified connection.</span><br><span class="line">     * setSocketOptions方法是专门处理特定socket连接的方法，将一个SocketChannel对象包装成一个NioChannel之后，注册到Poller中</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">setSocketOptions</span><span class="params">(SocketChannel socket)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Process the connection</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//disable blocking, APR style, we are gonna be polling it</span></span><br><span class="line">            socket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            Socket sock = socket.socket();</span><br><span class="line">            socketProperties.setProperties(sock);</span><br><span class="line"></span><br><span class="line">            NioChannel channel = nioChannels.pop();</span><br><span class="line">            <span class="keyword">if</span> ( channel == <span class="keyword">null</span> ) &#123;</span><br><span class="line">                <span class="comment">// SSL setup</span></span><br><span class="line">                <span class="keyword">if</span> (sslContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// normal tcp setup</span></span><br><span class="line">                    NioBufferHandler bufhandler = <span class="keyword">new</span> NioBufferHandler(socketProperties.getAppReadBufSize(),</span><br><span class="line">                                                                       socketProperties.getAppWriteBufSize(),</span><br><span class="line">                                                                       socketProperties.getDirectBuffer());</span><br><span class="line"></span><br><span class="line">                    channel = <span class="keyword">new</span> NioChannel(socket, bufhandler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel.setIOChannel(socket);</span><br><span class="line">                <span class="keyword">if</span> ( channel <span class="keyword">instanceof</span> SecureNioChannel ) &#123;</span><br><span class="line">                    SSLEngine engine = createSSLEngine();</span><br><span class="line">                    ((SecureNioChannel)channel).reset(engine);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    channel.reset();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            getPoller0().register(channel);<span class="comment">//注册</span></span><br><span class="line">            <span class="comment">//getPoller0是从在startInternal方法中初始化的pollsers数组中取一个poller。然后通过Poller对象的register方法把这个channel注册到此Poller对象上。pollers数组的大小是根据当前的运行环境计算出来的，无法通过配置修改。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(t);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.<span class="keyword">error</span>(<span class="string">""</span>,t);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable tt) &#123;</span><br><span class="line">                ExceptionUtils.handleThrowable(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Tell to close the socket</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span><br><span class="line">     * Return an available poller in true round robin fashion 轮训调度方式</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Poller <span class="title">getPoller0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = Math.abs(pollerRotater.incrementAndGet()) % pollers.length;</span><br><span class="line">        <span class="keyword">return</span> pollers[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Poller class.</span><br><span class="line">     * 初始化pollers数组，同时启动pollers数组中的线程，让pollers开始工作。</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Selector selector;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> SynchronizedQueue&lt;PollerEvent&gt; events =</span><br><span class="line">                <span class="keyword">new</span> SynchronizedQueue&lt;&gt;();<span class="comment">//PollerEvent完成channel对selector的事件注册，具体可见代码</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">/**</span><br><span class="line">         * The background thread that listens for incoming TCP/IP connections and</span><br><span class="line">         * hands them off to an appropriate processor.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Loop until destroy() is called</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Loop if endpoint is paused</span></span><br><span class="line">                    <span class="keyword">while</span> (paused &amp;&amp; (!close) ) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="comment">// Ignore</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">boolean</span> hasEvents = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Time to terminate?</span></span><br><span class="line">                    <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                        events();</span><br><span class="line">                        timeout(<span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            selector.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                            log.<span class="keyword">error</span>(sm.getString(</span><br><span class="line">                                    <span class="string">"endpoint.nio.selectorCloseFail"</span>), ioe);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        hasEvents = events();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> ( !close ) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (wakeupCounter.getAndSet(-<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//if we are here, means we have other stuff to do</span></span><br><span class="line">                                <span class="comment">//do a non blocking select</span></span><br><span class="line">                                keyCount = selector.selectNow();</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                keyCount = selector.select(selectorTimeout);</span><br><span class="line">                            &#125;</span><br><span class="line">                            wakeupCounter.set(<span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                            events();</span><br><span class="line">                            timeout(<span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                selector.close();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                                log.<span class="keyword">error</span>(sm.getString(</span><br><span class="line">                                        <span class="string">"endpoint.nio.selectorCloseFail"</span>), ioe);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        ExceptionUtils.handleThrowable(x);</span><br><span class="line">                        log.<span class="keyword">error</span>(<span class="string">""</span>,x);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//either we timed out or we woke up, process events first</span></span><br><span class="line">                    <span class="keyword">if</span> ( keyCount == <span class="number">0</span> ) hasEvents = (hasEvents | events());</span><br><span class="line"><span class="comment">//正常状态下的数据处理，通过processKey来实现。获取对应的渠道的key，然后调用processKey方法</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">                        keyCount &gt; <span class="number">0</span> ? selector.selectedKeys().iterator() : <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// Walk through the collection of ready keys and dispatch</span></span><br><span class="line">                    <span class="comment">// any active event.</span></span><br><span class="line">                    <span class="keyword">while</span> (iterator != <span class="keyword">null</span> &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">                        SelectionKey sk = iterator.next();</span><br><span class="line">                        KeyAttachment attachment = (KeyAttachment)sk.attachment();</span><br><span class="line">                        <span class="comment">// Attachment may be null if another thread has called</span></span><br><span class="line">                        <span class="comment">// cancelledKey()</span></span><br><span class="line">                        <span class="keyword">if</span> (attachment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            iterator.remove();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            attachment.access();</span><br><span class="line">                            iterator.remove();</span><br><span class="line">                            processKey(sk, attachment);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//process timeouts</span></span><br><span class="line">                    timeout(keyCount,hasEvents);</span><br><span class="line">                    <span class="keyword">if</span> ( oomParachute &gt; <span class="number">0</span> &amp;&amp; oomParachuteData == <span class="keyword">null</span> ) checkParachute();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (OutOfMemoryError oom) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        oomParachuteData = <span class="keyword">null</span>;</span><br><span class="line">                        releaseCaches();</span><br><span class="line">                        log.<span class="keyword">error</span>(<span class="string">""</span>, oom);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> ( Throwable oomt ) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.err.println(oomParachuteMsg);</span><br><span class="line">                            oomt.printStackTrace();</span><br><span class="line">                        &#125;<span class="keyword">catch</span> (Throwable letsHopeWeDontGetHere)&#123;</span><br><span class="line">                            ExceptionUtils.handleThrowable(letsHopeWeDontGetHere);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">            stopLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//processKey的主要工作是调用NioEndpoint的processSocket来实现socket的读写</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">processKey</span><span class="params">(SelectionKey sk, KeyAttachment attachment)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> ( isWorkerAvailable() ) &#123;</span><br><span class="line">                                unreg(sk, attachment, sk.readyOps());</span><br><span class="line">                                <span class="keyword">boolean</span> closeSocket = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="comment">// Read goes before write</span></span><br><span class="line">                                <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (!processSocket(attachment, SocketStatus.OPEN_READ, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                                        closeSocket = <span class="keyword">true</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (!closeSocket &amp;&amp; sk.isWritable()) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (!processSocket(attachment, SocketStatus.OPEN_WRITE, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                                        closeSocket = <span class="keyword">true</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (closeSocket) &#123;</span><br><span class="line">                                    cancelledKey(sk,SocketStatus.DISCONNECT);</span><br><span class="line">                                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">processSocket</span><span class="params">(KeyAttachment attachment, SocketStatus status, <span class="keyword">boolean</span> dispatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (attachment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            SocketProcessor sc = processorCache.pop();</span><br><span class="line">            <span class="keyword">if</span> ( sc == <span class="keyword">null</span> ) sc = <span class="keyword">new</span> SocketProcessor(attachment, status);</span><br><span class="line">            <span class="function"><span class="keyword">else</span> sc.<span class="title">reset</span><span class="params">(attachment, status)</span></span>;</span><br><span class="line">            Executor executor = getExecutor();<span class="comment">//使用线程池--整个的流程client-&gt;Acceptor-&gt;Poller-&gt;Socket Processor（Executor）</span></span><br><span class="line">            <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                executor.execute(sc);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sc.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException ree) &#123;</span><br><span class="line">            log.warn(sm.getString(<span class="string">"endpoint.executor.fail"</span>, attachment.getSocket()), ree);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(t);</span><br><span class="line">            <span class="comment">// This means we got an OOM or similar creating a thread, or that</span></span><br><span class="line">            <span class="comment">// the pool and its queue are full</span></span><br><span class="line">            log.<span class="keyword">error</span>(sm.getString(<span class="string">"endpoint.process.fail"</span>), t);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ---------------------------------------------- SocketProcessor Inner Class</span></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * This class is the equivalent of the Worker, but will simply use in an</span><br><span class="line">     * external Executor thread pool.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketProcessor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Initialize the endpoint.监听端口</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        serverSock = ServerSocketChannel.open();</span><br><span class="line">        socketProperties.setProperties(serverSock.socket());</span><br><span class="line">        InetSocketAddress addr = (getAddress()!=<span class="keyword">null</span>?<span class="keyword">new</span> InetSocketAddress(getAddress(),getPort()):<span class="keyword">new</span> InetSocketAddress(getPort()));</span><br><span class="line">        serverSock.socket().bind(addr,getBacklog());</span><br><span class="line">        serverSock.configureBlocking(<span class="keyword">true</span>); <span class="comment">//mimic APR behavior</span></span><br><span class="line">        serverSock.socket().setSoTimeout(getSocketProperties().getSoTimeout());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize thread count defaults for acceptor, poller</span></span><br><span class="line">        <span class="keyword">if</span> (acceptorThreadCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">FIXME:</span> Doesn't seem to work that well with multiple accept threads</span></span><br><span class="line">            acceptorThreadCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pollerThreadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//minimum one poller thread</span></span><br><span class="line">            pollerThreadCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stopLatch = <span class="keyword">new</span> CountDownLatch(pollerThreadCount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize SSL if needed</span></span><br><span class="line">        <span class="keyword">if</span> (isSSLEnabled()) &#123;</span><br><span class="line">           ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oomParachute&gt;<span class="number">0</span>) reclaimParachute(<span class="keyword">true</span>);</span><br><span class="line">        selectorPool.open();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Start the NIO endpoint, creating acceptor, poller threads.</span><br><span class="line">     * 初始化线程池，创建和启动网络数据接收线程组，创建和启动poller线程组</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">            running = <span class="keyword">true</span>;</span><br><span class="line">            paused = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            processorCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                    socketProperties.getProcessorCache());</span><br><span class="line">            eventCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                            socketProperties.getEventCache());</span><br><span class="line">            nioChannels = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                    socketProperties.getBufferPool());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create worker collection</span></span><br><span class="line">            <span class="keyword">if</span> ( getExecutor() == <span class="keyword">null</span> ) &#123;</span><br><span class="line">                createExecutor();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            initializeConnectionLatch();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start poller threads</span></span><br><span class="line">            pollers = <span class="keyword">new</span> Poller[getPollerThreadCount()];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class="line">                pollers[i] = <span class="keyword">new</span> Poller();</span><br><span class="line">                Thread pollerThread = <span class="keyword">new</span> Thread(pollers[i], getName() + <span class="string">"-ClientPoller-"</span>+i);</span><br><span class="line">                pollerThread.setPriority(threadPriority);</span><br><span class="line">                pollerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                pollerThread.start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            startAcceptorThreads();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结一下：<br>[Acceptor]：<br>     负责监听并接收socket连接建立。由Acceptor来控制与服务端建立连接的客户端socket数目。具体的数目为一个服务可配置项，可以在启动服务时指定.默认的配置在AbstractEndpoint中，初始值为10000</p>
<p>[Poller]：<br>     负责处理已建立连接的socket，将channel封装后，提交至线程池（Executors）来处理。Poller线程的数目与运行时环境有关，通过计算得出，不可配置。</p>
<p>[Executors]：<br>     处理socket请求的线程池。线程池中线程的数目可在启动服务时配置。<br>socket.getPoller()返回这个channel所注册的Poller对象。getSelector()返回这个Poller对象的selector。注册之后，当这个socket的channel有数据到达，便能通过selector.select活selector.selectNow被返回，放入到Executor中进行处理。</p>
<p>继续<br>在Http11NioProtocol构造函数中有个Http11ConnectionHandler我们还没分析，下面来看看。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --------------------  Connection handler --------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Http11ConnectionHandler</span></span><br><span class="line">            <span class="keyword">extends</span> <span class="title">AbstractConnectionHandler</span>&lt;<span class="title">Long</span>,<span class="title">Http11AprProcessor</span>&gt; <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> Http11AprProtocol proto;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Processes HTTP requests.</span><br><span class="line"> *</span><br><span class="line"> * @author Remy Maucherat</span><br><span class="line"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Http11AprProcessor</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractHttp11Processor&lt;Long&gt;</span> &#123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getAdapter().service(request, response);，用于处理用户自定义Servlet请求的地方<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> abstract <span class="keyword">class</span> AbstractHttp11Processor&lt;S&gt; extends AbstractProcessor&lt;S&gt; &#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">     * Process pipelined HTTP requests using the specified input and output</span><br><span class="line">     * streams.</span><br><span class="line">     *</span><br><span class="line">     * @param socketWrapper Socket from which the HTTP requests will be read</span><br><span class="line">     *               and the HTTP responses will be written.</span><br><span class="line">     *</span><br><span class="line">     * @throws IOException error during an I/O operation</span><br><span class="line">     */</span></span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> SocketState <span class="title">process</span><span class="params">(SocketWrapper&lt;S&gt; socketWrapper)</span></span><br><span class="line">        throws IOException </span>&#123;</span><br><span class="line">        RequestInfo rp = request.getRequestProcessor();</span><br><span class="line">        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Setting up the I/O</span></span><br><span class="line">        setSocketWrapper(socketWrapper);</span><br><span class="line">        getInputBuffer().init(socketWrapper, endpoint);</span><br><span class="line">        getOutputBuffer().init(socketWrapper, endpoint);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Flags</span></span><br><span class="line">        keepAlive = <span class="literal">true</span>;</span><br><span class="line">        comet = <span class="literal">false</span>;</span><br><span class="line">        openSocket = <span class="literal">false</span>;</span><br><span class="line">        sendfileInProgress = <span class="literal">false</span>;</span><br><span class="line">        readComplete = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (endpoint.getUsePolling()) &#123;</span><br><span class="line">            keptAlive = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            keptAlive = socketWrapper.isKeptAlive();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (disableKeepAlive()) &#123;</span><br><span class="line">            socketWrapper.setKeepAliveLeft(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!getErrorState().isError() &amp;&amp; keepAlive &amp;&amp; !comet &amp;&amp; !isAsync() &amp;&amp;</span><br><span class="line">                httpUpgradeHandler == null &amp;&amp; !endpoint.isPaused()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Parsing the request header</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                setRequestLineReadTimeout();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!getInputBuffer().parseRequestLine(keptAlive)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (handleIncompleteRequestLineRead()) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (endpoint.isPaused()) &#123;</span><br><span class="line">                    <span class="comment">// 503 - Service unavailable</span></span><br><span class="line">                    response.setStatus(<span class="number">503</span>);</span><br><span class="line">                    setErrorState(ErrorState.CLOSE_CLEAN, null);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    keptAlive = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// Set this every time in case limit has been changed via JMX</span></span><br><span class="line">                    request.getMimeHeaders().setLimit(endpoint.getMaxHeaderCount());</span><br><span class="line">                    <span class="comment">// Currently only NIO will ever return false here</span></span><br><span class="line">                    <span class="keyword">if</span> (!getInputBuffer().parseHeaders()) &#123;</span><br><span class="line">                        <span class="comment">// We've read part of the request, don't recycle it</span></span><br><span class="line">                        <span class="comment">// instead associate it with the socket</span></span><br><span class="line">                        openSocket = <span class="literal">true</span>;</span><br><span class="line">                        readComplete = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!disableUploadTimeout) &#123;</span><br><span class="line">                        setSocketTimeout(connectionUploadTimeout);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getLog().isDebugEnabled()) &#123;</span><br><span class="line">                    getLog().debug(</span><br><span class="line">                            sm.getString(<span class="string">"http11processor.header.parse"</span>), e);</span><br><span class="line">                &#125;</span><br><span class="line">                setErrorState(ErrorState.CLOSE_NOW, e);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                ExceptionUtils.handleThrowable(t);</span><br><span class="line">                UserDataHelper.Mode logMode = userDataHelper.getNextMode();</span><br><span class="line">                <span class="keyword">if</span> (logMode != null) &#123;</span><br><span class="line">                    String message = sm.getString(</span><br><span class="line">                            <span class="string">"http11processor.header.parse"</span>);</span><br><span class="line">                    <span class="keyword">switch</span> (logMode) &#123;</span><br><span class="line">                        <span class="keyword">case</span> INFO_THEN_DEBUG:</span><br><span class="line">                            message += sm.getString(</span><br><span class="line">                                    <span class="string">"http11processor.fallToDebug"</span>);</span><br><span class="line">                            <span class="comment">//$FALL-THROUGH$</span></span><br><span class="line">                        <span class="keyword">case</span> INFO:</span><br><span class="line">                            getLog().info(message);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> DEBUG:</span><br><span class="line">                            getLog().debug(message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 400 - Bad Request</span></span><br><span class="line">                response.setStatus(<span class="number">400</span>);</span><br><span class="line">                setErrorState(ErrorState.CLOSE_CLEAN, t);</span><br><span class="line">                getAdapter().<span class="built_in">log</span>(request, response, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!getErrorState().isError()) &#123;</span><br><span class="line">                <span class="comment">// Setting up filters, and parse some request headers</span></span><br><span class="line">                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    prepareRequest();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    ExceptionUtils.handleThrowable(t);</span><br><span class="line">                    <span class="keyword">if</span> (getLog().isDebugEnabled()) &#123;</span><br><span class="line">                        getLog().debug(sm.getString(</span><br><span class="line">                                <span class="string">"http11processor.request.prepare"</span>), t);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 500 - Internal Server Error</span></span><br><span class="line">                    response.setStatus(<span class="number">500</span>);</span><br><span class="line">                    setErrorState(ErrorState.CLOSE_CLEAN, t);</span><br><span class="line">                    getAdapter().<span class="built_in">log</span>(request, response, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (maxKeepAliveRequests == <span class="number">1</span>) &#123;</span><br><span class="line">                keepAlive = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxKeepAliveRequests &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    socketWrapper.decrementKeepAlive() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                keepAlive = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the request in the adapter</span></span><br><span class="line">            <span class="keyword">if</span> (!getErrorState().isError()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);</span><br><span class="line">                    getAdapter().service(request, response);<span class="comment">//核心代码</span></span><br><span class="line">                    <span class="comment">// Handle when the response was committed before a serious</span></span><br><span class="line">                    <span class="comment">// error occurred.  Throwing a ServletException should both</span></span><br><span class="line">                    <span class="comment">// set the status to 500 and set the errorException.</span></span><br><span class="line">                    <span class="comment">// If we fail here, then the response is likely already</span></span><br><span class="line">                    <span class="comment">// committed, so we can't try and set headers.</span></span><br><span class="line">                    <span class="keyword">if</span>(keepAlive &amp;&amp; !getErrorState().isError() &amp;&amp; (</span><br><span class="line">                            response.getErrorException() != null ||</span><br><span class="line">                                    (!isAsync() &amp;&amp;</span><br><span class="line">                                    statusDropsConnection(response.getStatus())))) &#123;</span><br><span class="line">                        setErrorState(ErrorState.CLOSE_CLEAN, null);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setCometTimeouts(socketWrapper);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedIOException e) &#123;</span><br><span class="line">                    setErrorState(ErrorState.CLOSE_NOW, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (HeadersTooLargeException e) &#123;</span><br><span class="line">                    <span class="comment">// The response should not have been committed but check it</span></span><br><span class="line">                    <span class="comment">// anyway to be safe</span></span><br><span class="line">                    <span class="keyword">if</span> (response.isCommitted()) &#123;</span><br><span class="line">                        setErrorState(ErrorState.CLOSE_NOW, e);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        response.reset();</span><br><span class="line">                        response.setStatus(<span class="number">500</span>);</span><br><span class="line">                        setErrorState(ErrorState.CLOSE_CLEAN, e);</span><br><span class="line">                        response.setHeader(<span class="string">"Connection"</span>, <span class="string">"close"</span>); <span class="comment">// <span class="doctag">TODO:</span> Remove</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    ExceptionUtils.handleThrowable(t);</span><br><span class="line">                    getLog().error(sm.getString(</span><br><span class="line">                            <span class="string">"http11processor.request.process"</span>), t);</span><br><span class="line">                    <span class="comment">// 500 - Internal Server Error</span></span><br><span class="line">                    response.setStatus(<span class="number">500</span>);</span><br><span class="line">                    setErrorState(ErrorState.CLOSE_CLEAN, t);</span><br><span class="line">                    getAdapter().<span class="built_in">log</span>(request, response, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Finish the handling of the request</span></span><br><span class="line">            rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isAsync() &amp;&amp; !comet) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getErrorState().isError()) &#123;</span><br><span class="line">                    <span class="comment">// If we know we are closing the connection, don't drain</span></span><br><span class="line">                    <span class="comment">// input. This way uploading a 100GB file doesn't tie up the</span></span><br><span class="line">                    <span class="comment">// thread if the servlet has rejected it.</span></span><br><span class="line">                    getInputBuffer().setSwallowInput(<span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Need to check this again here in case the response was</span></span><br><span class="line">                    <span class="comment">// committed before the error that requires the connection</span></span><br><span class="line">                    <span class="comment">// to be closed occurred.</span></span><br><span class="line">                    checkExpectationAndResponseStatus();</span><br><span class="line">                &#125;</span><br><span class="line">                endRequest();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If there was an error, make sure the request is counted as</span></span><br><span class="line">            <span class="comment">// and error, and update the statistics counter</span></span><br><span class="line">            <span class="keyword">if</span> (getErrorState().isError()) &#123;</span><br><span class="line">                response.setStatus(<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isAsync() &amp;&amp; !comet || getErrorState().isError()) &#123;</span><br><span class="line">                request.updateCounters();</span><br><span class="line">                <span class="keyword">if</span> (getErrorState().isIoAllowed()) &#123;</span><br><span class="line">                    getInputBuffer().nextRequest();</span><br><span class="line">                    getOutputBuffer().nextRequest();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!disableUploadTimeout) &#123;</span><br><span class="line">                <span class="keyword">if</span>(endpoint.getSoTimeout() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    setSocketTimeout(endpoint.getSoTimeout());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    setSocketTimeout(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (breakKeepAliveLoop(socketWrapper)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getErrorState().isError() || endpoint.isPaused()) &#123;</span><br><span class="line">            <span class="keyword">return</span> SocketState.CLOSED;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAsync() || comet) &#123;</span><br><span class="line">            <span class="keyword">return</span> SocketState.LONG;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUpgrade()) &#123;</span><br><span class="line">            <span class="keyword">return</span> SocketState.UPGRADING;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sendfileInProgress) &#123;</span><br><span class="line">                <span class="keyword">return</span> SocketState.SENDFILE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (openSocket) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (readComplete) &#123;</span><br><span class="line">                        <span class="keyword">return</span> SocketState.OPEN;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> SocketState.LONG;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> SocketState.CLOSED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终执行代码的adapter是来自于AbstractHttp11Protocol。还记得在Connector的startInternal函数么，在那里使用的是protocolHandler就是org.apache.coyote.http11.Http11NioProtocol，它继承了AbstractHttp11Protocol，所以这个最终的adapter是来自Http11NioProtocol的setAdapter方法传递进来。而这个方法，在Connector的initInternal中被调用，并且实际上就是这个Connector对象本身。</p>
<p>总结一下Tomcat中的几个核心模块<br><strong>[Acceptor]</strong><br>负责用来管理连接到tomcat服务器的数量，来看看Acceptor在tomcat服务器中的应用，是如何实现连接管理的，socket连接建立成功之后，是如何实现内容的读写的（读写是交由Poller机制去完成）。</p>
<p><strong>[连接的传递]</strong><br>管理连接的建立差不多就是Acceptor的主要工作了，连接建立好之后，最后的工作就是交给Poller去实现数据的读写。在setSocketOptions中实现了SocketChannel对Poller的注册。</p>
<p><strong>[Connection Handler]</strong><br>处理socket连接的handler<br>content:  Http11ConnectionHandler、AbstractConnectionHandler、AbstractEndpoint.Handler<br>主要内容部分在AbstractConnectionHandler上，从在这个类中定义的方法上和成员变量上可以看出，它作为一个Handler，但实际上并不直接对socket进行处理。它的主要作用是提供了将Processor和connection进行关联的地方，在适合的地方调用Processor去处理connection。还一个作用是在ConnectionHandler中维护内部缓存来提升系统性能。</p>
<p>在AbstractConnectionHandler的process方法中，实现了对socket的状态检查，缓存数据读写等操作。虽然是在这里对socket进行了各种检查，但并不涉及socket数据的处理，对socket的实际处理，还是交给了Processor来完成。</p>
<p>通过抽象方法 createProcessor方法，来作为关联Processor的入口。通过getProtocol方法，来作为获取和此Connection Handler关联的protocol的入口。</p>
<p><strong>[Socket Processor]</strong><br>处理socket数据<br>content: Http11Processor、AbstractHttp11Processor、org.apache.coyote.AbstractProcessor、org.apache.coyote.Processor</p>
<p>Socket Processor是具体处理socket，读写socket数据的地方。</p>
<p>最上层的Processor接口定义了getExecutor、process、event、getRequest等接口，定义了socket processor的大致模型。<br>     getExecutor方法定义了获取处理socket的线程池入口<br>     process方法是处理socket的入口<br>     event处理socket事件的地方<br>     request获取请求来源的入口<br>次一层的AbstractProcessor定义了Socket Processor框架和其它模块的交互关系，从AbstractProcessor的属性中可以看出<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProcessor</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">ActionHook</span>, <span class="title">Processor</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> StringManager sm = StringManager.getManager(Constants.Package);</span><br><span class="line">        <span class="keyword">protected</span> Adapter adapter;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> AsyncStateMachine asyncStateMachine ;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> AbstractEndpoint&lt;S&gt; endpoint ;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> Request request ;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> Response response ;</span><br><span class="line">        <span class="keyword">protected</span> SocketWrapper&lt;S&gt; socketWrapper = <span class="keyword">null</span> ;</span><br></pre></td></tr></table></figure></p>
<p> 一个Adapter对象，用来和tomcat容器进行关联，这里是实现了和Connector的关联。<br>          Adapter的作用在其注释中描述如下“Adapter. This represents the entry point in a coyote -based servlet container.”<br>     一个AbstractEndpoint对象，用来和Endpoint模块进行关联，实现对基础网络I/O的屏蔽。</p>
<p>AbstractHttp11Processor中包含了更多的处理http请求相关的细节，包括使用的http协议、socket的维持状态、内容压缩等。同时，更重要的一点是，它实现了process方法，这是整个Socket Processor框架处理http请求的核心部分。从实现的process方法中，可以看出Socket Processor框架的工作原理。 process方法做了各种分支的检查，处理了http请求的各种状态。根据所处理的http请求的状态，设置request和response的状态，最后正常的http请求相关的业务，会交由Adapter的service去进行处理，转移到Connector上来执行。</p>
<p><strong>[Endpoint]</strong><br>Endpoint是基础的网络设施，通过Endpoint来实现网络连接和控制，它是服务器对外I/O操作的接入点。主要任务是管理对外的socket连接，同时将建立好的socket连接交到合适的工作线程中去。<br>content：org.apache.tomcat.util.net.AbstractEndpoint，org.apache.tomcat.util.net.NioEndpoint</p>
<p>对于AbstractEndpoint主要关注它的以下几个属性<br>     private Executor executor = null;   执行业务的线程池，如果外部没有指定线程池，就使用Endpoint内部的线程池<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Threads used <span class="keyword">to</span> accept <span class="keyword">new</span> connections <span class="keyword">and</span> pass them <span class="keyword">to</span> worker threads.</span><br><span class="line">*/</span><br><span class="line"> <span class="keyword">protected</span> Acceptor[] acceptors;  管理连接</span><br></pre></td></tr></table></figure></p>
<p>对于NioEndpoint主要关注它的一下几个属性<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Handling of accepted sockets.</span><br><span class="line"> */</span></span><br><span class="line">private <span class="operator"><span class="keyword">Handler</span> <span class="keyword">handler</span> = <span class="literal">null</span> ;</span> 处理socket连接的<span class="operator"><span class="keyword">handler</span>，属于业务处理部分，在executor线程池中执行</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * The socket poller.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> Poller[] pollers = <span class="literal">null</span> ;</span> 监听socket事件，调用<span class="operator"><span class="keyword">handler</span>进行socket处理。</span></span><br></pre></td></tr></table></figure></p>
<p>它的内部组成包括Poller线程组和Acceptor线程组。</p>
<p>Acceptor线程组负责接收来自外部的网络连接请求，并将建立好的连接，交到Poller线程组去处理。Acceptor的具体工作原理，可以从NioEndpoint$Acceptor.run方法中可以看出，(countUpOrAwaitConnection)控制接收的连接的数量，对接收的连接，(setSocketOptions)将其注册到Poller线程组中，如果在操作过程中遇到错误，则关闭连接。连接注册到Poller线程组后，Poller就能够读取连接中的数据，并进行处理。注册到Poller线程上的效果，是将socket封装后放入Poller线程内部维护的一个PollerEvent队列中，然后Poller线程运行时处理队列，将socket注册到这个Poller的Selector上。</p>
<p>Poller线程组负责对已建立连接的socket进行处理。从NioEndpoint$Poller.run方法中可以看出Poller线程的工作原理，基于Java NIO来进行网络的读写。在run方法中，通过selector.select系列方法来获取数据，然后经由processKey到processSocket方法，封装成一个SocketProcessor对象后，放在EndPoint的线程池中执行，但实际的业务处理部分，是通过Endpoint的Handler进行处理。</p>
<p>下面简要说下后面的处理流程<br><strong>SocketProcessor</strong> –&gt;  <strong>Http11ConnectionHandler</strong> –&gt;  <strong>Http11Processor</strong> –&gt;  <strong>CoyoteApapter</strong> –&gt;  <strong>StandardEngineValve</strong> –&gt;  <strong>StandHostValve</strong> –&gt;  <strong>StandardContextValve</strong> –&gt;  <strong>StandardWrapperValve</strong> –&gt;  <strong>Application Filter Chain</strong> –&gt;  <strong>Servlet</strong></p>
<p>文章参考来源：大神 <a href="http://blog.csdn.net/yanlinwang/article/category/1398223" target="_blank" rel="external">http://blog.csdn.net/yanlinwang/article/category/1398223</a><br><a href="http://blog.csdn.net/cutesource/article/category/631854" target="_blank" rel="external">http://blog.csdn.net/cutesource/article/category/631854</a><br>明天继续，总结下深入剖析Tomcat，Tomcat的深入了解告一段落，开启新的路程。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于学习tomcat源码的一些知识总结<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java TCP/IP Socket编程]]></title>
    <link href="http://zc14.github.io/2016/01/13/Java-TCP-IP-Socket%E7%BC%96%E7%A8%8B/"/>
    <id>http://zc14.github.io/2016/01/13/Java-TCP-IP-Socket编程/</id>
    <published>2016-01-13T05:37:00.000Z</published>
    <updated>2016-01-15T06:06:35.184Z</updated>
    <content type="html"><![CDATA[<p>Java TCP/IP Socket编程 读书笔记，一本好书，值得多看几遍<br><a id="more"></a></p>
<h2 id="1-网络构成">1.网络构成</h2><p> 主机+路由器+物理的网络线路（通信信道）</p>
<h2 id="2-协议的定义">2.协议的定义</h2><p> 协议相当于相互通信的程序间达成的一种约定，它规定了分组报文的结构、交换方式、包含的意义以及怎样对报文所包含的信息进行解析。</p>
<h2 id="3-TCP/IP网络">3.TCP/IP网络</h2><p> IP–IP地址<br> TCP/UDP–端口</p>
<h2 id="4-信息处理流程">4.信息处理流程</h2><p> 应用程序-套接字-TCP/UDP-IP-通信信道- IP - 通信信道 -IP-TCP/UDP-套接字-应用程序<br> 主机                    -以太网等|路由器|        -主机           </p>
<h2 id="5-IP网络层_TCP/UDP传输层">5.IP网络层 TCP/UDP传输层</h2><h2 id="6-TCP协议和UDP协议也成为端到端协议，因为它们将数据从一个应用程序传输到另一个应用程序，而IP协议只是将数据从一个主机传输到另一个主机。">6.TCP协议和UDP协议也成为端到端协议，因为它们将数据从一个应用程序传输到另一个应用程序，而IP协议只是将数据从一个主机传输到另一个主机。</h2><h2 id="7-TCP协议是一个面向连接的协议3次握手，保证数据传输的可信赖性。_UDP是一种尽力而为的数据报服务，报文丢失，顺序错乱等问题要面对。">7.TCP协议是一个面向连接的协议3次握手，保证数据传输的可信赖性。 UDP是一种尽力而为的数据报服务，报文丢失，顺序错乱等问题要面对。</h2><h2 id="8-内网地址_10-/_192-168-/172-（16-31）-–&gt;NAT(网络地址转换)–&gt;连接到外网。多播地址224-239">8.内网地址 10./ 192.168./172.（16-31）.–&gt;NAT(网络地址转换)–&gt;连接到外网。多播地址224-239</h2><h2 id="9-Socket套接字是一种抽象层，应用程序通过它来发送和接收数据。主要的Socket类型为流套接字(Stream_socket)和数据报套接字(datagram_socket)-">9.Socket套接字是一种抽象层，应用程序通过它来发送和接收数据。主要的Socket类型为流套接字(Stream socket)和数据报套接字(datagram socket).</h2><h2 id="10-TCP协议下Client_-_Socket-InputStream/OutputStream_byte[]_;_Server_-_ServerSocket_-_socket">10.TCP协议下Client - Socket-InputStream/OutputStream byte[] ; Server - ServerSocket - socket</h2><h2 id="11-UDP协议_1&gt;在IP协议基础上添加了另一层地址(端口)，2&gt;对数据传输过程中可能产生的错误进行了检测，并抛弃已经损坏的数据。_UDP套接字比TCP的优势：保留边界信息。尽力而为，效率高，节约流量，灵活性，便于扩展。_DatagramSocket和DatagramPacket">11.UDP协议 1&gt;在IP协议基础上添加了另一层地址(端口)，2&gt;对数据传输过程中可能产生的错误进行了检测，并抛弃已经损坏的数据。 UDP套接字比TCP的优势：保留边界信息。尽力而为，效率高，节约流量，灵活性，便于扩展。 DatagramSocket和DatagramPacket</h2><h2 id="12-UDP_DatagramSocket_send()_和_receive()，发送/接收_DatagramPacket-需要设置阻塞时间socket-setSoTimeout，重试次数。失败后重试，一次次递减。">12.UDP DatagramSocket send() 和 receive()，发送/接收 DatagramPacket.需要设置阻塞时间socket.setSoTimeout，重试次数。失败后重试，一次次递减。</h2><h2 id="13-_UDP有长度限制_65535">13. UDP有长度限制 65535</h2><p>一个DatagramPacket实例中所运行传输的最大数据量为65507个字节，即UDP数据报文所能负载的最多数据，因此，使用一个有65600字节左右缓存数组的数据总是安全的。</p>
<h2 id="14-TCP/IP协议的唯一约束是信息必须在块(chunk)中发送和接收数据,而块的长度必须是8的倍数。">14.TCP/IP协议的唯一约束是信息必须在块(chunk)中发送和接收数据,而块的长度必须是8的倍数。</h2><h2 id="15-阻塞-TCP-成帧技术–解决接收端如何定位消息的首尾位置的问题。1&gt;基于定界符（填充技术，用于特殊字符传递问题，缺点是要扫描所有内容）2&gt;显示长度（必须知道消息长度）">15.阻塞-TCP-成帧技术–解决接收端如何定位消息的首尾位置的问题。1&gt;基于定界符（填充技术，用于特殊字符传递问题，缺点是要扫描所有内容）2&gt;显示长度（必须知道消息长度）</h2><h2 id="16-服务器端不能一次只处理一个客户的请求，那也太弱了。_1&gt;一客户一线程-2&gt;线程池_for循环，每个循环中new_Thread">16.服务器端不能一次只处理一个客户的请求，那也太弱了。 1&gt;一客户一线程.2&gt;线程池 for循环，每个循环中new Thread</h2><p>run()方法中 无限循环 while(true){ serverSocket.accept(),传递给Runnable中执行 }.<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(PORT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; threadPoolSize;i++)&#123;</span><br><span class="line">  Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        	<span class="keyword">try</span>&#123;</span><br><span class="line">              Socket clientSocket = serverSocket.accept();</span><br><span class="line">              EchoProtocol.handleEchoClient(clientSocket);<span class="comment">//EchoProtocol实现Runnable接口</span></span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException ex)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3&gt;线程池的优化版本-系统管理调度：Executor接口<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">ServerSocket serverSocket</span> = new ServerSocket(PORT);</span><br><span class="line"><span class="constant">Executor service</span> = Executors.newCachedThreadPool();<span class="comment">//dispatch </span></span><br><span class="line">while(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="constant">	Socket clientSocket</span> = serverSocket.accept();</span><br><span class="line">    <span class="class"><span class="keyword">service</span>.<span class="title">execute</span>(new EchoProtocol(clientSocket));</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="17-多接收者_1&gt;广播broadcast_IPv4的本地广播地址(255-255-255-255),本地广播信息绝不会被路由器转发。2&gt;IPv4中的多播multicast地址范围是224-0-0-0到239-255-255-255">17.多接收者 1&gt;广播broadcast IPv4的本地广播地址(255.255.255.255),本地广播信息绝不会被路由器转发。2&gt;IPv4中的多播multicast地址范围是224.0.0.0到239.255.255.255</h2><h2 id="18-多播MulticastSocket(是DatagramSocket的一个子类)，设置多播数据报文生命周期TTL。MulticastSocket_joinGroup-">18.多播MulticastSocket(是DatagramSocket的一个子类)，设置多播数据报文生命周期TTL。MulticastSocket joinGroup.</h2><h2 id="19-NIO非阻塞状态">19.NIO非阻塞状态</h2><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> clientChannel = <span class="type">SocketChannel</span>.<span class="keyword">open</span><span class="literal">()</span>;</span><br><span class="line">clientChannel.configureBlocking(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h2 id="20-Selector_可以用于避免使用非阻塞式客户端中很浪费资源的忙等。">20.Selector 可以用于避免使用非阻塞式客户端中很浪费资源的忙等。</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Selector</span> <span class="keyword">selector</span> = <span class="keyword">Selector</span>.open();</span><br><span class="line"></span><br><span class="line">ServerSocketChannel channel = ServerSocketChannel.open();</span><br><span class="line">channel.<span class="keyword">register</span>(<span class="keyword">selector</span>,SelectionKey.OP+ACCEPT);<span class="comment">//注册事件</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java TCP/IP Socket编程 读书笔记，一本好书，值得多看几遍<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入剖析Tomcat]]></title>
    <link href="http://zc14.github.io/2016/01/06/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Tomcat/"/>
    <id>http://zc14.github.io/2016/01/06/深入剖析Tomcat/</id>
    <published>2016-01-06T01:20:00.000Z</published>
    <updated>2016-01-16T14:12:01.401Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
<pre><code>Tomcat源码阅读文献
</code></pre><h2 id="A-一个简单的Web服务器–构建Web服务">A.一个简单的Web服务器–构建Web服务</h2><h3 id="1-HTTP协议">1.HTTP协议</h3><ol>
<li><p>请求<br><strong>请求方法  统一资源标识符URI  协议/版本</strong><br><strong>请求头</strong><br><strong>空行</strong><br><strong>实体</strong><br>[Demo]</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST <span class="regexp">/Platfform/</span>login.jsp HTTP/<span class="number">1.1</span></span><br><span class="line"><span class="string">Accept:</span> text<span class="regexp">/plain;text/</span>html</span><br><span class="line">Accept-<span class="string">Language:</span> en-gb</span><br><span class="line"><span class="string">Connection:</span> Keep-Alive</span><br><span class="line"><span class="string">Host:</span> localhost</span><br><span class="line">      </span><br><span class="line">username=jack&amp;password=<span class="number">1234</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>相应<br><strong>协议/版本  状态码  描述</strong><br><strong>响应头</strong><br><strong>空行</strong><br><strong>响应实体段</strong><br>[Demo]</p>
 <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Server: Microsoft-IIS/<span class="number">4.0</span></span><br><span class="line">Date:M<span class="keyword">on</span>,<span class="number">6</span> Jan <span class="number">2015</span></span><br><span class="line">Content-Type:text/html</span><br><span class="line">Content-Length:<span class="number">85</span></span><br><span class="line">       </span><br><span class="line"><span class="variable">&lt;html&gt;</span></span><br><span class="line">  <span class="variable">&lt;head&gt;</span></span><br><span class="line">     <span class="variable">&lt;title&gt;</span>hello world<span class="variable">&lt;/title&gt;</span></span><br><span class="line">  <span class="variable">&lt;/head&gt;</span></span><br><span class="line">  <span class="variable">&lt;body&gt;</span>Welcome <span class="keyword">to</span> Tomcat World<span class="variable">&lt;/body&gt;</span></span><br><span class="line"><span class="variable">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-Socket类_和_ServerSocket类">2.Socket类 和 ServerSocket类</h3><h3 id="3-构建应用程序">3.构建应用程序</h3><p>1.HttpServer接收请求(ServerSocket)<br>2.创建Socket对象(ServerSocket.accept())<br>3.创建输入输出流InputStream/OutputStream(socket.getInputStream()/socket.getOutputStream())<br>4.创建Request/Response对象<br>5.Request对象负责截取URI(自定义parse方法-用到indexOf()和substring)，传递给Response。<br>6.Response响应，构建HTTP相应格式信息，OutputStream给客户端。</p>
</li>
</ol>
<h2 id="B-一个简单的servlet容器–用于解析servlet">B.一个简单的servlet容器–用于解析servlet</h2><h3 id="servet编程要使用javax-servlet和javax-servlet-http两个接口下的类">servet编程要使用javax.servlet和javax.servlet.http两个接口下的类</h3><p><strong>URLClassLoader是ClassLoader的子类，它用于从指向 JAR 文件和目录的 URL 的搜索路径加载类和资源。也就是说，通过URLClassLoader就可以加载指定jar中的class到内存中。</strong></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(jar文件全路径);</span><br><span class="line">URL url = <span class="keyword">file</span>.toURI().toURL();</span><br><span class="line">URLClassLoader loader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[] &#123; url &#125;);</span><br><span class="line"><span class="keyword">Class</span> tidyClazz = loader.loadClass(所需<span class="keyword">class</span>的含包名的全名);</span><br></pre></td></tr></table></figure>
<h3 id="应用程序">应用程序</h3><p>   HttpServer—入口，ServletSocket–Socket–Input/Output<br>   Request—&gt;implements ServletRequest请求<br>   Response—&gt;implements ServletResponse响应–PrintWriter<br>   StaticResourceProcessor—静态html资源文件解析<br>   ServletProcessor—servlet类解析<br>   Cnstants—常量类</p>
]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>
<pre><code>Tomcat源码阅读文献
</code></pre><h2 id="A-一个简单的Web服务器–构建Web服务">A.一个简单的Web服务器–构建Web服务</h2><h3 id="1-HTTP协议">1.HTTP协议</]]>
    </summary>
    
      <category term="Tomcat" scheme="http://zc14.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java并发编程的艺术]]></title>
    <link href="http://zc14.github.io/2015/12/27/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <id>http://zc14.github.io/2015/12/27/Java并发编程的艺术/</id>
    <published>2015-12-27T03:27:03.000Z</published>
    <updated>2015-12-27T07:25:30.415Z</updated>
    <content type="html"><![CDATA[<p>Java并发编程的艺术读书笔记<br><a id="more"></a></p>
<h2 id="数据库连接池">数据库连接池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个简单的数据库连接池示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> LinkedList&lt;Connection&gt; pool = <span class="keyword">new</span> LinkedList&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> initialSize)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (initialSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initialSize; i++) &#123;</span><br><span class="line">				pool.addLast(ConnectionDriver.createConnection());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">				<span class="comment">// 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接</span></span><br><span class="line">				pool.addLast(connection);</span><br><span class="line">				pool.notifyAll();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在mills内无法获取到连接，将会返回null</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Connection <span class="title">fetchConnection</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">			<span class="comment">// 完全超时</span></span><br><span class="line">			<span class="keyword">if</span> (mills &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">while</span> (pool.isEmpty()) &#123;</span><br><span class="line">					pool.wait();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> pool.removeFirst();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line">				<span class="keyword">long</span> remaining = mills;</span><br><span class="line">				<span class="keyword">while</span> (pool.isEmpty() &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					pool.wait(remaining);</span><br><span class="line">					remaining = future - System.currentTimeMillis();</span><br><span class="line">				&#125;</span><br><span class="line">				Connection result = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">if</span> (!pool.isEmpty()) &#123;</span><br><span class="line">					result = pool.removeFirst();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实的实现应该是由数据库驱动提供方法来实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionDriver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">				<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (method.getName().equals(<span class="string">"commit"</span>)) &#123;</span><br><span class="line">				TimeUnit.MICROSECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个Connection的代理，在commit时休眠100毫秒</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Connection <span class="title">createConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (Connection) Proxy.newProxyInstance(</span><br><span class="line">				ConnectionDriver.class.getClassLoader(),</span><br><span class="line">				<span class="keyword">new</span> Class&lt;?&gt;[] &#123; Connection.class &#125;, <span class="keyword">new</span> ConnectionHandler());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPoolTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> ConnectionPool pool = <span class="keyword">new</span> ConnectionPool(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">// 保证所有ConnectionRunner能够同时开始</span></span><br><span class="line">	<span class="keyword">static</span> CountDownLatch start = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// main线程将会等待所有的ConnectionRunner结束后才能继续执行</span></span><br><span class="line">	<span class="keyword">static</span> CountDownLatch end;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 线程数量，可以修改线程数量进行观察</span></span><br><span class="line">		<span class="keyword">int</span> threadCount = <span class="number">5000</span>;</span><br><span class="line">		end = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line">		AtomicInteger got = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">		AtomicInteger notGot = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">			Thread thread = <span class="keyword">new</span> Thread(</span><br><span class="line">					<span class="keyword">new</span> ConnectionRunner(count, got, notGot),</span><br><span class="line">					<span class="string">"ConnectionRunnerThread"</span>);</span><br><span class="line">			thread.start();</span><br><span class="line">		&#125;</span><br><span class="line">		start.countDown();</span><br><span class="line">		end.await();</span><br><span class="line">		System.out.println(<span class="string">"total invoke: "</span> + (threadCount * count));</span><br><span class="line">		System.out.println(<span class="string">"got connection: "</span> + got);</span><br><span class="line">		System.out.println(<span class="string">"not got connection: "</span> + notGot);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> count;</span><br><span class="line">		AtomicInteger got;</span><br><span class="line">		AtomicInteger notGot;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">ConnectionRunner</span><span class="params">(<span class="keyword">int</span> count, AtomicInteger got,</span><br><span class="line">				AtomicInteger notGot)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.count = count;</span><br><span class="line">			<span class="keyword">this</span>.got = got;</span><br><span class="line">			<span class="keyword">this</span>.notGot = notGot;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				start.await();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="comment">// 从线程池中获取连接，如果1000ms内无法获取到，将会返回null</span></span><br><span class="line">					<span class="comment">// 分别统计连接获取的数量got和未获取到连接的数量notGot</span></span><br><span class="line">					Connection connection = pool.fetchConnection(<span class="number">1000</span>);</span><br><span class="line">					<span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							connection.createStatement();</span><br><span class="line">							connection.commit();</span><br><span class="line">						&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">							pool.releaseConnection(connection);</span><br><span class="line">							got.incrementAndGet();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						notGot.incrementAndGet();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">				&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">					count--;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			end.countDown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程池">线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程池技术</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行一个Job，这个Job需要实现Runnable</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭线程池</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 增加工作者线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 减少工作者线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 得到正在等待执行的任务数量</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; <span class="keyword">implements</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//线程池最大限制数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_WORKER_NUMBERS  = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//线程池默认的数量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WORKER_NUMBERS = <span class="number">5</span>;</span><br><span class="line">	<span class="comment">//线程池最小的数量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_WORKER_NUMBERS = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//这是一个工作列表，将会向里面插入工作</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Job&gt; jobs = <span class="keyword">new</span> LinkedList&lt;Job&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//工作者列表</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;Worker&gt; workers = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Worker&gt;());</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//工作者线程的数量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//线程编号生成</span></span><br><span class="line">	<span class="keyword">private</span> AtomicLong threadNum = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		initializeWorkers(DEFAULT_WORKER_NUMBERS);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">		workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS : num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num;</span><br><span class="line">		initializeWorkers(workerNum);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(job != <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//添加一个工作，然后进行通知</span></span><br><span class="line">			<span class="keyword">synchronized</span>(jobs)&#123;</span><br><span class="line">				jobs.addLast(job);</span><br><span class="line">				jobs.notify();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Worker worker: workers)&#123;</span><br><span class="line">			worker.shutdown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(jobs)&#123;</span><br><span class="line">			<span class="comment">//限制新增的Worker数量不能超过最大值</span></span><br><span class="line">			<span class="keyword">if</span>( num + <span class="keyword">this</span>.workerNum &gt; MAX_WORKER_NUMBERS)&#123;</span><br><span class="line">				num = MAX_WORKER_NUMBERS - <span class="keyword">this</span>.workerNum;</span><br><span class="line">			&#125;</span><br><span class="line">			initializeWorkers(num);</span><br><span class="line">			<span class="keyword">this</span>.workerNum += num;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(jobs)&#123;</span><br><span class="line">			<span class="keyword">if</span>(num &gt;= <span class="keyword">this</span>.workerNum)&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"beyond workNum"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//按照给定的数量停止Worker</span></span><br><span class="line">			<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(count &lt; num)&#123;</span><br><span class="line">				Worker worker = workers.get(count);</span><br><span class="line">				<span class="keyword">if</span>(workers.remove(worker))&#123;</span><br><span class="line">					worker.shutdown();</span><br><span class="line">					count++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.workerNum -= count;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> jobs.size();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化线程工作者</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWorkers</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num;i++)&#123;</span><br><span class="line">			Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">			workers.add(worker);</span><br><span class="line">			Thread thread = <span class="keyword">new</span> Thread(worker,<span class="string">"ThreadPool-Worker-"</span>+threadNum.incrementAndGet());</span><br><span class="line">			thread.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//工作者，负责消费任务</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="comment">//是否工作</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(running)&#123;</span><br><span class="line">				Job job = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">synchronized</span>(jobs)&#123;</span><br><span class="line">					<span class="comment">//如果工作者列表是空的，那么就wait</span></span><br><span class="line">					<span class="keyword">while</span>(jobs.isEmpty())&#123;</span><br><span class="line">						<span class="keyword">try</span>&#123;</span><br><span class="line">							jobs.wait();</span><br><span class="line">						&#125;<span class="keyword">catch</span>(InterruptedException ex)&#123;</span><br><span class="line">							<span class="comment">//感知到外部对WorkerThread的中断操作，返回</span></span><br><span class="line">							Thread.currentThread().interrupt();</span><br><span class="line">							<span class="keyword">return</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">//取出一个Job</span></span><br><span class="line">					job = jobs.removeFirst();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(job != <span class="keyword">null</span>)&#123;</span><br><span class="line">					<span class="keyword">try</span>&#123;</span><br><span class="line">						job.run();</span><br><span class="line">					&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">						<span class="comment">//忽略job执行中的Exception</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">			running = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个基于线程池技术的简单Web服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理HttpRequest的线程池</span></span><br><span class="line">	<span class="keyword">static</span> ThreadPool&lt;HttpRequestHandler&gt; threadPool = <span class="keyword">new</span> DefaultThreadPool&lt;HttpRequestHandler&gt;(</span><br><span class="line">			<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// SimpleHttpServer的根路径</span></span><br><span class="line">	<span class="keyword">static</span> String basePath;</span><br><span class="line">	<span class="keyword">static</span> ServerSocket serverSocket;</span><br><span class="line">	<span class="comment">// 服务监听端口</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (port &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			SimpleHttpServer.port = port;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBasePath</span><span class="params">(String basePath)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (basePath != <span class="keyword">null</span> &amp;&amp; <span class="keyword">new</span> File(basePath).exists()</span><br><span class="line">				&amp;&amp; <span class="keyword">new</span> File(basePath).isDirectory()) &#123;</span><br><span class="line">			SimpleHttpServer.basePath = basePath;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动SimpleHttpServer</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">		Socket socket = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 接收一个客户端Socket，生成一个HttpRequestHandler，放入线程池执行</span></span><br><span class="line">			threadPool.execute(<span class="keyword">new</span> HttpRequestHandler(socket));</span><br><span class="line">		&#125;</span><br><span class="line">		serverSocket.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequestHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">HttpRequestHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.socket = socket;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			String line = <span class="keyword">null</span>;</span><br><span class="line">			BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">			BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">			PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">			InputStream in = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(</span><br><span class="line">						socket.getInputStream()));</span><br><span class="line">				String header = reader.readLine();</span><br><span class="line">				<span class="comment">// 由相对路径计算出绝对路径</span></span><br><span class="line">				String filePath = basePath + header.split(<span class="string">" "</span>)[<span class="number">1</span>];</span><br><span class="line">				out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">				<span class="comment">// 如果请求资源的后缀为jpg或者ico，则读取资源并输出</span></span><br><span class="line">				<span class="keyword">if</span> (filePath.endsWith(<span class="string">"jpg"</span>) || filePath.endsWith(<span class="string">"ico"</span>)) &#123;</span><br><span class="line">					in = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">					ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">					<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">						baos.write(i);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">byte</span>[] array = baos.toByteArray();</span><br><span class="line">					out.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">					out.println(<span class="string">"Content-Type: image/jpeg"</span>);</span><br><span class="line">					out.println(<span class="string">"Content-Length: "</span> + array.length);</span><br><span class="line">					out.println(<span class="string">""</span>);</span><br><span class="line">					socket.getOutputStream().write(array, <span class="number">0</span>, array.length);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(</span><br><span class="line">							<span class="keyword">new</span> FileInputStream(filePath)));</span><br><span class="line">					out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">					out.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">					out.println(<span class="string">"Content-Type: text/html; charset=UTF-8"</span>);</span><br><span class="line">					out.println(<span class="string">""</span>);</span><br><span class="line">					<span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">						out.println(line);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				out.flush();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">				out.println(<span class="string">"HTTP/1.1 500"</span>);</span><br><span class="line">				out.println(<span class="string">""</span>);</span><br><span class="line">				out.flush();</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				close(br, in, reader, out, socket);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭流或者Socket</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... closeables)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (closeables != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Closeable closeable : closeables) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					closeable.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">					<span class="comment">// 忽略</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于线程池实现的简单web服务器">基于线程池实现的简单web服务器</h2><h2 id="Java中的锁_Lock/Condition">Java中的锁 Lock/Condition</h2><h2 id="Java_并发容器和框架">Java 并发容器和框架</h2><h3 id="ConcurrentHashMap">ConcurrentHashMap</h3><p>   ConcurrentHashMap - 多个segment组成。采用了可重入锁ReentrantLock HashEntry。<br>   为了提高效率，ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。</p>
<h3 id="COncurrentLinkedQueue">COncurrentLinkedQueue</h3><p>   线程安全的队列。两种实现方式：1使用阻塞算法（锁）。2使用非阻塞算法（CAS）。</p>
<h3 id="Java中的阻塞队列">Java中的阻塞队列</h3><p>   ArrayBlockingQueue<br>   …</p>
<h3 id="Fork/Join框架">Fork/Join框架</h3><pre><code>工作窃取算法 <span class="literal">A</span>线程执行完自己的任务，从队列尾部窃取B线程中未执行的任务。
</code></pre><h2 id="Java中的并发工具类">Java中的并发工具类</h2><h3 id="等待多线程完成的CountDownLatch">等待多线程完成的CountDownLatch</h3><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch c = new CountDownLatch()<span class="comment">;</span></span><br><span class="line">c.countDown()<span class="comment">;</span></span><br><span class="line">c.await()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<pre><code>迅雷下载。
</code></pre><h3 id="同步屏障CyclicBarrier">同步屏障CyclicBarrier</h3><pre><code>张孝祥老师的例子-团队建设。去游玩。 集合-到达目的地-吃午饭-继续逛-集合-回家。等到最后一个满足条件，才去执行下一步。
</code></pre><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//银行流水处理服务类</span><br><span class="line">public class <span class="type">BankWaterService</span> implements <span class="type">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">	// 创建<span class="number">4</span>个屏障，处理完之后执行当前类的run方法</span><br><span class="line">	private <span class="type">CyclicBarrier</span> c = new <span class="type">CyclicBarrier</span>(<span class="number">4</span>, this);</span><br><span class="line"></span><br><span class="line">	// 假设只有<span class="number">4</span>个sheet，所以启动<span class="number">4</span>个线程</span><br><span class="line">	private <span class="type">Executor</span> executor = <span class="type">Executors</span>.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	// 保存每个sheet计算出来的银行流水结果</span><br><span class="line">	private <span class="type">ConcurrentHashMap</span>&lt;<span class="type">String</span>, <span class="type">Integer</span>&gt; sheetBankWaterCount = new <span class="type">ConcurrentHashMap</span>&lt;<span class="type">String</span>, <span class="type">Integer</span>&gt;();</span><br><span class="line"></span><br><span class="line">	private <span class="type">void</span> count() &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">			executor.execute(new <span class="type">Runnable</span>() &#123;</span><br><span class="line">				@<span class="type">Override</span></span><br><span class="line">				public <span class="type">void</span> run() &#123;</span><br><span class="line">					// 计算当前sheet的银行流水数据，计算代码省略</span><br><span class="line">					sheetBankWaterCount</span><br><span class="line">							.put(<span class="type">Thread</span>.currentThread().getName(), <span class="number">1</span>);</span><br><span class="line">					// 银行流水计算完成，插入一个屏障</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						c.await();</span><br><span class="line">					&#125; catch (<span class="type">InterruptedException</span> | <span class="type">BrokenBarrierException</span> e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@<span class="type">Override</span></span><br><span class="line">	public <span class="type">void</span> run() &#123;</span><br><span class="line">		<span class="type">int</span> <span class="literal">result</span> = <span class="number">0</span>;</span><br><span class="line">		// 汇总每个sheet计算出的结果</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">Entry</span>&lt;<span class="type">String</span>, <span class="type">Integer</span>&gt; sheet : sheetBankWaterCount.entrySet()) &#123;</span><br><span class="line">			<span class="literal">result</span> += sheet.getValue();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 将计算结果输出</span><br><span class="line">		sheetBankWaterCount.put(<span class="string">"result"</span>, <span class="literal">result</span>);</span><br><span class="line">		<span class="type">System</span>.<span class="keyword">out</span>.println(<span class="literal">result</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">		<span class="type">BankWaterService</span> bankWaterCount = new <span class="type">BankWaterService</span>();</span><br><span class="line">		bankWaterCount.count();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="控制并发线程数的Semaphore">控制并发线程数的Semaphore</h3><pre><code>银行排队。
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> SemaphoreTest &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">			threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				@<span class="function">Override</span><br><span class="line">				<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						s.acquire();</span><br><span class="line">						Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">						System.out.println(<span class="string">"save data"</span>);</span><br><span class="line">						s.release();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		threadPool.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程间交换数据的Exchanger">线程间交换数据的Exchanger</h3><p>张孝祥老师的例子- 模拟毒品交易</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; exgr       = <span class="keyword">new</span> Exchanger&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService         threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String A = <span class="string">"银行流水A"</span>;<span class="comment">// A录入银行流水数据</span></span><br><span class="line">                    exgr.exchange(A);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String B = <span class="string">"银行流水B"</span>;<span class="comment">// B录入银行流水数据</span></span><br><span class="line">                    String A = exgr.exchange(<span class="string">"B"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span> + A + <span class="string">"，B录入是："</span> + B);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java中的线程池">Java中的线程池</h2><pre><code>ThreadPoolExrcutor
</code></pre><h2 id="Executor框架">Executor框架</h2><p>   FutureTask<br>   ThreadPoolExrcutor<br>   ScheduledThreadPoolExecutor</p>
<h2 id="Java并发编程实战">Java并发编程实战</h2><p>   生产者或消费者模式<br>   <strong>通过一个容器来解决生产者和消费者的强耦合，生产者和消费者不直接通信，通过一个阻塞队列来平衡二者。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[并发编程]]>
    
    </summary>
    
      <category term="并发编程" scheme="http://zc14.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[异常]]></title>
    <link href="http://zc14.github.io/2015/12/23/%E5%BC%82%E5%B8%B8/"/>
    <id>http://zc14.github.io/2015/12/23/异常/</id>
    <published>2015-12-23T05:20:46.000Z</published>
    <updated>2015-12-27T07:26:33.428Z</updated>
    <content type="html"><![CDATA[<p>哪条语句执行，哪条不执行，看仔细了<br><a id="more"></a><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class ExceptionsTest &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">String</span> input = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">String</span> capitalized = capitalize(input);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"$$$$"</span>+capitalized);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"~~~~"</span>+e.toString());</span><br><span class="line">			<span class="comment">//throw new RuntimeException("goodbye");</span></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.<span class="built_in">println</span>(capitalize(<span class="string">"name"</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> capitalize(<span class="keyword">String</span> s) <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == s) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Your passed a null argument"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Character firstChar = s.charAt(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">String</span> theRest = s.substring(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> firstChar.toString().toUpperCase() + theRest;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><em><br>~~~~java.lang.NullPointerException: Your passed a null argument<br>Name
</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>哪条语句执行，哪条不执行，看仔细了<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[初始化加载顺序]]></title>
    <link href="http://zc14.github.io/2015/12/23/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
    <id>http://zc14.github.io/2015/12/23/初始化加载顺序/</id>
    <published>2015-12-23T02:00:40.000Z</published>
    <updated>2015-12-27T07:28:14.220Z</updated>
    <content type="html"><![CDATA[<p>普通代码块，静态代码块执行顺序，次数<br><a id="more"></a><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InitTest03</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InitTest03</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		init();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InitTest03</span>(<span class="params"><span class="keyword">int</span> x</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.x = x;</span><br><span class="line">		init();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		y = x * <span class="number">2</span>;</span><br><span class="line">		System.<span class="keyword">out</span>.println(y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"static initialization"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		y = x * <span class="number">4</span>;</span><br><span class="line">		System.<span class="keyword">out</span>.println(y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">		InitTest03 test = <span class="keyword">new</span> InitTest03();</span><br><span class="line">		InitTest03 moreTest = <span class="keyword">new</span> InitTest03();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>static initialization<br>12<br>6<br>12<br>6
</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>普通代码块，静态代码块执行顺序，次数<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[回调函数]]></title>
    <link href="http://zc14.github.io/2015/12/22/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <id>http://zc14.github.io/2015/12/22/回调函数/</id>
    <published>2015-12-22T07:35:36.000Z</published>
    <updated>2015-12-27T07:23:23.310Z</updated>
    <content type="html"><![CDATA[<p>学习模板方法的时候发现的。<br>java中的回调函数，是通过匿名内部类来实现的。<br>Spring也是这么用的，好好学习下。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">handler</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJdbcQueryTemplate</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(String sql,ResultHandler&lt;T&gt; <span class="keyword">handler</span>)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="keyword">handler</span>.<span class="title">handler</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">Test</span>&#123;</span><br><span class="line">  public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="literal">result</span> = new <span class="type">SimpleJdbcQueryTemplate</span>().query(</span><br><span class="line">      new <span class="type">ResultHandler</span>&lt;<span class="type">Boolean</span>&gt;()&#123;</span><br><span class="line">        public <span class="type">String</span> query()&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"一个小小的测试。"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="literal">result</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>学习模板方法的时候发现的。<br>java中的回调函数，是通过匿名内部类来实现的。<br>Spring也是这么用的，好好学习下。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java解惑]]></title>
    <link href="http://zc14.github.io/2015/12/20/Java%E8%A7%A3%E6%83%91/"/>
    <id>http://zc14.github.io/2015/12/20/Java解惑/</id>
    <published>2015-12-20T06:52:24.000Z</published>
    <updated>2015-12-27T07:31:11.368Z</updated>
    <content type="html"><![CDATA[<p>一些小小注意点<br><a id="more"></a></p>
<h1 id="表达式之谜">表达式之谜</h1><h2 id="谜题1_奇偶性">谜题1 奇偶性</h2><pre><code>i%<span class="number">2</span> == <span class="number">0</span> 
优化 (i &amp; <span class="number">1</span>) == <span class="number">0</span>
</code></pre><h2 id="谜题2_找零时刻">谜题2 找零时刻</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">2.00</span> - <span class="number">1.10</span>);</span><br><span class="line"><span class="comment">//输出结果：0.8999999999999999</span></span><br></pre></td></tr></table></figure>
<p>原因:<strong>并不是所有的小数都可以用二进制浮点数精确表示。在需要精确答案的地方，要避免使用float和double;对于货币计算，要使用int，long或BigDecimal。</strong><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> System.out.<span class="built_in">println</span>(<span class="keyword">new</span> BigDecimal(<span class="number">.1</span>));</span><br><span class="line"> <span class="comment">//输出结果：0.1000000000000000055511151231257827021181583404541015625</span></span><br><span class="line"></span><br><span class="line"> 一定要用BigDecimal(<span class="keyword">String</span>)构造器，而千万不要用BigDecimal(<span class="keyword">double</span>)</span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="keyword">new</span> BigDecimal(<span class="string">"2.00"</span>).subtract(<span class="keyword">new</span> BigDecimal(<span class="string">"1.10"</span>)));</span><br><span class="line"><span class="comment">//输出结果：0.90</span></span><br></pre></td></tr></table></figure></p>
<h2 id="谜题3_长整除">谜题3 长整除</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final <span class="keyword">long</span> MICROS_PER_DAY = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line">       final <span class="keyword">long</span> MILLIS_PER_DAY = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">       System.out.println(MICROS_PER_DAY / MILLIS_PER_DAY);</span><br><span class="line"><span class="comment">//输出结果：5，而不是预期的1000</span></span><br></pre></td></tr></table></figure>
<p><strong>当你要操作很大的数字时，千万要提防溢出—-它可是一个缄默的杀手</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final <span class="keyword">long</span> MICROS_PER_DAY = <span class="number">24L</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line">       final <span class="keyword">long</span> MILLIS_PER_DAY = <span class="number">24L</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">       System.out.println(MICROS_PER_DAY / MILLIS_PER_DAY);</span><br><span class="line"><span class="comment">//输出结果：1000</span></span><br></pre></td></tr></table></figure></p>
<h2 id="谜题4_初级问题">谜题4 初级问题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">12345</span> + <span class="number">5432l</span>);</span><br><span class="line"><span class="comment">//输出结果：17777</span></span><br></pre></td></tr></table></figure>
<p><strong>在long类型字面常量中，一定要用大写的L，千万不要用小写的l</strong></p>
<h2 id="谜题5_十六进制的趣事">谜题5 十六进制的趣事</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">Long</span><span class="class">.toHexString</span>(0<span class="tag">x100000000L</span> + 0<span class="tag">xcafebabe</span>));</span><br></pre></td></tr></table></figure>
<p><strong>如果十六进制和八进制字面常量的最高位被置位了，那么他们就是负数。通常最好是避免混合类型的计算。</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">Long</span><span class="class">.toHexString</span>(0<span class="tag">x100000000L</span> + 0<span class="tag">xcafebabeL</span>));</span><br></pre></td></tr></table></figure>
<h2 id="谜题6_多重转型">谜题6 多重转型</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.<span class="keyword">out</span>.println((<span class="keyword">int</span>) (<span class="keyword">char</span>) (<span class="keyword">byte</span>) -<span class="number">1</span>);</span><br><span class="line"><span class="comment">//输出结果： 65535  32-&gt;8-&gt;16-&gt;32</span></span><br><span class="line">不能用一个<span class="keyword">char</span>表示一个负的<span class="keyword">byte</span>数值。</span><br></pre></td></tr></table></figure>
<p><strong>如果最初的数值类型是有符号的，就执行符号扩展；如果它是char，那么不管它将要被转换成什么类型，都执行零扩展。</strong></p>
<h2 id="谜题7_互换内容">谜题7 互换内容</h2><p>不重要</p>
<h2 id="谜题8_Dos_Equais">谜题8 Dos Equais</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">char</span> x = <span class="string">'X'</span>;</span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> System.out.print(<span class="literal">true</span>  ? x : <span class="number">0</span>);</span><br><span class="line"> System.out.print(<span class="literal">false</span> ? i : x); </span><br><span class="line">输出结果：X88</span><br></pre></td></tr></table></figure>
<p><strong>如果一个操作数的类型是T，T表示byte，short或char，而另一个操作类型是int。他的值可以用类型T表示，那么三目运算符的类型就是T。</strong></p>
<h2 id="谜题9_半斤">谜题9 半斤</h2><h2 id="谜题10_八两">谜题10 八两</h2><h2 id="谜题11_最后的笑声">谜题11 最后的笑声</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LastLaugh</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"H"</span> + <span class="string">"a"</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">'H'</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">'H'</span> + <span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Ha</span><br><span class="line">H</span><br><span class="line"><span class="number">169</span></span><br></pre></td></tr></table></figure>
<p><strong>当且仅当+操作符的操作数中至少有一个是String类型时，才会执行字符串连接操作</strong></p>
<h2 id="谜题12_ABC">谜题12 ABC</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Abc</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        String letters = <span class="string">"ABC"</span>;</span><br><span class="line">        <span class="keyword">char</span>[] numbers = &#123; <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span> &#125;;</span><br><span class="line">        System.<span class="keyword">out</span>.println(letters + <span class="string">" easy as "</span> + numbers);</span><br><span class="line">	System.<span class="keyword">out</span>.println(letters + <span class="string">" easy as "</span> + String.valueOf(numbers));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">ABC easy <span class="keyword">as</span> [C@<span class="number">659e0</span>bfd</span><br><span class="line">ABC easy <span class="keyword">as</span> <span class="number">123</span></span><br></pre></td></tr></table></figure>
<p><strong>char数组不是字符串。要想将一个char数组转换成一个字符串，就要调用String.valueof(char[])方法</strong></p>
<h2 id="谜题13_动物庄园">谜题13 动物庄园</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class AnimalFarm &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">String</span> len = <span class="string">"10"</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">String</span> pig = <span class="string">"length: 10"</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">String</span> dog = <span class="string">"length: "</span> + pig.length();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">String</span> monkey = <span class="string">"length: "</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">String</span> duck = <span class="string">"length: "</span> + len;</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Animals are equal: "</span> + pig == dog);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Animals are equal: "</span> + (pig == dog));</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Animals are equal: "</span> + (pig == monkey));</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Animals are equal: "</span> + (pig == duck));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">Animals are equal: <span class="keyword">false</span></span><br><span class="line">Animals are equal: <span class="keyword">true</span></span><br><span class="line">Animals are equal: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p><strong>在使用字符串连接操作符时，总是将重要的操作数用括号括起来。</strong></p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">``</span>`</span><br></pre></td></tr></table></figure>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">``</span>`</span><br></pre></td></tr></table></figure>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">``</span>`</span><br></pre></td></tr></table></figure>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">``</span>`</span><br></pre></td></tr></table></figure>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">``</span>`</span><br></pre></td></tr></table></figure>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">``</span>`</span><br></pre></td></tr></table></figure>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">``</span>`</span><br></pre></td></tr></table></figure>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">``</span>`</span><br></pre></td></tr></table></figure>
<pre><code>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>一些小小注意点<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[金典-概念与算法]]></title>
    <link href="http://zc14.github.io/2015/12/15/%E9%87%91%E5%85%B8-%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://zc14.github.io/2015/12/15/金典-概念与算法/</id>
    <published>2015-12-15T05:09:03.000Z</published>
    <updated>2015-12-16T07:53:00.211Z</updated>
    <content type="html"><![CDATA[<h1 id="概念与算法">概念与算法</h1><h2 id="位操作">位操作</h2><ol>
<li>手工位运算<br>1000 - 0110  （0010）<br>1011 &amp; (~0 &lt;&lt; 2) （1000）</li>
<li><p>位操作原理与技巧<br>|”^”操作|”&amp;”操作|<br>|:—-:|:—-:|<br>|x^0 = x|x&amp;0 = 0|<br>|x^1 = ~x|x&amp;1 = x|<br>|x^x = 0|x&amp;x = x|</p>
</li>
<li><p>常见位操作：获取，设置，清除及更新位数据</p>
<ul>
<li><p>获取</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">getBit</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((num &amp; (<span class="number">1</span> &lt;&lt; i)) !=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <em>该方法将1左移i位，得到形如00010000的值。接着，对这个值与num执行“位与”操作，从而将i位之外的所有位清零。<br>最后，检查该结果是否为零。不为零说明i位为1，否则，i位为0.</em></p>
</li>
<li><p>置位</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setBit</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>该方法先将1左移i位，得到形如00010000的值。接着，对这个值和num执行“位或”操作，这样只会改变i位的数据。<br>改掩码i位除外的位均为零，故而不会影响num的其余位。</em></p>
</li>
<li><p>清零</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clearBit</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mask = ~(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">  <span class="keyword">return</span> num &amp; mask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将num最高位至i位(含)清零的做法如下：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clearBitsMSBthroughtI</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mask = (<span class="number">1</span> &lt;&lt; i) -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> num &amp; mask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将i位至0位(含)清零的做法如下：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clearBitsIthrought0</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mask = ~((<span class="number">1</span> &lt;&lt; (i+<span class="number">1</span>)) -<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> num &amp; mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>该方法与setBit刚好相反。首先，将1左移i位得到形如00010000的值，对这个值取反进而得到类似11101111的掩码。<br>接着，对该掩码和num执行“位与”操作。这样只会清零num的i位，其余位保持不变。</em></p>
</li>
<li>更新<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateBit</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> i,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mask = ~(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">  <span class="keyword">return</span> ( num &amp; mask) | (v &lt;&lt; i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><em>此方法将setBit与clearBit合二为一。首先，用诸如11101111的掩码将num的第i位清零。<br>接着，将待写入值v左移i位，得到一个i位为v但其余位都为0的数。最后，对之前得到的两个结果执行“位或”操作，<br>v为1则将num的i位更新为1，否则该位仍为0.
</em></p>
</li>
</ol>
<h2 id="智力题">智力题</h2><ol>
<li>大声说出你的思路</li>
<li><p>总结规律与模式<br><em>给定两条绳子，每条绳子燃烧殆尽正好要用1个小时。怎样用这两条绳子准确计量15分钟？</em></p>
</li>
<li><p>略作变通</p>
</li>
<li>触类旁通</li>
</ol>
<h2 id="数学与概率">数学与概率</h2><ol>
<li><p>素数<br>每一个数都可以分解成素数乘积。<br><em>84 = 2的2次方 x 3的1次方 x 5的0次方 x 7的1次方 x 11的0次方 x 13的0次方 x 17的0次方…..</em></p>
<ul>
<li><p>素数检查</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">primeSlighrlyBetter</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> <span class="built_in">sqrt</span> = (<span class="keyword">int</span>) Math.<span class="built_in">sqrt</span>(n);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;=<span class="built_in">sqrt</span>;i++)&#123;</span><br><span class="line">   <span class="keyword">if</span>( n %i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成素数序列：埃拉托斯特腻筛法<br>能非常高效地生成素数序列，原理是剔除所有可被素数整除的非素数。<br>原理：一开始列出到max为止的所有数字。首先，划掉所有可被2整除的数(2保留)。<br>然后，找到下一个素数(也即下一个不会被划掉的数)，并划掉所有可被它整除的数。划掉所有可被2，3，5，7，11等素数整除的数，最终课得到2到max之间的素数序列。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[] sieveOfEratosthenes(<span class="keyword">int</span> max)&#123;</span><br><span class="line">  <span class="keyword">boolean</span>[] flags = <span class="keyword">new</span> <span class="keyword">boolean</span>[max +<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  init(flags);<span class="comment">//将flags中0，1元素除外的所有元素设为true</span></span><br><span class="line">  <span class="keyword">int</span> prime = <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(prime &lt;= max)&#123;</span><br><span class="line">   <span class="comment">/*划掉余下为prime倍数的数字*/</span></span><br><span class="line">   crossOff(flags,prime);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/*找出下一个为true的值*/</span></span><br><span class="line">   prime = getNextPrime(flags,prime);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>(prime &gt;= flags.length)&#123;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> crossOff(<span class="keyword">boolean</span>[] flags,<span class="keyword">int</span> prime)&#123;</span><br><span class="line"> <span class="comment">/*划掉余下为prime倍数的数字，我们可以从(prime*prime)开始，因为如果k*prime且k &lt; prime,这个值早就在之前的迭代里被划掉了。*/</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = prime * prime;i &lt; flags.length;i +=prime)&#123;</span><br><span class="line">   flags[i] = <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> getNextPrime(<span class="keyword">boolean</span>[] flags,<span class="keyword">int</span> prime)&#123;</span><br><span class="line"> <span class="keyword">int</span> <span class="keyword">next</span> = prime +<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span>(<span class="keyword">next</span> &lt; flags.length &amp;&amp; !flags[<span class="keyword">next</span>])&#123;</span><br><span class="line">   <span class="keyword">next</span>++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>概率</p>
<ul>
<li>A与B都发生的概率<br>P(A与B都发生) = P(B发生，在A发生的情况下) <em> P(A发生)
</em>假设要在1到10之间挑选一个数。挑中一个偶数且这个数载1到5之间的概率有多大？*1/5</li>
<li>A或B发生的概率<br>P(A或B发生) = P(A发生) + P(B发生) - P(A与B都发生)<br><em>假设我们要在1到10之间挑选一个数。挑中的数为偶数或这个数1到5之间的概率有多大？</em>4/5</li>
<li><p>独立<br>若A与B相互独立(也即，一个事件的发生，推不出另一个事件的发生)。那么P(A与B都发生) = P(A)P(B)。这条规则直接推倒自P(A与B都发生) = P(A)P(B).</p>
</li>
<li><p>互斥<br>若A与B互斥(也即，若一个事件发生，则另一个事件就不可能发生)，则P(A或B发生) = P(A) + P(B)。这是因为P(A与B都发生) = 0，所以，删除了之前P(A或B发生)算式中的P(A与B都发生)一项。</p>
</li>
</ul>
</li>
</ol>
<h2 id="面向对象设计">面向对象设计</h2><ol>
<li>如何解答面向对象设计问题<ul>
<li>处理不明确的地方</li>
<li>定义核心对象</li>
<li>分析对象关系</li>
<li>研究对象的动作</li>
</ul>
</li>
<li>设计模式<ul>
<li>单例设计模式<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Restaurant</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Restaurant _instance = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">Resuaurant</span>(<span class="params"></span>)</span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Restaurant <span class="title">getInstance</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">      _instance = <span class="keyword">new</span> Restaurant();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li>工厂方法设计模式<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> CardGame&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> CardGame createCardGame(GameType <span class="class"><span class="keyword">type</span>)&#123;</span></span><br><span class="line">     <span class="keyword">if</span>(<span class="class"><span class="keyword">type</span> </span>== GameType.Poker)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> PokerGame();</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="class"><span class="keyword">type</span> </span>== GameType.BlackJack)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlackJackGame();</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="递归和动态规划">递归和动态规划</h2><p>   当你听到问题是这么开头的：”设计一个算法，计算第n个……”,”编写代码列出前n个…….”,”实现一个方法，计算所有…..”等等，那么，这基本上就是一个递归问题。</p>
<ol>
<li>解决之道<br>从较小的子问题逐渐逼近原始问题。很多时候，只要在f(n-1)的解法中加入，移除某系东西或者稍作修改就能算出f(n).</li>
<li><p>动态规划<br>区别于递归，动态规划要对中间结果执行“缓存”操作，以备后续使用。<br><em>动态规划法简单实例：斐波那契数列</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改之前------------------------------</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(i == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span>(i == <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> fibonacci(i-<span class="number">1</span>) + fibonacci(i-<span class="number">2</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//修改之后------------------------------</span></span><br><span class="line"> <span class="keyword">int</span>[] fib = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(fib[i] != <span class="number">0</span>) <span class="keyword">return</span> fib[i];<span class="comment">//返回先前缓存的结果</span></span><br><span class="line">  fib[i] = fibonacci(i-<span class="number">1</span>) + fibonacci(i-<span class="number">2</span>);<span class="comment">//缓存结果</span></span><br><span class="line">  <span class="keyword">return</span> fib[i];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>递归和迭代解法<br>递归算法的空间效率很低。每次递归调用都会在栈上增加一层，也就是说，若算法包含O(n)次递归调用，就要使用O(n)内存。不得了！</li>
</ol>
</li>
</ol>
<h2 id="扩展性与存储限制">扩展性与存储限制</h2><ol>
<li>循序渐进法<ul>
<li>大胆假设</li>
<li>切合实际</li>
<li>解决问题</li>
</ul>
</li>
<li>你需要知道的：信息，策略与问题</li>
<li>示例：查找所有包含某一组词的文件<br><em>给定数百万份文件，如何找出所有包含某一组词的文件？我们不关心这些词出现的顺序，但它们必须是完整的单词。也就是说，“book”与“bookkeeper”不是一回事。</em><br><strong>在着手解决问题之前，我们需要考虑findWords程序只用一次，还是要反复调用。假设需要多次调用findWords程序来扫描这些文件，那么，我们可以接受预处理的开销。</strong><ul>
<li>步骤1<br>先忘记我们有数以百万计的文件，假装只有几十个文件。在这种情况下，如何实现findWords呢？<br>一种方法是预处理每个文件，并创建一个散列表的索引。这个散列表会将词映射到含有这个词的一组文件。<br>“books” -&gt;{doc2,doc3,doc6,doc8}<br>“many” -&gt;{doc1,doc3,doc7,doc8,doc9}<br>若要查找 “many books”,只需要对”books”和”many”的值进行交集运算，于是得到结果{doc3,doc8}</li>
<li>步骤2<br>现在，回到最初的问题。若有数百万份文件，会有什么问题？首先，我们可能需要将文件分散到多台机器上。<br>文件分散到多台机器上会引出以下几个很关键的关注点。<br>  1）如何划分改散列表。（按关键字划分）某台机器上存放油包含某个单词的全部文件。<br>  2）划分数据完成，我们可能需要在一台机器上对文件进行处理，并将结果推送他其他机器上。<br>  3）我们需要找到一种方法获知哪台机器拥有哪些数据。</li>
<li>步骤3<br>为了找到匹配某一组字符串的所有文件，我们会先对这一组字符串进行排序，然后给每一台机器发送与字符对应的查找请求。例如，若带查找字符串为“after builds boat amaze banana”，一号机器开始查找包含“after” 与 “amaze” 的文件，并对这些文件执行交集运算。三号机器则处理{“banana”，“boat”，“builds”}这几个关键字，同样也会对文件进行交集运算。<br>最后，发送请求的机器在对一号机器及三号机器返回的结果作交集运算。<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">            “after builds boat amaze banana”</span><br><span class="line"> </span><br><span class="line"> Machine <span class="number">1</span>：“after amaze”       Machine <span class="number">3</span>：“builds boat banana”</span><br><span class="line"> </span><br><span class="line">“after” -&gt;<span class="annotation">doc</span><span class="number">1</span>,<span class="annotation">doc</span><span class="number">5</span>,<span class="annotation">doc</span><span class="number">7</span>       “builds” -&gt;<span class="annotation">doc</span><span class="number">3</span>,<span class="annotation">doc</span><span class="number">4</span>,<span class="annotation">doc</span><span class="number">5</span></span><br><span class="line">“amaze” -&gt;<span class="annotation">doc</span><span class="number">2</span>,<span class="annotation">doc</span><span class="number">5</span>,<span class="annotation">doc</span><span class="number">7</span>       “boat”   -&gt;<span class="annotation">doc</span><span class="number">2</span>,<span class="annotation">doc</span><span class="number">3</span>,<span class="annotation">doc</span><span class="number">5</span></span><br><span class="line">                               “banana” -&gt;<span class="annotation">doc</span><span class="number">3</span>,<span class="annotation">doc</span><span class="number">3</span>,<span class="annotation">doc</span><span class="number">5</span></span><br><span class="line">      </span><br><span class="line">      &#123;<span class="annotation">doc</span><span class="number">5</span>,<span class="annotation">doc</span><span class="number">7</span>&#125;               &#123;<span class="annotation">doc</span><span class="number">3</span>,<span class="annotation">doc</span><span class="number">5</span>&#125;</span><br><span class="line">      </span><br><span class="line">                  solution = <span class="annotation">doc</span><span class="number">5</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="排序与查找">排序与查找</h2><ol>
<li><p>排序算法<br>面试中常见的排序算法三种算法：归并排序(Merge Sort) 快速排序(Quick Sort) 基数排序(Radix Sort,桶排序)</p>
<ul>
<li>冒泡排序|执行时间： 平均情况与最差情况为O(n²)，存储空间：O(1).<br>冒泡排序（Bubble Sort）是先从数组第一个元素开始，依次比较相邻两个数，若前者比后者大，就将两者交换位置，然后处理下一对，依此类推，不断扫描数组，直到完成排序。</li>
<li>选择排序|执行时间：平均情况与最差情况为O(n²)，存储空间：O(1).<br>选择排序(Selecction Sort)有点小儿科：简单而低效。我们会线性逐一扫描数组元素，从中挑出最小的元素，将它移到最前面(也就是与最前面的元素交换)。然后，再次线性扫描数组，找到第二小的元素，并移到前面。如此反复，直到全部元素各归其位。</li>
<li><p>归并排序|执行时间：平均情况与最差情况为O(nlog(n))，存储空间：看情况。☆☆☆☆☆<br>归并排序是将数组分成两半，这两半分别排序后，再归并在一起。排序某一半时，继续沿用同样的排序算法，最终，你将归并两个只含有一个元素的数组。这个算法的重担都落在“归并”的部分上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">  	<span class="keyword">int</span> middle = (low + high) /<span class="number">2</span>;</span><br><span class="line">      mergesort(<span class="built_in">array</span>,low,middle);<span class="comment">//排序左半部分</span></span><br><span class="line">      mergesort(<span class="built_in">array</span>,middle+<span class="number">1</span>,high);<span class="comment">//排序右半部分</span></span><br><span class="line">      merge(<span class="built_in">array</span>,low,middle,high);<span class="comment">//归并</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>,<span class="keyword">int</span> low,<span class="keyword">int</span> middle,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] helper = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">array</span>.length];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*将数组左右两半拷贝到helper数组中*/</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = low;i &lt;=high;i++)&#123;</span><br><span class="line">  helper[i] = <span class="built_in">array</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> helperLeft = low;</span><br><span class="line">  <span class="keyword">int</span> helperRight = middle + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> current = low;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   *迭代访问helper数组。比较左，右两半的元素，并将较小的元素复制到原先的数组中。</span><br><span class="line">   */</span></span><br><span class="line">   <span class="keyword">while</span>(helperLeft &lt;= middle &amp;&amp; helperRight &lt;=high)&#123;</span><br><span class="line">     <span class="keyword">if</span>(helper[helperLeft] &lt;= helper[helperRight])&#123;</span><br><span class="line">       <span class="built_in">array</span>[current] = helper[helperLeft];</span><br><span class="line">       helperLeft++;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果右边的元素小于左边的元素</span></span><br><span class="line">       <span class="built_in">array</span>[current] = helper[helperRight];</span><br><span class="line">       helperRight++;</span><br><span class="line">     &#125;</span><br><span class="line">     count++;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/*</span><br><span class="line">    *将数组左半部分剩余元素复制到目标数组中</span><br><span class="line">    */</span></span><br><span class="line">    <span class="keyword">int</span> remaining = middle -- helperLeft;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=remaining;i++)&#123;</span><br><span class="line">      <span class="built_in">array</span>[current + i] = helper[helperLeft + i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] helper = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">array</span>.length];</span><br><span class="line">  mergesort(<span class="built_in">array</span>,helper,<span class="number">0</span>,<span class="built_in">array</span>.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>merge方法会将目标数组的所有元素拷贝到临时数组helper中，并记下数组左,右两半的其实位置(helperLefth和helperRight)。然后，迭代访问helper数组，将左右两半中较小的元素，复制到目标数组中。最后，再将余下所有元素复制回目标数数组。</p>
</li>
<li><p>快速排序|执行时间：平均情况为O(nlog(n))，最差情况为O(n²)，存储空间：O(log(n)).☆☆☆☆☆<br>快速排序是随机挑选一个元素，对数组进行分割，以将所有比它小的元素排在前面，比它大的元素则排在后面。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">quickSort</span>(int arr[],int <span class="keyword">left</span>,int <span class="keyword">right</span>)&#123;</span><br><span class="line">  int index = <span class="built_in">partition</span>(arr,<span class="keyword">left</span>,<span class="keyword">right</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">left</span> &lt; index -<span class="number">1</span>)&#123; <span class="comment">//排序左半部分</span></span><br><span class="line">     <span class="built_in">quickSort</span>(arr,<span class="keyword">left</span>,index - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(index &lt; <span class="keyword">right</span>)&#123; <span class="comment">//排序右半部分</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr,index,<span class="keyword">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="built_in">partition</span>(int arr[],int <span class="keyword">left</span>,int <span class="keyword">right</span>)&#123;</span><br><span class="line">  int pivot = arr[(<span class="keyword">left</span> + <span class="keyword">right</span>)/<span class="number">2</span>];<span class="comment">//挑出一个基准点</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">left</span> &lt;= <span class="keyword">right</span>) &#123;</span><br><span class="line">    <span class="comment">//找出左边中应被放到右边的元素</span></span><br><span class="line">    <span class="keyword">while</span>(arr[<span class="keyword">left</span>] &lt; pivot) <span class="keyword">left</span>++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找出右边中应被放到左边的元素</span></span><br><span class="line">    <span class="keyword">while</span>(arr[<span class="keyword">right</span>] &gt; pivot) <span class="keyword">right</span>--;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换元素，同时调整左右索引值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">left</span> &lt;= <span class="keyword">right</span>)&#123;</span><br><span class="line">      <span class="built_in">swap</span>(arr,<span class="keyword">left</span>,<span class="keyword">right</span>);<span class="comment">//交换元素</span></span><br><span class="line">      <span class="keyword">left</span>++;</span><br><span class="line">      <span class="keyword">right</span>--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">left</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基数排序|执行时间：O(kn) ☆☆☆☆☆<br>基数排序是个整数(或其他一些数据类型)排序算法，充分利用整数的位数有限这一事实。使用基数排序时，我们会迭代访问数字的每一位，按各个位对这些数字分组。<br>比如说，假设有一个整数数组，我们可以先按个位对这些数字进行分组，于是，个位为0的数字就会分在同一个组里。然后，再按十位进行分组，如此反复执行同样的过程，逐级按更高位进行排序，直到最后整个数组变为有序数组。</p>
</li>
</ul>
</li>
<li><p>查找算法<br>二分查找☆☆☆☆☆ <strong>需要有序</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> mid;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">    mid = (low + high) /<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid] &lt; x)&#123;</span><br><span class="line">      low = mid +<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &gt; x)&#123;</span><br><span class="line">    high = mid -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearchRecursive</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> x,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(low &gt; high) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//错误</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> mid = (low + high) /<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span>(a[mid] &lt; x)&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearchRecursive(a,x,mid + <span class="number">1</span>,high);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &gt; x)&#123;</span><br><span class="line">   <span class="keyword">return</span> binarySearchRecursive(a,x,low,mid -<span class="number">1</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mid;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概念与算法">概念与算法</h1><h2 id="位操作">位操作</h2><ol>
<li>手工位运算<br>1000 - 0110  （0010）<br>1011 &amp; (~0 &lt;&lt; 2) （1000）</li>
<li><p>位操作原理与技]]>
    </summary>
    
      <category term="金典" scheme="http://zc14.github.io/tags/%E9%87%91%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[金典-数据结构]]></title>
    <link href="http://zc14.github.io/2015/12/13/%E9%87%91%E5%85%B8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://zc14.github.io/2015/12/13/金典-数据结构/</id>
    <published>2015-12-13T13:02:04.000Z</published>
    <updated>2015-12-27T07:32:53.270Z</updated>
    <content type="html"><![CDATA[<p>一些面试常用的数据结构<br><a id="more"></a></p>
<h1 id="数据结构">数据结构</h1><h2 id="数组与字符串">数组与字符串</h2><ol>
<li><p>散列表<br>散列表是一种将键(key)映射为值(value)从而实现快速查找的数据结构。<br><strong>核心：底层数组和散列函数(hash function)</strong>.问题：数组过小，碰撞冲突。<br>除了创建按索引hash(key)%array_length的数组元素指向的链表中。要通过某个键来查找对象，就必须根据散列值找到对应的链表，然后在链表中查找对应的键。<br>另外，我们还可以采用<strong>二叉查找树</strong>来实现散列表。只要我们让这棵树保持平衡，就能保证数据能查找用时为O(log n).原因很简单，我们不必一开始就分配一个大数组。</p>
</li>
<li><p>ArrayList(动态数组)</p>
</li>
<li><p>StringBuffer</p>
</li>
</ol>
<h2 id="链表">链表</h2><ol>
<li>创建链表<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Node</span><span class="identifier"></span><span class="title">&#123;</span><br><span class="line">  Node</span> next = null;</span><br><span class="line">  int data;</span><br><span class="line">  </span><br><span class="line">  public <span class="keyword">Node</span><span class="identifier"></span><span class="title">(int</span> d)&#123;</span><br><span class="line">    data = d;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  void appendToTail(int d)&#123;</span><br><span class="line">    <span class="keyword">Node</span><span class="identifier"> </span><span class="title">end</span> = new <span class="keyword">Node</span><span class="identifier"></span><span class="title">(d</span>);</span><br><span class="line">    <span class="keyword">Node</span><span class="identifier"> </span><span class="title">n</span> = this;</span><br><span class="line">    while(n.next != null)&#123;</span><br><span class="line">      n = n.next;</span><br><span class="line">    &#125;</span><br><span class="line">    n.next = end;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>删除单向链表中的节点<br>给定一个节点n，我们先找到它的前驱结点prev,并将prev.next设置为n.next.<br>如果是双向链表，我们还要更新n.next.将n.next.prev置为n.prev.当然，我们必须注意：</p>
<ul>
<li>检查空指针。</li>
<li>必要时更新表头head和表尾tail指针。<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Node deleteNode(Node head,int <span class="keyword">d</span>)&#123;</span><br><span class="line">  Node <span class="keyword">n</span> = head;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">n</span>.data == <span class="keyword">d</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> head.next; <span class="comment">/*表头指向下一结点*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">n</span>.next != null) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">n</span>.next.data == <span class="keyword">d</span>)&#123;</span><br><span class="line">      <span class="keyword">n</span>.next  = <span class="keyword">n</span>.next.next;</span><br><span class="line">      <span class="keyword">return</span> head; <span class="comment">/*表头不变*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">n</span> = <span class="keyword">n</span>.next;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>快行指针技巧<br>快行指针值得是同时用两个指针来迭代访问链表，只不过其中一个比另一个超前一些。”快”指针往往先行几步，或与”慢”指针相差固定的步数。<br><em>举个例子，假定有一个链表a1-&gt;a2-&gt;…..-&gt;an-&gt;b1-&gt;b2……-&gt;bn,你想将其重新排列成a1-&gt;b1-&gt;a2-&gt;b2-&gt;…..an-&gt;bn.另外，你不知道该链表的长度(但确定它有偶数个元素)。</em><br>你可以用两个指针，其中p1（快指针）每次都向前移动两步，而同时p2只移动一步。当p1到达链表末尾时，p2刚好位于链表中间位置。然后，再让p1与p2一步步从尾向头反向移动，并将p2指向的结点插入到p1所指结点后面。</p>
</li>
<li><p>递归问题<br>解决链表问题碰壁时，不妨试试递归法能否奏效。</p>
</li>
</ol>
<h2 id="栈与队列">栈与队列</h2><ol>
<li><p>实现一个栈<br>栈(LIFO)</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">  Node top;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">Object</span> pop()&#123;</span><br><span class="line">    <span class="keyword">if</span>(top != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="built_in">Object</span> item = top.data;</span><br><span class="line">      top = top.next;</span><br><span class="line">      <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> push(<span class="built_in">Object</span> item)&#123;</span><br><span class="line">    Node t = <span class="keyword">new</span> Mode(item);</span><br><span class="line">    t.next = top;</span><br><span class="line">    top = t;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">Object</span> peek()&#123;</span><br><span class="line">    <span class="keyword">return</span> top.data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现一个队列<br>队列采用先进先出(FIFO)顺序。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">class</span> Queue&#123;</span><br><span class="line">  Node <span class="keyword">first</span> ,<span class="keyword">last</span>;</span><br><span class="line">  </span><br><span class="line">  void enqueue(Object <span class="property">item</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">first</span> == null) &#123;</span><br><span class="line">      <span class="keyword">last</span> = new Node(<span class="property">item</span>);</span><br><span class="line">      <span class="keyword">first</span> = <span class="keyword">last</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="keyword">last</span>.next = new Node(<span class="property">item</span>);</span><br><span class="line">     <span class="keyword">last</span> = <span class="keyword">last</span>.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> Object dequeue()&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="keyword">first</span> != null)&#123;</span><br><span class="line">     Object <span class="property">item</span> = <span class="keyword">first</span>.data;</span><br><span class="line">     <span class="keyword">first</span> = <span class="keyword">first</span>.next;</span><br><span class="line"><span class="command">     return</span> <span class="property">item</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="command">   return</span> null;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="树与图">树与图</h2><ol>
<li><p>需要注意的潜在问题</p>
<ul>
<li>二叉树与二叉查找树<br>二叉查找树的附加条件：对于任意结点，左子结点&lt;=当前结点，后者 由&lt;=所有右子结点</li>
<li>平衡与不平衡<br>如果树是不平衡的，你应当从平均情况和最坏情况所需时间来描述自己的算法。注意，树的平衡有多种方法，平衡一棵树只意味着子树的深度差不会超过一定值，并不表示左子树和右子树的深度完全相同。</li>
<li>完满和完整<br>一棵树必须正好有2n次方-1个结点才能满足这个条件</li>
</ul>
</li>
<li><p>二叉树遍历 尤其是中序遍历考察的比较多</p>
</li>
<li><p>树的平衡：红黑树 和平衡二叉树。面试问的比较少</p>
</li>
<li><p>单词查找树(trie)<br>tire树是n层树的一种变体，其中每个节点存储有字符。整棵树的每条路径自上而下表示一个单词。</p>
</li>
<li><p>图的遍历<br>广度优先搜索(BFS)和深度优先搜索(DFS)</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>一些面试常用的数据结构<br>]]>
    
    </summary>
    
      <category term="金典" scheme="http://zc14.github.io/tags/%E9%87%91%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[准备]]></title>
    <link href="http://zc14.github.io/2015/12/13/%E5%87%86%E5%A4%87/"/>
    <id>http://zc14.github.io/2015/12/13/准备/</id>
    <published>2015-12-13T09:43:44.000Z</published>
    <updated>2015-12-13T12:51:32.600Z</updated>
    <content type="html"><![CDATA[<ol>
<li>没有什么比<strong>为兴趣而工作</strong>更能打动招聘人员的了。</li>
<li>公司最青睐的人才必须具备两个特性：一是天资聪颖，二是扎实的编程功底。</li>
<li>还要提前规划好职业发展路径。</li>
<li>建立好的人际网络。好的人际网络不仅意味着你广交朋友(广度),还要与他们保持紧密的联系(深度).尽量与朋友保持<strong>真诚</strong>与<strong>深厚</strong>的关系。</li>
<li>要学会主动跟人打招呼。</li>
<li>最重要的是乐于助人。</li>
</ol>
<h2 id="简历的书写">简历的书写</h2><ul>
<li>简历尽量短<br>[demo]:使用Y实现了X，从而达到了Z效果。<em>通过实施分布式缓存功能减少了75%的对象渲染时间，从而使得用户登录速度加快了10%。</em> <strong>原则：描述做过的事情，怎么做的，以及结果如何。理想的做法是尽可能地量化结果。</strong></li>
<li>编程语言：Java(非常熟练)，C++(熟练)，JavaScript(有过使用经验)。</li>
<li>你有哪些缺点 <strong>应该提到真实，合乎情理的缺点，然后话锋一转，强调自己如何克服这些缺点。</strong> <em>1.有时候，我可能对细节不够重视。好的一面是我反应迅速，执行力强，但不免会粗心大意而犯错。有鉴于此，我总是会找其他同事帮忙检查自己的工作，确保不出问题。</em> <em>2.通过记录笔记/blog的形式，深化记忆</em></li>
<li>项目中最难处理的问题是什么。  离职人员没有交接，造成问题定位困难（手机客户端，umapp端）。修改日志。</li>
<li>你应该问面试官哪些问题 1）真实的问题 <em>你每天有多少时间花在写代码上？</em> <em>你一周要开几次会？</em> 2）有见地的问题 <em>我注意到你们使用了X技术，请问你们是如何处理Y问题的？</em> 3）富有激情的问题 <em>我对可扩展性很感兴趣。请问你从事过分布式系统的工作吗？有哪些机会可以学习这方面的知识？</em> <em>我对X技术不是太熟悉，不过听上去是个不错的解决方案。你能给我多讲讲它的工作原理吗？</em></li>
<li><strong>VS</strong> <em>我几乎包揽了团队中所有的累活和难活。[骄傲自大，面试大忌]</em> <em>我实施了文件系统，因为XXXX原因，这是整个项目中最难的一部分。</em></li>
</ul>
<h2 id="行为面试题">行为面试题</h2><table>
<thead>
<tr>
<th style="text-align:right">常见问题</th>
<th style="text-align:right">项目1</th>
<th style="text-align:right">项目</th>
<th style="text-align:right">项目3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">最难的部分</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:right">有什么收获</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:right">最有意思的部分</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:right">最难解决的bug</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:right">最享受的过程</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:right">与团队成员的冲突</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
</tbody>
</table>
<p><strong>编写小故事，填写表格。面试前复习。最好小故事浓缩成几个字，便于记忆</strong></p>
<h2 id="基本知识点">基本知识点</h2><table>
<thead>
<tr>
<th style="text-align:right">数据结构</th>
<th style="text-align:right">算法</th>
<th style="text-align:right">概念</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">链表</td>
<td style="text-align:right">广度优先遍历</td>
<td style="text-align:right">位操作</td>
</tr>
<tr>
<td style="text-align:right">二叉树</td>
<td style="text-align:right">深度优先遍历</td>
<td style="text-align:right">单例设计模式</td>
</tr>
<tr>
<td style="text-align:right">单词查找树(trie)</td>
<td style="text-align:right">二分查找法</td>
<td style="text-align:right">工厂设计模式</td>
</tr>
<tr>
<td style="text-align:right">栈</td>
<td style="text-align:right">归并排序</td>
<td style="text-align:right">内存(栈和堆)</td>
</tr>
<tr>
<td style="text-align:right">队列</td>
<td style="text-align:right">快速排序</td>
<td style="text-align:right">递归</td>
</tr>
<tr>
<td style="text-align:right">向量/数组列表</td>
<td style="text-align:right">树的插入</td>
<td style="text-align:right">大O时间</td>
</tr>
<tr>
<td style="text-align:right">散列表</td>
<td style="text-align:right"></td>
</tr>
</tbody>
</table>
<h2 id="算法题的五种解法">算法题的五种解法</h2><ol>
<li><p>举例法<br><em>给定一个具体时间，计算时针与分针之间的角度。</em><br>[解]：下面以3：27为例。确定3点的时针位置和27分的分针位置，我们可以画出一个时钟。<br>在一下的解法中，h表示小时，m表示分钟。同时，我们假定h的范围[0-23].<br>从这些例子我们可以得出以下规则：</p>
<ul>
<li>分针的角度（从12点整开始算起）：360 x m/60;                              162</li>
<li>时针的角度（从12点整开始算起）：360 x (h%12)/12 + 360 x (m/60) x (1/12)   90 +13.5</li>
<li>时针和分针之间的角度： （30h-5.5m）%360. 148.5    14.58</li>
</ul>
</li>
<li><p>模式匹配法<br><em>一个有序数组的元素经过循环移动，元素的顺序可能是“3 4 5 6 7 1 2”。怎么才能找出数组中最小的那个元素？假设数组中的元素各不相同。</em><br>二分查找，部分有序。找出拐点即可。</p>
</li>
<li><p>简化推广法<br><em>从一本杂志里剪下一些单词可以拼凑成一封勒索信。怎样才能断定勒索信(以字符串表示)是否由某本杂志(即另一个字符串)里的单词组成。</em><br>可以先简化问题：暂时不考虑单词，只当它是字符。<br>推广这个算法，创建一个散列表，将单词映射到其词频上。</p>
</li>
<li><p>简单构造法–最后往往演变成递归法。（数学中的数学归纳法）<br><em>设计一种算法，打印某个字符串所有可能的排列组合。为简单起见，假设字符串中没有重复字符。</em><br>以字符串”abcdefg”为例：<br>只有”a”的情况，结果为：{“a”}<br>然后是”ab”，结果为：{“ab”,”ba”}<br>再然后是”abc”，结果会是什么呢？<br>此时，问题开始变得有点意思了。得到P(ab)的答案，怎么才能生成P(abc)呢？很简单，新字符是c。我们只需要在前一种情况的答案也即字符组合的任意位置加一个c就可以了。也就是：<br>P(abc) = 将”c”字符插入 P(ab)得到的所有字符串的任意位置。<br>亦即：P(abc) = 将”c”字符插入{“ab”,”ba”}这两个字符串中的任意位置。<br>也就是：P(abc) = merge({“cab”,”acb”,”abc”},{“cba”,”bca”,”bac”})<br>最后得出的结果：P(abc) = {“cab”,”acb”,”abc”,”cba”,”bca”,”bac”}.</p>
</li>
<li><p>数据结构头脑风暴<br><em>随机生成一些数字，并保存到一个(可扩展的)数组中。如何跟踪数组的中位数？</em><br>链表？<br>数组？<br>二叉树？<br>堆？</p>
</li>
</ol>
<h2 id="许多公司都想找到能写出“优美，整洁”代码的人才。">许多公司都想找到能写出“优美，整洁”代码的人才。</h2><ol>
<li>正确</li>
<li>高效</li>
<li>简洁</li>
<li>易读</li>
<li>可维护性</li>
</ol>
<p><em>编写一个函数检查某个二进制数(以字符串形式传入)是否等于以字符串表示的十六进制数。</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li>没有什么比<strong>为兴趣而工作</strong>更能打动招聘人员的了。</li>
<li>公司最青睐的人才必须具备两个特性：一是天资聪颖，二是扎实的编程功底。</li>
<li>还要提前规划好职业发展路径。</li>
<li>建立好的人际网络。好的人际网]]>
    </summary>
    
      <category term="面试" scheme="http://zc14.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法学习]]></title>
    <link href="http://zc14.github.io/2015/12/09/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://zc14.github.io/2015/12/09/算法学习/</id>
    <published>2015-12-09T05:26:15.000Z</published>
    <updated>2015-12-09T09:04:18.444Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="学习算法是非常有趣和令人激动的">学习算法是非常有趣和令人激动的</h1><h1 id="最大公约数-(欧几里得算法)">最大公约数-(欧几里得算法)</h1>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="link_reference">自然语言描述</span>]:<span class="link_url">计算两个非负整数p和q的最大公约数:若q是0，则最大公约数为p。否则，将p除以q得到余数r，p和q的最大公约数即为q和r的最大公约数。</span></span><br></pre></td></tr></table></figure>
<h2 id="基础">基础</h2><h2 id="排序">排序</h2><h2 id="查找">查找</h2><h2 id="图">图</h2><h2 id="字符串">字符串</h2><h2 id="背景">背景</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="学习算法是非常有趣和令人激动的">学习算法是非常有趣和令人激动的</h1><h1 id="最大公约数-(欧几里得算法)">最大公约数-(欧几里得算法)</h1>  <figure class="highlight markdown"><t]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[markdown快速入门]]></title>
    <link href="http://zc14.github.io/2015/12/06/markdown/"/>
    <id>http://zc14.github.io/2015/12/06/markdown/</id>
    <published>2015-12-06T13:48:23.000Z</published>
    <updated>2015-12-06T14:07:16.198Z</updated>
    <content type="html"><![CDATA[<p>简单学习markdown<br><a id="more"></a></p>
<h1 id="一级标题">一级标题</h1><h2 id="二级标题">二级标题</h2><h3 id="三级标题">三级标题</h3><h4 id="四级标题">四级标题</h4><h5 id="五级标题">五级标题</h5><h6 id="六级标题">六级标题</h6><p><strong>加粗</strong><br><em>斜体</em><br>这个是<code>行内代码</code>，好玩</p>
<ol>
<li>你好</li>
<li>我好</li>
<li>大家好</li>
</ol>
<p>[TOC]</p>
<ul>
<li>无序1</li>
<li>无序2</li>
<li>无序3</li>
</ul>
<hr>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hello</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"hello world"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>fffffff</del></p>
<p>==kkkkkkkkk==<br>| 姓名 | 学号 |<br>|——–|——–|<br>|      张三  |       002 |</p>
<!--注释-->]]></content>
    <summary type="html">
    <![CDATA[简单学习markdown]]>
    
    </summary>
    
      <category term="markdown" scheme="http://zc14.github.io/tags/markdown/"/>
    
      <category term="markdown" scheme="http://zc14.github.io/categories/markdown/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[临时笔记]]></title>
    <link href="http://zc14.github.io/2015/12/06/%E4%B8%B4%E6%97%B6%E7%AC%94%E8%AE%B0/"/>
    <id>http://zc14.github.io/2015/12/06/临时笔记/</id>
    <published>2015-12-06T07:53:01.000Z</published>
    <updated>2015-12-11T12:51:21.953Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="记录临时学习内容">记录临时学习内容</h1><h2 id="Java的设计优化_提高性能的5种[设计模式]_^-^">Java的设计优化 提高性能的5种[设计模式] ^.^</h2><h3 id="单例模式">单例模式</h3><h3 id="代理模式">代理模式</h3>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">静态代理： 抽象接口/真实对象/代理对象--可用于[延迟加载]</span><br><span class="line">动态代理： jdk/cglib</span><br><span class="line">           apache commons ArrayUtils.<span class="function"><span class="title">contains</span><span class="params">(xx,xx)</span></span> ,可以增加某些操作的日志过滤</span><br></pre></td></tr></table></figure>
<p>  <strong>待完成题目</strong> <em>运用spring拦截器，进行用户操作行为的记录[user/ip/method/time]</em></p>
<h3 id="享元模式">享元模式</h3>  <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">核心：克隆 或者 从享元工厂的<span class="preprocessor">Map</span>中获取</span><br></pre></td></tr></table></figure>
<h3 id="装饰者模式">装饰者模式</h3>  <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">核心：动态添加对象的功能，如java中的<span class="built_in">io</span>类</span><br></pre></td></tr></table></figure>
<h3 id="观察者模式">观察者模式</h3>  <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主题<span class="keyword">Subject </span>抽象/具体 (添加/删除/循环通知)</span><br><span class="line">观察者Observer update</span><br></pre></td></tr></table></figure>
<p>  <strong>待完成题目</strong> <em>考试系统-学生/考试</em></p>
<h2 id="缓存的应用">缓存的应用</h2>   <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(局部缓存/全局缓存)</span><br><span class="line">jsp标签实现页面级的局部缓存 - OSCache</span><br><span class="line">局部缓存在开发中 不如 全局缓存用的多</span><br><span class="line">全局缓存<span class="comment">--过滤器filter</span></span><br></pre></td></tr></table></figure>
<h2 id="Java程序优化">Java程序优化</h2><ul>
<li>集合类的相关[插入/删除]性能对比</li>
<li>集合类的相关[查找]性能对比</li>
</ul>
<h2 id="常用的提高性能方式">常用的提高性能方式</h2><ol>
<li>工具类多用静态方法</li>
<li>重量级对象的创建使用Clone(√)方法代替new关键字,注意深克隆和浅克隆，apache commons的是深度克隆</li>
<li>io操作尽可能的使用Buffer，性能提高不少</li>
<li>对于数据复制，尽量使用System.arrayCopy()</li>
<li>bool运算(&amp;&amp;)(√) 和 位运算,做逻辑判断的时候，前者效率高于后者</li>
<li>普通循环赋值 和 分批次循环赋值(√)  后者效率高</li>
<li>提取表达式，比如for循环时候的变量定义等</li>
<li>array 下标/switch/if else的效率</li>
<li>位运算代替乘法</li>
<li>局部变量(√) 和 成员变量,前者效率较高</li>
<li>一维数组(√) 性能 高于 二维数组</li>
</ol>
<h2 id="NIO">NIO</h2><ul>
<li>文件内存映射，效率很高</li>
<li>Channel/Buffer</li>
<li>Fork/Join</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="记录临时学习内容">记录临时学习内容</h1><h2 id="Java的设计优化_提高性能的5种[设计模式]_^-^">Java的设计优化 提高性能的5种[设计模式] ^.^</h2><h3 id="单例模式">单例模式</h3><h3 ]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://zc14.github.io/2015/12/06/hello-world/"/>
    <id>http://zc14.github.io/2015/12/06/hello-world/</id>
    <published>2015-12-06T06:32:43.000Z</published>
    <updated>2015-12-06T07:49:07.676Z</updated>
    <content type="html"><![CDATA[<p>开始新的征程.</p>
<h2 id="主标题">主标题</h2><h3 id="副标题1">副标题1</h3><h3 id="副标题2">副标题2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ 命令行语句</span><br></pre></td></tr></table></figure>
<p>更多信息: <a href="http://zc14.github.io/">More</a></p>
]]></content>
    <summary type="html">
    <![CDATA[入门页面，认识下简单的样式]]>
    
    </summary>
    
      <category term="开始" scheme="http://zc14.github.io/tags/%E5%BC%80%E5%A7%8B/"/>
    
      <category term="hello" scheme="http://zc14.github.io/categories/hello/"/>
    
  </entry>
  
</feed>
