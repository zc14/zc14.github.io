<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[zc14-紫竹林]]></title>
  <subtitle><![CDATA[叽里呱啦]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://zc14.github.io/"/>
  <updated>2016-02-19T12:49:05.695Z</updated>
  <id>http://zc14.github.io/</id>
  
  <author>
    <name><![CDATA[周聪]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Netty知识点总结]]></title>
    <link href="http://zc14.github.io/2016/02/19/Netty%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://zc14.github.io/2016/02/19/Netty知识点总结/</id>
    <published>2016-02-19T12:48:29.000Z</published>
    <updated>2016-02-19T12:49:05.695Z</updated>
    <content type="html"><![CDATA[<h1 id="1_传统IO和NIO比较">1 传统IO和NIO比较</h1><ul>
<li>单线程情况下只能有一个客户端响应</li>
<li>线程池可以有多个客户端连接，但是非常消耗性能</li>
<li>NIO技术 线程+selector</li>
</ul>
<h2 id="NIO的重要类">NIO的重要类</h2><pre><code><span class="label">ServerSocketChannel</span> 对比 ServerSocket
<span class="label">SocketChannel</span> 对比 Socket
<span class="keyword">Selector
</span><span class="keyword">SelectionKey</span>
</code></pre><h1 id="2_Netty3_入门">2 Netty3 入门</h1><p> <strong>SimpleChannelHandler</strong> 处理消息接收和写<br> {<br>   messageReceived接收消息<br>   channelConnected新连接，通常用来检测IP是否为黑名单<br>   channelDisconnected链接关闭，可以再用户断线的时候清楚用户的缓存数据等<br> }</p>
<h1 id="3_提高NIO性能">3 提高NIO性能</h1><p>   一个NIO可以有多个selector。分区域管辖</p>
<h1 id="4_精华">4 精华</h1><p>  <strong>一个Thread+队列 == 一个单线程线程池 ====&gt; 线程安全的，人无是线性串行执行的</strong><br>  线程安全，不会产生阻塞效应，使用对象组<br>  线程不安全，会产生阻塞效应，使用对象池</p>
<h1 id="5_心跳">5 心跳</h1><p>  <strong>IdleStateHandler</strong>，用于检测会话状态</p>
<pre><code><span class="number">1</span>. 心跳其实就是一个普通的请求，特点是数据简单，业务也简单
 <span class="number">2</span>. 心跳对于服务器端来说，定时清除闲置会话<span class="function"><span class="title">inactive</span><span class="params">(netty5)</span></span> <span class="function"><span class="title">channelclose</span><span class="params">(netty3)</span></span>
 <span class="number">3</span>. 心跳对于客户端来说，用来检测会话是否断开，是否重连。用来检测网络延迟
</code></pre><h1 id="6_ProtoBuf">6 ProtoBuf</h1><ol>
<li>protocol buff 是一种协议，from google，用于序列化</li>
<li>Java序列化协议也是其中一种</li>
<li>两者目的，将对象序列化城字节数组，或者说是二进制数据</li>
<li>优点：节约空间 int 4字节用 1~5字节表示，缺点：不易阅读</li>
</ol>
<h1 id="7_自定义数据包协议">7 自定义数据包协议</h1><ol>
<li>问题来源 粘包拆包<br>i am a gril i want a boy<br>粘包  i am a grili want a boy<br>分包  i am<br>   a gril i want a boy</li>
<li>原因：没有一个稳定的数据结构</li>
<li><p>解决：1.增加分隔符</p>
<pre><code><span class="number">2.</span>长度+数据
</code></pre><h1 id="8_自定义数据包格式举例">8 自定义数据包格式举例</h1><ul>
<li>数据包格式</li>
<li>+———-——+———–——+———-——+———-——+———–——+</li>
<li>| 包头    | 模块号   | 命令号  |  长度  |   数据   |</li>
<li>+———-——+———–——+———-——+———-——+———–——+</li>
<li>包头4字节</li>
<li>模块号2字节short</li>
<li>命令号2字节short</li>
<li>长度4字节(描述数据部分字节长度)</li>
</ul>
</li>
</ol>
<h1 id="9_Netty解决粘包拆包问题">9 Netty解决粘包拆包问题</h1><p>   可以借助<strong>FrameDecoder</strong></p>
<h1 id="10_Netty_源码分析">10 Netty 源码分析</h1><ol>
<li>消息如何在管道中流转<br>handler往下传递对象的方法是sendUpstream(event)</li>
<li>为什么FrameDecoder return的对象就是往下传递的对象  （还是调用了sendUpstream）</li>
<li>buffer里面数据未被读取完怎么办？    （cumulation缓存）</li>
<li>为什么return null就可以缓存buffer     （cumulation缓存）</li>
<li>FrameDecoder里面的cumulation其实就是一个缓存的buffer对象</li>
</ol>
<h1 id="11_netty3_vs_netty5">11 netty3 vs netty5</h1><p>netty3                 netty4或5</p>
<p>ChannelBuffer        ByteBuf</p>
<p>ChannelBuffers        PooledByteBufAllocator(要注意使用完后释放buffer)或UnpooledByteBufAllocator或Unpooled</p>
<p>FrameDecoder        ByteToMessageDecoder</p>
<p>OneToOneEncoder        MessageToByteEncoder</p>
<p>messageReceive        channelRead0(netty5里面是messageReceive)</p>
<p>业务线程池</p>
<p>EventLoopGroup 消息串行化</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1_传统IO和NIO比较">1 传统IO和NIO比较</h1><ul>
<li>单线程情况下只能有一个客户端响应</li>
<li>线程池可以有多个客户端连接，但是非常消耗性能</li>
<li>NIO技术 线程+selector</li>
</ul>
<h2 i]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[java集合类]]></title>
    <link href="http://zc14.github.io/2016/02/19/java%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <id>http://zc14.github.io/2016/02/19/java集合类/</id>
    <published>2016-02-19T12:45:40.000Z</published>
    <updated>2016-02-19T12:47:07.210Z</updated>
    <content type="html"><![CDATA[<h1 id="ArrayList源码知识点–transient_Object[]_elementData；">ArrayList源码知识点–transient Object[] elementData；</h1><h2 id="1-_add扩容">1. add扩容</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">elementData = Arrays.copyOf(elementData, newCapacity);</span><br></pre></td></tr></table></figure>
<h2 id="2-_Arrays-copyOf核心部分">2. Arrays.copyOf核心部分</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>类型分 <span class="keyword">Object</span>/T</span><br><span class="line">对应 <span class="keyword">new</span> <span class="keyword">Object</span>[newLength] 和 <span class="keyword">Array</span>.newInstance(newType.getComponentType(), newLength);</span><br><span class="line"><span class="number">2.</span>最终要执行数组的拷贝</span><br><span class="line">System.arraycopy(original, <span class="number">0</span>, <span class="built_in">copy</span>, <span class="number">0</span>,</span><br><span class="line">                         Math.<span class="built_in">min</span>(original.length, newLength));</span><br></pre></td></tr></table></figure>
<h2 id="3-_Arrays-toString(str)用于输出">3. Arrays.toString(str)用于输出</h2><h2 id="4-_remove删除对象_fastRemove">4. remove删除对象 fastRemove</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(elementData, <span class="keyword">index</span>+<span class="number">1</span>, elementData, <span class="keyword">index</span>,</span><br><span class="line">                             numMoved)；</span><br></pre></td></tr></table></figure>
<h2 id="5-_常用方法_add(E)/remove(E)/get(int)/contains(E)/iterator()">5. 常用方法 add(E)/remove(E)/get(int)/contains(E)/iterator()</h2><h2 id="6-_ArrayList总结">6. ArrayList总结</h2><ul>
<li>基于数组实现</li>
<li>容量动态增长，性能考虑，初始化时候最好指定</li>
<li>删除元素，数组容量不会变化，可用trimToSize()做调整</li>
<li>非线程安全</li>
</ul>
<p>=========================================================</p>
<h1 id="LinkedList源码知识点–双向链表Node,next,prev;">LinkedList源码知识点–双向链表Node,next,prev;</h1><h2 id="1-_add(E)">1. add(E)</h2><p>   需要创建一个新的Node节点，并对其next,prev做好处理。</p>
<h2 id="2-_remove(E)">2. remove(E)</h2><p>   需要遍历，取得位置后好办了，直接修改item,next,prev。</p>
<h2 id="3-_get(int)">3. get(int)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; node(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;<span class="comment">//0~mid中查找</span></span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)<span class="comment">//否则size-1 到 index中查找</span></span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```   </span><br><span class="line"><span class="preprocessor">## <span class="number">4.</span> iterator()</span></span><br><span class="line">   通过内部类来完成ListItr</span><br><span class="line"><span class="preprocessor">## <span class="number">5.</span> contains(E)</span></span><br><span class="line">   依次遍历，没啥好说的。</span><br><span class="line"><span class="preprocessor">## <span class="number">6.</span> LinkedList总结</span></span><br><span class="line">+ 基于双向链表实现的</span><br><span class="line">+ 插入元素时，需要创建一个新的Node</span><br><span class="line">+ 删除元素时，需要遍历</span><br><span class="line">+ 查找元素时，需要遍历</span><br><span class="line">+ 非线程安全</span><br><span class="line"></span><br><span class="line">=========================================================</span><br><span class="line"><span class="preprocessor"># Vector源码知识点--protected Object[] elementData;</span></span><br><span class="line"><span class="preprocessor">## <span class="number">1.</span> add(E)核心代码</span></span><br></pre></td></tr></table></figure>
<p>int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?<br>                                         capacityIncrement : oldCapacity);<br>```<br>取决于capacityIncrement。如果大于0，则新容量= 旧容量+capacityIncrement；否则 新容量= 2*旧容量。</p>
<h2 id="2-_remove(E)_==_synchronized+ArrayList的remove(E)">2. remove(E) == synchronized+ArrayList的remove(E)</h2><h2 id="3-_get(int)_==_synchronized+ArrayList的get(int)">3. get(int) == synchronized+ArrayList的get(int)</h2><h2 id="4-_iterator()_==_ArrayList的iterator()">4. iterator() == ArrayList的iterator()</h2><h2 id="5-_contains(E)_==_synchronized+ArrayList的contains(E)">5. contains(E) == synchronized+ArrayList的contains(E)</h2><h2 id="6-_Vector总结">6. Vector总结</h2><ul>
<li>synchronized的ArrayList</li>
<li>扩容机制稍有不同。由capacityIncrement决定是增量加还是2倍长。</li>
</ul>
<p>=========================================================</p>
<h1 id="Stack源码知识点–extends_Vector_LIFO">Stack源码知识点–extends Vector   LIFO</h1><h2 id="push–实际执行的是Vector中的方法">push–实际执行的是Vector中的方法</h2><h2 id="pop–peek方法+删除元素">pop–peek方法+删除元素</h2><h2 id="peek–实际执行的是Vector中的elementAt方法">peek–实际执行的是Vector中的elementAt方法</h2><h2 id="Stack总结">Stack总结</h2><ul>
<li>基于Vector实现的</li>
<li>支持LIFO</li>
</ul>
<p>=========================================================</p>
<h1 id="HashSet–private_transient_HashMap_map;">HashSet–private transient HashMap<e,object> map;</e,object></h1><h2 id="HashSet总结">HashSet总结</h2><ul>
<li>HashSet基于HashMap实现的，无容量限制</li>
<li>HashSet非线程安全</li>
</ul>
<p>=========================================================</p>
<h1 id="TreeSet">TreeSet</h1><h2 id="TreeSet总结">TreeSet总结</h2><ul>
<li>TreeSet基于TreeMap实现的，支持排序</li>
<li>TreeSet非线程安全</li>
</ul>
<p>=========================================================</p>
<p>#TreeMap</p>
<h2 id="TreeMap总结">TreeMap总结</h2><ul>
<li>基于红黑树实现的，无容量限制</li>
<li>非线程安全</li>
</ul>
<p>=========================================================</p>
<h1 id="HashMap">HashMap</h1><p>？？？</p>
<p>=========================================================</p>
<h1 id="ConcurrentHashMap">ConcurrentHashMap</h1><p>？？</p>
<p>=========================================================</p>
<p>#CopyOnWriteArrayList</p>
<p>=========================================================</p>
<h1 id="CopyOnWriteSet">CopyOnWriteSet</h1><p>=========================================================</p>
<h1 id="ArrayBlockingQueue–FIFO">ArrayBlockingQueue–FIFO</h1><p>？？</p>
<p>=========================================================</p>
<h1 id="ThreadPoolExecutor">ThreadPoolExecutor</h1><h2 id="创建线程池">创建线程池</h2><p>？？</p>
<p>=========================================================</p>
<h1 id="Executors">Executors</h1><p>=========================================================</p>
<h1 id="FutureTask">FutureTask</h1><p>=========================================================</p>
<h1 id="Semaphore">Semaphore</h1><h2 id="控制某资源同时被访问的个数的类">控制某资源同时被访问的个数的类</h2><p>=========================================================</p>
<h1 id="CountDownLatch">CountDownLatch</h1><p>=========================================================</p>
<h1 id="CyclicBarrier">CyclicBarrier</h1><h2 id="当await的数量到达了设定的数量后，才能继续往下执行。">当await的数量到达了设定的数量后，才能继续往下执行。</h2><p>=========================================================</p>
<h1 id="ReentrantLock">ReentrantLock</h1><p>=========================================================</p>
<h1 id="Condition">Condition</h1><h2 id="ReentrantLock-newCondition()">ReentrantLock.newCondition()</h2><p>=========================================================</p>
<h1 id="ReentrantReadWriteLock-读写锁">ReentrantReadWriteLock-读写锁</h1><p>？？</p>
<p>=========================================================</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="ArrayList源码知识点–transient_Object[]_elementData；">ArrayList源码知识点–transient Object[] elementData；</h1><h2 id="1-_add扩容">1. add扩容</h2><f]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[java基础知识点准备]]></title>
    <link href="http://zc14.github.io/2016/01/23/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%87%86%E5%A4%87/"/>
    <id>http://zc14.github.io/2016/01/23/java基础知识点准备/</id>
    <published>2016-01-23T09:28:22.000Z</published>
    <updated>2016-02-20T03:22:36.572Z</updated>
    <content type="html"><![CDATA[<h2 id="1-知识点总结">1.知识点总结</h2><ul>
<li><h3 id="常见面试题整理">常见面试题整理</h3><p>1.Aio和Nio区别<br>  <strong>NIO:同步非阻塞；AIO:异步非阻塞</strong><br>  <strong>同步异步是指是否是同一次请求（便于理解，举个例子）。阻塞和非阻塞就是oio和nio的问题，指的是调用一个方法能否立即返回结果。</strong><br>  <em>如果把内核比作快递，NIO就是你要自己时不时到官网查下快递是否已经到了你所在城市，然后自己去取快递；AIO就是快递员送货上门了。</em></p>
<p>2.你做过最得意的项目是什么<br>  <strong>必须想办法突出项目的亮点，并且突出自己在团队中的重要性。</strong></p>
<p>3.HashMap是如何实现的<br>  <strong>本质：数组+链表， 链表的节点就是 k-v 对。H</strong><br>  <strong>Hashmap中有一个饱和因子的变量，默认上是0.75，实际上也是通常情况下不会产生hash冲突的最佳设置（当然凡事也有例外）</strong><br>  <strong>这个扩容会重做整个散列数组+链表，代价很大，所以大牛们都建议使用hashmap时最好指定需要的容量大小。</strong><br>  <strong>一般需要使用大小为N，new HashMap时最好指定（N/饱和因子）的容量，或者指定大于N的最小的2的幂。</strong></p>
<p>4.为什么要使用Spring<br> <strong>与EJB对比。重量级模块耦合度高。/用哪个，配置哪个。 Ioc模块+Aop模块。 润滑剂 让业务功能实现更方便、更优雅。</strong></p>
<p>5.如何减少上下文切换<br> <strong>上下文切换是指CPU的控制权由运行任务转移到另外一个就绪任务时所发生的事件；</strong></p>
<p> <strong>对于任务耗时短的情况，要求线程尽量少，如果线程太多，有可能出现线程切换和管理的时间，大于任务执行的时间，那效率就低了；</strong><br> <strong>耗时长的任务，要分是cpu任务，还是io等类型的任务。如果是cpu类型的任务，线程数不宜太多；但是如果是io类型的任务，线程多一些更好，可以更充分利用cpu</strong><br> <strong>高并发，低耗时的情况，上下文切换 本来就多，并且高并发就意味着CPU是处于繁忙状态的， 增加更多地线程也不会让线程得到执行时间片, 反而会增加线程切换的开销.</strong><br> <strong>低并发，高耗时，保证有空闲线程，接收新任务，可以减少线程切换。</strong><br> <strong>高并发高耗时：1要分析任务类型，2增加排队，3、加大线程数</strong></p>
</li>
</ul>
<p>  6.Spring有什么缺点<br>   <strong>变的复杂。东西越来越多，拆分模块出来，不知道用什么。</strong><br>   <strong>学习源码困难度加大。</strong></p>
<p>  7.有限的资源里处理一个较大的数据<br>   <strong>如果你处理逻辑，跟全量数据有关，例如对全部数据进行排序，这个可以采用bitmap(索引，数据压缩方面有好的应用),堆排序等之类的，网上可以搜到。<br>但是如果你的处理逻辑跟全量数据无关，那就跟简单了，你可以设置一个buffer，每次读满一个buffer，处理完了，再读下一个buffer。</strong></p>
<p>  8.高并发，执行耗时短的任务，还有低并发，执行耗时长的任务，各自选取什么样的线程池会比较合理？为什么？如果业务场景是高并发，且任务耗时长时，有什么解决思路？<br>  <strong>线程池的关键点是：1、尽量减少线程切换和管理的开支； 2、最大化利用cpu。</strong><br>  <strong>对于1，要求线程数尽量少，这样可以减少线程切换和管理的开支；<br>对于2，要求尽量多的线程，以保证CPU资源最大化的利用。</strong><br>  <strong>对于高并发耗时长的情况，我认为，思路就是把一个难以解决的问题转化成我们已知的已经有解决方案的问题，以此来解决。<br>所以 ，高并发又耗时长，可以转化为<br>      1、高并发，耗时短的问题   –&gt;   异步处理+回调，和情况1吻合<br>      2、低并发，耗时长的问题   –&gt;   前端加load balance，把高并发分摊成若干低并发，和情况2吻合<br>其实说到核心，如果真遇到高并发耗时长的场景，只能是加机器，加计算单元（无论是异步加回调还是load balance）</strong></p>
<p>  9.数据库中内连接与外连接的区别<br>  <strong>这个问题从数学的角度更容易理解。<br>inner join：A与B的交集<br>left join：A的全集<br>right join：B的全集<br>full join：A与B的并集<br>cross join：A与B的笛卡尔积</strong></p>
<p>  10.经常看到url中很长的一串请求参数，为什么不采用post方式<br>  <strong>1 浏览器地址栏打开的默认就是GET，所以链接用GET很方便。<br>2 POST的提交需要表单或js提交，麻烦。<br>3 GET可以使用缓存<br>4 GET有利于SEO</strong></p>
<p>  11.有一个生成唯一串的需求，并发请求量非常大<br><strong>1.生成串由单线程批量生成。<br>2.并发获取的线程由队列（队列采用链表的阻塞队列实现）进行控制。<br>串的生成格式：ip+进程号+当前时间(精确到纳秒)+计数器（每次批量生成串的时候重置计数器为0）<br>可以解决，多机多JVM实例的问题，计数器可以解决时间相同的问题</strong></p>
<p>  12.处理大量并发用户访问网页，并且如何跟踪每个用户<br><strong>页面静态化，还有cdn代理等等 总之尽量减少或避免用户加载页面时与服务后台产生动态数据的加载</strong></p>
<p> 13.高并发解决方案<br> <strong>浏览器到前台页面，负载均衡，HTML静态化，缓存，图片服务器分离。数据库，读写分离，垂直拆分数据库，水平拆分数据库。</strong></p>
<p> 14.1亿条数据如何保存<br>  <strong>生成txt或者csv数据文件，再直接通过数据文件导入到数据库中。先删除索引，导入后在重建。</strong></p>
<p>15.1000万条数据如何取出来<br>  分页？</p>
<p>16.有3个线程ABC。按照ABC来运行（A线程输出A，B线程输出B，C线程输出C，以此类推，循环输出）。<br>  <strong>join</strong><br>  <strong>用 Reentrantlock，用它的newCondition() 方法创建3个condition，按顺序调用 condition 的await和signal 方法就可以了，具体看Reentrantlock 和Condition 讲解。</strong></p>
<p>17.threadlocal原理<br> **ThreadLocal 主要目的：<br>1、在同一线程中方法与方法，类与类之间的共享内容传输（也是官方创建ThreadLocal的本意）。<br>2、利用ThreadLocal 规避线程安全问题，这种方式已经大量应用，如Spring mvc 在Controller中注入全局HttpSession对象。</p>
<p>ThreadLocal原理：<br>Thread 类成员变量 ThreadLocal.ThreadLocalMap 详细不说了。**</p>
<p>18.分库分表如何控制事务，也就是分布式事务有什么解决方案<br><strong>所谓分布式事务最终解决的是数据一致性的问题，这也是典型的cap定理里面的东西没啥新鲜的。那么如何解决？<br>1，用redis做一个分布式锁，不过redis集群很麻烦，不太稳定（目前我们公司再用）<br>2，zk锁，推荐使用。：<br>3，数据库层面的东西，有一个mycat的东西，你可以了解下。</strong></p>
<p>19.让您做一个电商平台，您如何设置一个在买家下订单后的”第60秒“发短信通知卖家发货，您需要考虑的是 像淘宝一样的大并发量的订单。<em> ★★★★★★★★★★★★★★★★★<strong>
  </strong><br>  可以通过分布式调度框架来实现,将这种通用的调度任务交给专门的系统来处理,接收下单的时间和订单的基本信息做为触发这个任务的参数即可<br>触发动作可以用过类似kafka的消息中间件进行传递*</em></p>
<p><strong>1、具有排序功能的队列<br>2、Redis+定时器</strong><br><em>原理：第一种思路也就是大家推荐的延迟队列实现的原理，其就是一个按时间排好序的队列，每次put的时候排序，然后take的时候就计算时间是否过期，如果过期则返回队列第一个元素，否则当前线程阻塞X秒，这个也是JDK 自带 DelayQueue 的思路。详细可看源码</em><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pubic E <span class="title">take</span>(<span class="params"></span>) throws InterruptedException</span>&#123;</span><br><span class="line">  final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">  <span class="keyword">lock</span>.lockInterruptibly();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      E first = q.peek();</span><br><span class="line">      <span class="keyword">if</span>(first == <span class="keyword">null</span>)</span><br><span class="line">      available.await();</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> delay = first.getDelay(TimeUnit.NANOSECONFS);</span><br><span class="line">        <span class="keyword">if</span>(delay &lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> q.poll();</span><br><span class="line">        <span class="function"><span class="keyword">else</span> <span class="title">if</span>(<span class="params">leader != <span class="keyword">null</span></span>)</span><br><span class="line">        available.<span class="title">await</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">         Thread thisThread = Thread.currentThread();</span><br><span class="line">         leader = thisThread;</span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line">            available.awaitNanos(delay);</span><br><span class="line">         &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(leader == thisThread)</span><br><span class="line">           leader = <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(leader == <span class="keyword">null</span> &amp;&amp; peek() != <span class="keyword">null</span>)</span><br><span class="line">    available.signal();</span><br><span class="line">    <span class="keyword">lock</span>.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>原理：第二种思路需要利用Redis的有序集合，说到使用 Redis 就不得不考虑Score的设计，因为它直接决定你代码的复杂度，你思路的清晰性，在这我并没有采用 林中漫步 先生的设计，而是通过精确到秒的时间做Score（去掉毫秒），然后使用线程每一秒扫一次，使用当前时间作为zrangeBysocre命令的Score去查询。详细请看代码。<br>业务场景：按京东一天500万的成交量，一天主要成交时间为8小时，计算得出每秒173个订单，当然实际上订单不能均匀分布在每秒，但我们主要为了论证思想的可行性。<br>代码实现：这里首先我简单的利用Spring Scheduled作为订单的生产者，每一秒制造170个订单，放入Redis，注意Score的生成，为当前时间的后60秒，removeMillis()生成去掉毫秒的时间戳作为Rredis的Zadd方法的 Score（不了解的可以百度下）。</em><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Componment</span><br><span class="line"><span class="keyword">public</span> class OrderHanlder&#123;</span><br><span class="line">  <span class="keyword">private</span> Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line">  <span class="keyword">private</span> AtomicLong currentOrderId = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> simpleDateFormat sdformat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> KEY = <span class="string">"orders"</span>;</span><br><span class="line">  </span><br><span class="line">  @Scheduled(cron = <span class="string">"0/1 * * * * *"</span>)</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> initData() <span class="keyword">throws</span> ParseException&#123;</span><br><span class="line">   Calendar cal = <span class="keyword">new</span> Calendar();</span><br><span class="line">   cal.<span class="built_in">add</span>(Calender.SECOND,<span class="number">60</span>);<span class="comment">//获取当前日期的后60秒</span></span><br><span class="line">   Map&lt;<span class="keyword">String</span>,Double&gt; scores = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">//一天500w的成交量，8小时计算，每秒成交173份订单</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;<span class="number">170</span>;i++)&#123;</span><br><span class="line">     currentOrderId.getAndIncrement();</span><br><span class="line">     scores.put(currentOrderId.toString(),(<span class="keyword">double</span>)removeMillis(cal));</span><br><span class="line">     jedis.zadd(<span class="variable">key</span>,scores);</span><br><span class="line">     System.out.<span class="built_in">println</span>(<span class="string">"当前订单ID：---------"</span>+currentOrderId);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> removeMills(Canendar cal) <span class="keyword">throws</span> ParseException&#123;</span><br><span class="line">    <span class="keyword">String</span> date = sdformat.format(cal.getTime());</span><br><span class="line">    Date nowTime = sfformat.parse(date);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"---------当前时间： "</span>+nowTime + <span class="string">"-----毫秒数 "</span>+nowTime.getTime());</span><br><span class="line">    <span class="keyword">return</span> nowTime.getTime();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二步：同样利用Spring Scheduled 一秒钟心跳一次，每次利用当前时间作为Key 从Redis 取数据。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Scheduled</span>(cron=<span class="string">"0/1 * * * * *"</span>)</span><br><span class="line">public <span class="type">void</span> consumer() throws <span class="type">ParseException</span>&#123;</span><br><span class="line">  <span class="type">Calendar</span> cal = <span class="type">Calendar</span>.getInstance();</span><br><span class="line">  long score = removeMills(cal);</span><br><span class="line">  <span class="type">Set</span>&lt;<span class="type">String</span>&gt; orders = <span class="type">Jedis</span>.zrangeByScore(<span class="type">KEY</span>,<span class="number">0</span>,score);//早于当前时间的都应该被发送，因为可能订单太多没有处理过来</span><br><span class="line">  <span class="keyword">if</span>(orders.isEmpty()||orders,size() == <span class="number">0</span>)</span><br><span class="line">    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"========================暂时没有订单，时间："</span>+cal.getTime());</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">String</span> order:orders)&#123;</span><br><span class="line">    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"^^^^^^^^^^^^^^^^^^^^^^^^处理订单，订单ID： "</span>+order);</span><br><span class="line">    long <span class="literal">result</span> = jedis.zrem(<span class="type">KEY</span>,order);</span><br><span class="line">    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"^^^^^^^^^^^^^^^^^^^^^^^^处理完毕，订单ID： "</span>+order+<span class="string">" 删除结果"</span>+(<span class="literal">result</span> ==<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> private long removeMills(<span class="type">Canendar</span> cal) throws <span class="type">ParseException</span>&#123;</span><br><span class="line">    <span class="type">String</span> date = sdformat.format(cal.getTime());</span><br><span class="line">    <span class="type">Date</span> nowTime = sfformat.parse(date);</span><br><span class="line">    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"---------当前时间： "</span>+nowTime + <span class="string">"-----毫秒数 "</span>+nowTime.getTime());</span><br><span class="line">    <span class="keyword">return</span> nowTime.getTime();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>经过测试，没有出现漏单的情况，这只是简单的实现，很多地方可以优化，在实际中用也可能会出现很多问题，需要不断完善，此案例只是提供思路，另外我觉得JDK的 DelayQueue 相对于Redis来说没有那么好，因为Queue毕竟每次取一个，如果同一时间的比较多可能不能符合当前这种时间严谨的需求，另外他是单机的，有时间我去研究下kafka、Rabbit的延迟队列再来补充。</p>
<p>20.多维度查询的解决方案有哪些？<br><em>我们现在的公寓特别多，在页面用户可以根据多种维度进行筛选，比如“面积、房间、豪华程度、小区、新旧、交通、价格……”，这种场景如果放在数据库进行过滤，肯定是作死的节奏。</em><br> 这种一般用Nosql，而不是关系型数据库，比如elasticsearch搜索引擎，k-v键值对，可对同个商品同时建立多个标签进行多维度搜索，支持分页，高性能<br> 一般可以通过搜索引擎的方式来解决,比如ES,性能上无压力,无限集群<br> solr facet</p>
<p>21.集群环境如何保证某个机器挂掉了ng请求不再有访问打到这个机器<br><strong>Nginx有个负载均衡的插件叫做 nginx-upstream-fair：按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br>这种负载策略应该可以解决你那种问题，不用轮询。</strong></p>
<p>22.遇到OOM如何处理<br><strong>首先，要搞清OOM的分类：<br>OMM主要三类： permgen OOM , heap OOM, stack overflow<br>permgen OOM: 这个主要是由于加载的类太多，或者反射的类太多， 还有 调用 String.intend（jdk7之前）也会造成这个问题。所以出现了这个问题，就检查这三个方面；<br>heap OOM： 基本是按照 1楼的方式就可以解决了，主要是因为一些无用对象没有及时释放造成的，检查代码加上 heap dump 去分析吧<br>stack overflow： 这个主要是由于调用层数，或者递归深度太大造成的，看异常信息，基本上就能定位得出来了</strong></p>
<ul>
<li><h3 id="Java_集合类源码_？？？">Java 集合类源码 ？？？</h3><ol>
<li>涉及到堆栈，队列等操作，应该考虑用List。</li>
<li>需要快速插入，删除元素，应该使用LinkedList。</li>
<li>需要快速随机访问元素，应该使用ArrayList。</li>
</ol>
</li>
<li><h3 id="设计模式的实际应用_？？？">设计模式的实际应用 ？？？</h3><p>1.单例模式<br>2.工厂模式<br>3.责任链模式<br>4.代理模式<br>5.模板方法模式-回调函数<br>6.策略模式<br>7.组合模式-递归调用<br>8.门面模式<br>9.观察者模式<br>10.中介者模式<br>11.享元模式<br>12.原型模式<br>13.命令模式<br>14.迭代器模式<br>15.桥接模式<br>16.构造者模式<br>17.适配器模式<br>18.备忘录模式<br>19.访问者模式<br>20.工厂方法模式<br>21.状态模式<br>22.解释器模式<br>23.装饰者模式</p>
</li>
<li><h3 id="Spring">Spring</h3><p>参考黄亿华老师的<strong>1000行代码读懂Spring核心</strong><br>大部分的框架都是由静态配置产生动态代码<br>如何编写一个Spring<br><strong>Spring IoC主线中的大部分重要角色：<br>BeanDefinition,BeanFactory,ApplicationContext<br>Resource,BeanDefinitionReader,PropertyValue,BeanReference</strong></p>
</li>
</ul>
<p>1.Ioc-给你想要的</p>
<ul>
<li><p>最基本的容器-包括注入和获取功能<br>BeanDefinition-保存Bean及配置信息（Bean）<br>BeanFactory-对Bean进行管理（Map-registerBeanDefinition/getBean）<br>核心流程：</p>
<pre><code><span class="number">1.</span> 初始化BeanFactory
<span class="number">2.</span> 注册Bean
<span class="number">3.</span> 获取Bean
</code></pre></li>
<li><p>将Bean创建放入工厂-管理Bean的生命周期<br>抽象BeanFactory-面向接口更易扩展<br>在AbstractBeanFactory内部初始化Bean（BeanFactory-AbstractBeanFactory-AutowireCapableBeanFactory）<br>核心流程:</p>
<pre><code><span class="number">1</span>. 初始化<span class="keyword">BeanFactory </span>面向接口编程 <span class="keyword">BeanFactory </span><span class="keyword">beanFactory </span>= new AutowireCapableBeanFactory()<span class="comment">;</span>
<span class="number">2</span>. 注册<span class="keyword">Bean </span><span class="keyword">BeanDefinition(Bean/BeanClass/BeanClassName) </span>在AutowireCapableBeanFactory中
   实现Class.forName(<span class="keyword">beanClassName).newInstance(); </span>
<span class="number">3</span>. 获取<span class="keyword">Bean</span>
</code></pre></li>
<li><p>为bean注入属性<br>PropertyValue-保存属性注入信息（name/value）<br>PropertyValues（List<propertyvalue> add/getList）<br>AutowireCapableBeanFactory-可自动装配的BeanFactory-newInstance()/applyPropertyValues(Field)<br>BeanDefinition（Bean/BeanClass/BeanClassName/PropertyValues）<br>核心流程：</propertyvalue></p>
<pre><code><span class="number">1</span>. 初始化<span class="keyword">BeanFactory </span>同上
<span class="number">2</span>. <span class="keyword">Bean的定义 </span><span class="keyword">beanDefinition.setBeanClassName("xxxx");
</span><span class="number">3</span>. 属性设置   PropertyValues.<span class="keyword">addPropertyValue(new </span>PropertyValue(<span class="string">"name"</span>,<span class="string">"xxxxx"</span>))<span class="comment">;</span>
<span class="number">4</span>. 注册<span class="keyword">Bean </span> <span class="keyword">beanFactory.registerBeanDefinition(beanName, </span><span class="keyword">beanDefinition);
</span><span class="number">5</span>. 获取<span class="keyword">Bean </span> <span class="keyword">beanFactory.getBean(beanName);</span>
</code></pre><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(Object bean, BeanDefinition mbd)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (PropertyValue propertyValue : mbd.getPropertyValues().getPropertyValues()) &#123;</span><br><span class="line">			Field declaredField = bean.getClass().getDeclaredField(propertyValue.getName());</span><br><span class="line">			declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			declaredField.set(bean, propertyValue.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取xml配置初始化bean<br>从XML中读取BeanDefinition-将代码变为配置<br>BeanDefinitionReader-配置读取者 XmlBeanDefinitionReader extends AbstractBeanDefinitionReader implements BeanDefinitionReader<br>XmlBeanDefinitionReader-从XML中读取配置<br>读取Xml并解析 Element（name/class/property/name/value）<br>Resource-定位资源文件 UrlResource implements Resource<br>核心流程：</p>
<pre><code><span class="number">1.</span> 读取配置
<span class="number">2.</span> 初始化BeanFactory并注册bean
<span class="number">3.</span> 获取bean
</code></pre><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">XmlBeanDefinitionReader</span> xmlBeanDefinitionReader = new XmlBeanDefinitionReader(new ResourceLoader())<span class="comment">;</span></span><br><span class="line"><span class="label">xmlBeanDefinitionReader.loadBeanDefinitions</span>(<span class="string">"tinyioc.xml"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">BeanFactory </span><span class="keyword">beanFactory </span>= new AutowireCapableBeanFactory()<span class="comment">;</span></span><br><span class="line"><span class="label">for</span> (<span class="preprocessor">Map</span>.Entry&lt;<span class="keyword">String, </span><span class="keyword">BeanDefinition&gt; </span><span class="keyword">beanDefinitionEntry </span>: xmlBeanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">	<span class="keyword">beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), </span><span class="keyword">beanDefinitionEntry.getValue());</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>为bean注入bean - 解析依赖<br>BeanReference-保存对Bean的引用 （name/bean）<br>getBean()中调用createBean()-lazy-init<br>XmlBeanDefinitionReader-解析XML的时候增加bean的关联依赖</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//<span class="type">XmlBeanDefinitionReader</span></span><br><span class="line">private <span class="type">void</span> processProperty(<span class="type">Element</span> ele, <span class="type">BeanDefinition</span> beanDefinition) &#123;</span><br><span class="line">		<span class="type">NodeList</span> propertyNode = ele.getElementsByTagName(<span class="string">"property"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; propertyNode.getLength(); i++) &#123;</span><br><span class="line">			<span class="type">Node</span> node = propertyNode.item(i);</span><br><span class="line">			<span class="keyword">if</span> (node instanceof <span class="type">Element</span>) &#123;</span><br><span class="line">				<span class="type">Element</span> propertyEle = (<span class="type">Element</span>) node;</span><br><span class="line">				<span class="type">String</span> name = propertyEle.getAttribute(<span class="string">"name"</span>);</span><br><span class="line">				<span class="type">String</span> value = propertyEle.getAttribute(<span class="string">"value"</span>);</span><br><span class="line">				<span class="keyword">if</span> (value != null &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					beanDefinition.getPropertyValues().addPropertyValue(new <span class="type">PropertyValue</span>(name, value));</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="type">String</span> <span class="keyword">ref</span> = propertyEle.getAttribute(<span class="string">"ref"</span>);</span><br><span class="line">					<span class="keyword">if</span> (<span class="keyword">ref</span> == null || <span class="keyword">ref</span>.length() == <span class="number">0</span>) &#123;</span><br><span class="line">						throw new <span class="type">IllegalArgumentException</span>(<span class="string">"Configuration problem: &lt;property&gt; element for property '"</span></span><br><span class="line">								+ name + <span class="string">"' must specify a ref or value"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="type">BeanReference</span> beanReference = new <span class="type">BeanReference</span>(<span class="keyword">ref</span>);</span><br><span class="line">					beanDefinition.getPropertyValues().addPropertyValue(new <span class="type">PropertyValue</span>(name, beanReference));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">//<span class="type">AutowireCapableBeanFactory</span>    </span><br><span class="line">protected <span class="type">void</span> applyPropertyValues(<span class="type">Object</span> bean, <span class="type">BeanDefinition</span> mbd) throws <span class="type">Exception</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">PropertyValue</span> propertyValue : mbd.getPropertyValues().getPropertyValues()) &#123;</span><br><span class="line">			<span class="type">Field</span> declaredField = bean.getClass().getDeclaredField(propertyValue.getName());</span><br><span class="line">			declaredField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">			<span class="type">Object</span> value = propertyValue.getValue();</span><br><span class="line">			<span class="keyword">if</span> (value instanceof <span class="type">BeanReference</span>) &#123;</span><br><span class="line">				<span class="type">BeanReference</span> beanReference = (<span class="type">BeanReference</span>) value;</span><br><span class="line">				value = getBean(beanReference.getName());</span><br><span class="line">			&#125;</span><br><span class="line">			declaredField.<span class="type">set</span>(bean, value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>同时为了解决循环依赖的问题，我们使用lazy-init的方式，将createBean的事情放到getBean的时候才执行<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractBeanFactory</span></span><br><span class="line">@Override</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">Object</span> getBean(<span class="keyword">String</span> name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		BeanDefinition beanDefinition = beanDefinitionMap.<span class="built_in">get</span>(name);</span><br><span class="line">		<span class="keyword">if</span> (beanDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No bean named "</span> + name + <span class="string">" is defined"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">Object</span> bean = beanDefinition.getBean();</span><br><span class="line">		<span class="keyword">if</span> (bean == <span class="keyword">null</span>) &#123;</span><br><span class="line">			bean = doCreateBean(beanDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>  核心流程：</p>
<pre><code><span class="number">1.</span> 读取配置
<span class="number">2.</span> 初始化BeanFactory并注册bean
<span class="number">3.</span> 初始化bean
<span class="number">4.</span> 获取bean
</code></pre><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line">XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">new</span> ResourceLoader());</span><br><span class="line">xmlBeanDefinitionReader.loadBeanDefinitions(<span class="string">"tinyioc.xml"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line">AbstractBeanFactory beanFactory = <span class="keyword">new</span> AutowireCapableBeanFactory();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : xmlBeanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">	beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.</span></span><br><span class="line"> beanFactory.getBean(<span class="string">"helloWorldService"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>ApplicationContext登场<br>引入ApplicationContext-包装Bean的初始化流程，对应用透明<br>BeanFactory-&gt;ApplicationContext-&gt;AbstractApplicationContext-&gt;ClassPathXmlApplicationContext<br>组合优于继承<br>refresh()-变lazy-init为提前初始化</li>
</ul>
<p>现在BeanFactory的功能齐全了，但是使用起来有点麻烦。于是我们引入熟悉的ApplicationContext接口，并在AbstractApplicationContext的refresh()方法中进行bean的初始化工作。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ClassPathXmlApplicationContext</span></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">new</span> ResourceLoader());</span><br><span class="line">		xmlBeanDefinitionReader.loadBeanDefinitions(configLocation);</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : xmlBeanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">			beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ApplicationContext</span> applicationContext = new ClassPathXmlApplicationContext(<span class="string">"tinyioc.xml"</span>);</span><br><span class="line"><span class="title">HelloWorldService</span> helloWorldService = (HelloWorldService) applicationContext.getBean(<span class="string">"helloWorldService"</span>);</span><br></pre></td></tr></table></figure>
<p>  2.Aop-做你不想做的<br>  常用的几个Aop概念<br>  MethodInvocation&lt;=Joinpoint - 切的是什么<br>  MethodInterceptor&lt;=Advice - 切了做什么<br>  Pointcut - 切哪里<br>  Aspect - 谁在切<br>  Advisor - 只有一个Advice的的Aspect(Spring独有)<br>  知道切哪 - 定义Pointcut<br>  怎么切 - 定义Advisor<br>  开始切 - Weave<br>  Spring的AOP只是方法级别的</p>
<ul>
<li>使用JDK动态代理实现AOP织入<br>先从织入开始<ol>
<li>AdvisedSupport - 保存AOP配置</li>
<li>TargetSource - 保存被代理的数据<br>织入和代理</li>
<li>AopProxy- 对目标对象做代理，在调用目标方法前线调用它</li>
<li>JdkDynamicAopProxy- 使用JDK动态代理对接口做代理</li>
<li>RelectiveMethodInvocation - 将反射的Method封装为Joinpoint</li>
</ol>
</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">testInterceptor</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// --------- helloWorldService without AOP</span></span><br><span class="line">		ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"tinyioc.xml"</span>);</span><br><span class="line">		HelloWorldService helloWorldService = (HelloWorldService) applicationContext.getBean(<span class="string">"helloWorldService"</span>);</span><br><span class="line">		helloWorldService.helloWorld();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// --------- helloWorldService with AOP</span></span><br><span class="line">		<span class="comment">// 1. 设置被代理对象(Joinpoint)</span></span><br><span class="line">		AdvisedSupport advisedSupport = <span class="keyword">new</span> AdvisedSupport();</span><br><span class="line">		TargetSource targetSource = <span class="keyword">new</span> TargetSource(helloWorldService, HelloWorldService.class);</span><br><span class="line">		advisedSupport.setTargetSource(targetSource);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 设置拦截器(Advice)</span></span><br><span class="line">		TimerInterceptor timerInterceptor = <span class="keyword">new</span> TimerInterceptor();</span><br><span class="line">		advisedSupport.setMethodInterceptor(timerInterceptor);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3. 创建代理(Proxy)</span></span><br><span class="line">		JdkDynamicAopProxy jdkDynamicAopProxy = <span class="keyword">new</span> JdkDynamicAopProxy(advisedSupport);</span><br><span class="line">		HelloWorldService helloWorldServiceProxy = (HelloWorldService) jdkDynamicAopProxy.getProxy();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 4. 基于AOP的调用</span></span><br><span class="line">		helloWorldServiceProxy.helloWorld();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function">Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">"Invocation of Method "</span> + invocation.getMethod().getName() + <span class="string">" start!"</span>);</span><br><span class="line">		Object <span class="keyword">proceed</span> = invocation.<span class="keyword">proceed</span>();</span><br><span class="line">		System.out.println(<span class="string">"Invocation of Method "</span> + invocation.getMethod().getName() + <span class="string">" end! takes "</span> + (System.nanoTime() - time)</span><br><span class="line">				+ <span class="string">" nanoseconds."</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">proceed</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于jdk的动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> AdvisedSupport advised;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">JdkDynamicAopProxy</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.advised = advised;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(getClass().getClassLoader(), <span class="keyword">new</span> Class[] &#123; advised.getTargetSource()</span><br><span class="line">				.getTargetClass() &#125;, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Object proxy, <span class="keyword">final</span> Method method, <span class="keyword">final</span> Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		MethodInterceptor methodInterceptor = advised.getMethodInterceptor();</span><br><span class="line">		<span class="keyword">return</span> methodInterceptor.invoke(<span class="keyword">new</span> ReflectiveMethodInvocation(advised.getTargetSource().getTarget(), method,</span><br><span class="line">				args));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用AspectJ管理切面<br>AspectJ 基于表达式的Java AOP扩展<br>定义Pointcut - 在哪里切<br>ClassFilter &amp; MethodMatcher - 对类和方法调用做判断<br>AspectJExpressionPointcut - 基于Aspectj表达式的Poingcut</li>
</ul>
<ul>
<li>将AOP融入Bean的创建过程<br>将AOP融入BeanFactory<br>BeanPostProcessor - 提供Bean生命周期中的扩展点<br>BeanPostProcessor - 需要先加载？ - DefaultListableBeanFactory.getBeanNamesForType(Class),按类型扫描，优先于其他Bean的初始化进行<br>BeanFactoryAware - 在Bean中获知BeanFactory<br>Advisor = Advice + Pointcut<br>AspectJAeareAdvisorAutoProxyCreator - 自动完成Pointcut扫描，并将Bean替换成Proxy实现</li>
<li>使用CGLIB进行类的织入<br>前面的JDK动态代理只能对接口进行代理，对于类则无能为力。这里我们需要一些字节码操作技术。这方面大概有几种选择：ASM，CGLib和javassist，后两者是对ASM的封装。Spring中使用了CGLib。<ul>
<li><h3 id="Tomcat">Tomcat</h3>参考前面总结的内容</li>
</ul>
</li>
</ul>
<ul>
<li><h3 id="Openfire源码_-_10天">Openfire源码 - 10天</h3></li>
<li><h3 id="Mysql_sql优化_-_3天">Mysql sql优化 - 3天</h3></li>
<li><h3 id="Java_多线程_-_？？">Java 多线程 - ？？</h3></li>
<li><h3 id="Redis">Redis</h3><p>五种数据类型</p>
<ol>
<li>String</li>
<li>List  - 链表 push/pop 栈和队列</li>
<li>Hash - 适用于存储 对象</li>
<li>Set  - 集合 并差交补操作</li>
<li>Sort Set<br><strong>★★★在正式环境中的应用★★★</strong></li>
</ol>
</li>
</ul>
<ul>
<li><h3 id="脚本经验_-_nutch启动脚本">脚本经验 - nutch启动脚本</h3></li>
<li><h3 id="Jvm调优">Jvm调优</h3><p>实战例子？？？</p>
</li>
<li><h3 id="TCP/HTTP_协议，粘包，拆包问题_Socket/ServerSocket">TCP/HTTP 协议，粘包，拆包问题 Socket/ServerSocket</h3><p>自己实现简单的web服务器 ？？？</p>
</li>
</ul>
<h2 id="2-简历准备">2.简历准备</h2><h2 id="3-工作总结">3.工作总结</h2><h2 id="4-小故事贮备">4.小故事贮备</h2><h2 id="5-职业规划">5.职业规划</h2><h2 id="6-心态调整">6.心态调整</h2><h2 id="7-准备面试">7.准备面试</h2><h3 id="常见面试题目整理">常见面试题目整理</h3><p>1.自我介绍<br>2.hashMap原理-&gt;线程安全ConcurrentHashMap原理<br>3.可重入锁- Java内存模型<br>4.volatile变量的用法<br>5.算法字符串翻转<br>6.mysqlB-树索引的优点，为什么不用二叉树<br>7.项目中有什么困难，如何解决<br>8.jvm内存模型<br>9.定义二叉树，判断此二叉树是否对称<br>10.mysql组合索引，什么时候组合索引失效<br>11.https实现过程<br>12.tcp/udp区别，tcp的三次握手<br>13.innodb和myisam区别<br>14.自己实现一个线程池，要考虑的点<br>15.目前项目中的优化<br>16.linux命令<br>17.jvm的gc机制<br>18.多线程同步怎么做<br>19.Spring的AOP是如何实现的<br>20.缓存机制，项目中用到过吗<br>21.”如果出现大面积并发，在不增加服务器的基础上，如何解决服务器响应不及时问题“。性能调优<br>22.强引用，软引用，弱引用<br>23.你对mysql熟悉吗？说说mysql索引如何建立的<br>24.什么时候使用字节流、什么时候使用字符流<br>25.适配器模式的类图知道吗？<br>26.你觉得你还有哪里比较擅长，在这次面试中没有聊起来的吗？</p>
<p>一、Java基础<br>1.String类为什么是final的。<br>2.HashMap的源码，实现原理，底层结构。<br>3.反射中，Class.forName和classloader的区别<br>4.session和cookie的区别和联系，session的生命周期，多个服务部署时session管理。<br>5.Java中的队列都有哪些，有什么区别。<br>6.Java的内存模型以及GC算法<br>7.Java7、Java8的新特性(baidu问的,好BT)<br>8.Java数组和链表两种结构的操作效率，在哪些情况下(从开头开始，从结尾开始，从中间开始)，哪些操作(插入，查找，删除)的效率高<br>9.Java内存泄露的问题调查定位：jmap，jstack的使用等等 </p>
<p>二、框架<br>1.struts1和struts2的区别<br>2.struts2和springMVC的区别<br>3.spring框架中需要引用哪些jar包，以及这些jar包的用途<br>4.srpingMVC的原理<br>5.springMVC注解的意思<br>6.spring中beanFactory和ApplicationContext的联系和区别<br>7.spring注入的几种方式<br>8.spring如何实现事物管理的<br>9.springIOC和AOP的原理<br>10.hibernate中的1级和2级缓存的使用方式以及区别原理<br>11.spring中循环注入的方式 </p>
<p>三、多线程<br>1.Java创建线程之后，直接调用start()方法和run()的区别<br>2.常用的线程池模式以及不同线程池的使用场景<br>3.newFixedThreadPool此种线程池如果线程数达到最大值后会怎么办，底层原理。<br>4.多线程之间通信的同步问题，synchronized锁的是对象，衍伸出和synchronized相关很多的具体问题，例如同一个类不同方法都有synchronized锁，一个对象是否可以同时访问。或者一个类的static构造方法加上synchronized之后的锁的影响。<br>5.了解可重入锁的含义，以及ReentrantLock 和synchronized的区别<br>6.同步的数据结构，例如concurrentHashMap的源码理解以及内部实现原理，为什么他是同步的且效率高<br>7.atomicinteger和volatile等线程安全操作的关键字的理解和使用<br>8.线程间通信，wait和notify<br>9.定时线程的使用<br>10.场景：在一个主线程中，要求有大量(很多很多)子线程执行完之后，主线程才执行完成。多种方式，考虑效率。 </p>
<p>四、网络通信<br>1.http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么。<br>2.socket通信，以及长连接，分包，连接异常断开的处理。<br>3.socket通信模型的使用，AIO和NIO。<br>4.socket框架netty的使用，以及NIO的实现原理，为什么是异步非阻塞。<br>5.同步和异步，阻塞和非阻塞。 </p>
<p>五、Linux<br>1.常用的linux下的命令<br>2.大的log文件中，统计异常出现的次数、排序，或者指定输出多少行多少列的内容。(主要考察awk)<br>3.linux下的调查问题思路：内存、CPU、句柄数、过滤、查找、模拟POST和GET请求等等场景<br>4.shell脚本中#！的作用 </p>
<p>六、数据库MySql<br>1.MySql的存储引擎的不同<br>2.单个索引、联合索引、主键索引<br>3.Mysql怎么分表，以及分表后如果想按条件分页查询怎么办(如果不是按分表字段来查询的话，几乎效率低下，无解)<br>4.分表之后想让一个id多个表是自增的，效率实现<br>5.MySql的主从实时备份同步的配置，以及原理(从库读主库的binlog)，读写分离<br>6.写SQL语句。。。<br>7.索引的数据结构，B+树<br>8.事物的四个特性，以及各自的特点（原子、隔离）等等，项目怎么解决这些问题 </p>
<p>七、设计模式(写代码)<br>1.单例模式：饱汉、饿汉。以及饿汉中的延迟加载<br>2.工厂模式、装饰者模式、观察者模式。 </p>
<p>八、算法<br>1.使用随机算法产生一个数，要求把1-1000W之间这些数全部生成。（考察高效率，解决产生冲突的问题）<br>2.两个有序数组的合并排序<br>3.一个数组的倒序<br>4.计算一个正整数的正平方根<br>5.说白了就是常见的那些查找排序算法（排序转载：<a href="http://mp.weixin.qq.com/s?__biz=MjM5MTAzMTE4Nw==&amp;mid=204838393&amp;idx=2&amp;sn=e9b50c8ef689e2cb6436110a8dc148a3&amp;scene=5#rd）" target="_blank" rel="external">http://mp.weixin.qq.com/s?__biz=MjM5MTAzMTE4Nw==&amp;mid=204838393&amp;idx=2&amp;sn=e9b50c8ef689e2cb6436110a8dc148a3&amp;scene=5#rd）</a> </p>
<p>九、缓存<br>1.为什么用缓存，用过哪些缓存，redis和memcache的区别<br>2.redis的数据结构<br>3.redis的持久化方式，以及项目中用的哪种，为什么<br>4.redis集群的理解，怎么动态增加或者删除一个节点，而保证数据不丢失。（一致性哈希问题） </p>
<p>5.Linux使用与问题分析排查</p>
<p>1）. grep，awk，sed； 是否自己写过shell脚本；<br>2）. 常见的cpu load过高，us过高，一般是什么问题。引申出是否用过top，jstat，jstack等。 常见的内存问题一般有哪些。 引申出是否用过free，top， jmap等。</p>
<ol>
<li><p>框架使用 spring aop的底层实验原理。 aop与cglib，与asm的关系。 spriong ioc的生命周期，（init-method，intilizingbean接口方法afterPropertiesSet的先后顺序）等。 Hibernate对一二级缓存的使用，Lazy-Load的理解；</p>
</li>
<li><p>数据库相关： 1. mysql存储引擎中索引的实现机制； 2.数据库事务的几种粒度； 3.行锁，表锁；乐观锁，悲观锁</p>
</li>
</ol>
<p>8.网络协议： HTTP协议； HTTPS协议，SSL协议及完整交互过程；</p>
<ol>
<li>redis redis，memcache底层客户端使用一致性Hash，看是否了解； redis的事件驱动多路复用底层实现；引申到NIO编程， 看对Netty，或mina是否了解。 如果候选者同时用过memcache，redis，看下是否了解两者在使用场景上的区别。以考察使用深度，以及是否有好奇精神。</li>
</ol>
<p>10.什么是CDN？如果实现？DNS起到什么作用？</p>
<p>1、滴滴<br>    先吐槽下滴滴面试安排，如果你通过了一面，那么就优先安排后面的面试，所以导致还没一面的人就得一直苦等。那会儿我是下午一点去的，大概到了快4点才进行一面，后面就嗖嗖嗖地过关斩将到了hr面，也算是运气不错吧。<br>交叉1面<br>垃圾回收算法<br>(代码)01矩阵，相邻的1是一个岛屿，找出所有岛屿数（递归解决）<br>有关注过开源社区吗，都看过哪些源码<br>AtomicInteger实现原理(CAS自旋)<br>synchronized和reentrantLock区别<br>介绍spring的IOC和AOP，分别如何实现(classloader、动态代理)<br>redis如何处理分布式服务器并发造成的不一致(本身就是单线程序列化的隔离级别)，如果数据库不提供隔离呢<br>OSGi的机制(因为简历写了)<br>交叉2面<br>2个鸡蛋，100高的楼，最少的次数测出鸡蛋碎掉的临界层，没碎的鸡蛋可以反复用（没做出，应该是14次，网上有解法）<br>大量字符串找出数量最多的K个，考虑内存放得下和放不下两种情况<br>解释mysql索引、b树，为啥不用平衡二叉树、红黑树(磁盘和内存的存储方式不同)<br>垃圾回收算法，为什么要分代处理<br>跳表(不熟，没继续)<br>IO(不熟，没继续)<br>epoll(不熟，没继续)<br>一致性hash<br>zookeeper如何同步配置(不熟，没继续)<br>讲下java锁的原理<br>ConcurrentHashMap原理<br>BOSS面<br>(代码)最长回文子串<br>GC停顿原因，如何降低停顿<br>JVM如何调优、参数怎么调<br>如何用工具分析jvm状态（visualVM看堆中对象的分配，对象间的引用、是否有内存泄漏，jstack看线程状态、是否死锁等等）<br>进程和线程区别<br>epoll和select区别(不熟，没继续)<br>解释mysql索引、b树<br>hr面<br>五个词来描述自己<br>长期的计划<br>兴趣爱好<br>期望薪水<br>对岗位的要求<br>已经拿到的offer<br>   hr告诉我滴滴主要还是用c和php（看来我这次算是误打误撞），然后和我说php多快呀，多容易呀，要不要到碗里来？呵呵呵<br>java岗面<br>（代码）含Double数据的list，找出最长连续递增序列的长度（连续递增比较简单，看你代码质量）<br>找出最长递增子序列的长度，说思路（dp算法，复杂度O(n)）<br>mysql中int的最大填充长度（我记得是255，被告知是错的），varchar不同编码下的存储字符个数<br>写SQL，多表连接查昨天的第二多的值<br>js题，考察闭包</p>
<p>2、美团<br>    美团的面试安排在下午，不用早起真好~ 等候区就在1楼，工作人员供了面包和一次性杯子，旁边就是运动区，有跑步机、乒乓球桌、桌上足球及一些运动器材，感觉环境还是很不错的（此处应该吐槽下京东，场面极其混乱）。<br>       面试一共三轮，会有工作人员叫名字让你进去面试，就是中间的等待有点久。每轮通过的话就会留下来接着下一面，没过的话工作人员会告诉你“很抱歉，你今天的面试已经结束了”，特别是在漫长的等待中，周围的人一个个被“很抱歉”，那个心理压力可不是一般大。然后就是全部的面试经过，大概整理了下，发现运气还不错，都可以答得上来。面试问题只是参照，面试官会根据你的简历来问针对性的问题，而你也可以引导他来问你擅长的领域，当然有些基础的东西还是必须了解的，比如jvm、spring框架、持久化框架、数据库之类的。<br>一面<br>介绍实习经历，讲项目<br>解释https (先公私钥加密，再对称加密) 为什么不直接公私钥<br>jvm中类加载过程，解释双亲委派加载，及类是在哪个加载器加载的<br>传值、传引用 传入对象引用，指向一个new的对象，问主函数里的会变吗<br>找出数组中最多的那个数，除了hashset还有没其他方法（只想到蒙特卡罗法）<br>(代码)输入合法的数字字符串，输出货币字符，就是每隔3位加个逗号，考虑边界处理<br>(代码)有1-10 10个数，和一个数sum，计算用10个数连加得到sum有多少种系数组合（递归）<br>二面<br>自我介绍，讲项目<br>spring中bean加载机制，bean生成的具体步骤<br>ioc注入的方式<br>spring何时创建applicationContext(web.xml中使用listener)<br>listener是监听哪个事件(ServletContext创建事件)<br>springMVC流程具体叙述下<br>synchronized和reentrantLock的区别，synchronized用在代码快、方法、静态方法时锁的都是什么<br>介绍ConcurrentHashMap原理，用的是哪种锁，segment有没可能增大（不会，只会增大每个segment中的entry数组）<br>如何实现高效的同步链表<br>(代码)层次遍历二叉树，偶数层输出逆序输出(队列，用一个标记记录每一层的结束，统一输出当前层)<br>三面<br>介绍实习经历，讲项目<br>(代码)给定一个字符串，写出所有可能的全排列(递归)<br>剩下的就是问一下hr面的问题：<br>怎么理解踏实，你在项目中哪儿体现到了<br>最近最有成就感的事<br>你的优点 缺点<br>最近在看的技术<br>是否写过其他个人兴趣的小项目<br>写技术博客吗，github呢<br>个人职位目标<br>    三面的面试官还是很nice的，最后的部门好像也是由三面的来挑。面试结束第二天就让签了两方，待遇也没得谈。</p>
<p>3、网易<br>   面试等待时间赶超了滴滴，上午10点等到下午两点才刚开始一面。hr面结束都5点多了，正赶上下班高峰期，公交又堵了好久，回去后感觉浑身都已经无力了。<br>一面<br>介绍了下阿里的实习项目，问了下对SOA和OSGi的认识，以及之间的关系<br>项目中遇到的最难忘的问题，如何解决的（网上搜索、问经验丰富的、断点调试跟进源码、技术论坛发帖）<br>问了擅长的java领域，针对性提问（jvm、容器、并发）<br>介绍jvm内存机制（把各个内存区域作用、回收算法、收集器分类统统说了一遍）<br>创建线程方式（实现runnable接口、集成Thread、线程池）<br>java都有哪些加锁方式（synchronized、ReentrantLock、共享锁、读写锁等）<br>想让所有线程都等到一个时刻同时执行有哪些方法（介绍了下CountDownLatch和CyclicBarrier）<br>volatile的作用（使变量对所有线程可见，同时禁止指令重排序）<br>都用过哪些java容器，LinkedList都一般都在什么时候用到（经常插入删除时、实现队列和栈时）<br>介绍ConcurrentHashMap（分段加锁，几乎每个面试都问这个。。。）<br>Object里头都有哪些方法，着重问了clone(深复制还是浅复制)、finalize（一般在什么时候用，回收时一定能被运行）<br>二面<br>问题和一面差不多，很多重复的就不说了<br>如何管理线程（介绍了各种线程池的实现）<br>如何让线程A等待线程B结束后再执行（join、单线程池），还反问单线程池真的可以吗，所以大致和他介绍了下阻塞队列的机制<br>如何优化jvm参数（堆大小、xmx一般和xms设成一样大、永久代大小、收集器选择、收集器参数、新生代对象年龄阈值等）<br>hr面<br>很少见的男hr，性格温和，谈起来很轻松愉快<br>介绍所有的项目<br>对在阿里的实习如何评价，对mentor如何评价<br>在阿里有没什么让你比较惋惜的地方（内部论坛资源非常丰富，都是大牛的知识帖，后悔看得太少）<br>喜欢何种风格的领导，是严格的技术型还是宽松的管理型<br>你的职业规划，转管理还是一直技术<br>喜欢的兴趣爱好<br>针对我写到的旅游又问了，去哪儿旅游过，通常都是如何准备一次旅行的（查各种攻略、做旅行计划，叫上小伙伴），是否写游记呢（很少），对写游记的人如何评价（为他们点赞~）<br>最近在看什么书籍呢（各种技术类书籍）<br>是否能提前来实习<br>已经拿到的offer<br>目标薪资</p>
<p>4、58赶集<br>  58就在798旁边，面试完后特地去在寒风中感受了下艺术气息。签到的时候可以看到自己笔试的分数，貌似是按分数排的面试顺序。不想更加纠结所以放弃了二面。<br>一面<br>终于遇到一位年轻且头发还算茂密的面试官了，还蛮热情的<br>闲扯了下项目<br>介绍spring的IOC和AOP，容器的概念（本质就是applicationContext管理了classloader）<br>bean的创建过程<br>手写TCP三次握手（最好把状态也写出来），每次请求的序号是如何变化的<br>TCP如何控制拥塞（拥塞窗口、慢开始、拥塞避免、快重传、快恢复）<br>（代码）N个男生，N个女生，给出所有排列方式，其满足在任意i处（范围在[0,2n-1]），0-i的女生数都大于男生数（递归实现）<br>知道哪些排序算法，介绍一下快排</p>
<p>5、京东<br>   在某天晚上突然收到第二天早上去京东面试的通知，而且用的还是电话语音，9月22日读成九点二二 是什么鬼！面试现场比较混乱，一边的人在排着队，一边是有负责人出来循环播放“XXX在吗”……当天只安排一轮面试，大约等了一小时才见到面试官，面试官貌似是做管理的，技术性问题不多。介绍完项目后提出了一些场景问你如何解决，如何实现分布式，一般在哪儿用redis等等，面试过程很短一下就结束了。回去后半夜又收二面通知，又是那个电话语音，我当时的内心是崩溃的……但是面试时间和美团的冲突了，并且根本找不到hr联系方式，京东的面试就在此止步了。</p>
<pre><code>还有几家公司的面试，要么不大合适，要么就是跪了，就不细说了。希望大伙儿都能找到满意的工作，特别是到了校招后期，心态可能会变化比较大，可以来场说走就走的短途旅行缓解下压力，不要过于苛求自己，祝一切顺利！
</code></pre><p>一面（电话面 1一个小时左右 ）<br>约投递一周后接到电话，问了大概以下问题，时间比较长了，记得不太清楚了<br>1 ArrayList和LinkedList有什么区别，能否序列化<br>2 如何判断链表是否有环<br>3 concurrentHashMap如何实现<br>4 集群服务器 如何application 共享<br>5 四个表 记录成绩，每个大约十万条记录，如何找到成绩最好的同学<br>6 AIO与BIO的区别<br>7 DirectMemory是否了解<br>8 对JVM了解多少？我当时提到了内存模型 ，他问我工作线程的内存如何释放<br>9 JVM的垃圾收集算法了解多少？有哪些垃圾收集器<br>10 是否了解红黑树<br>11 session的生命周期是多久<br>12 关于Mina框架了解多少？（因为我在项目里用到了Mina，所以提到了这个部分）<br>13 是否了解Linux<br>由于大概四个月过去了，能记住的只有这么多了。一面大概持续了一个小时吧，总的来说问题广而杂，而且会比较深入。这就是大家所谓的压力面试，面试基本在一个聊天+面试的氛围中进行。面试官的跳跃性很强，时不时地聊天，又会突然提问。印象中还有更多的问题吧，实在记不清了，而且我当时也没有全部回答上来。<br>二面（电话面 20多分钟）<br>本以为一面挂了，结果还是在几天后接到二面电话。他首先自我介绍是XX事业群的总监，基本就是聊天，没有任何技术问题。比较关心如果发offer能否全职实习的事。很轻松，也很意外。<br>三面（交叉面 30分钟）<br>第三面是杭州的电话（前两面都是北京），很明显就是大家所说的交叉面（前面的叫部门内部面试）。从他的问题中我能感觉到他完全不知道前面的面试官问过我什么问题，后来事实证明在面试系统里面应该只有评价，所以不要以为面试过的问题不会再问了。<br>1 介绍自己的项目，问我项目中用到的websocket，问我websocket有哪些优缺点<br>2 HashMap和ConcurrentHashMap的实现<br>3 JVM内存都分为哪些<br>4  是否了解数据库的索引是如何实现的<br>5  对Linux是否实践过？（几乎没有问，因为我只说我会用简单的命令）<br>三面总体说比较机械，没有过多的废话在里面，一个问题接着一个问题，不会就过，感觉有点无情。而且也没有最后的提问环节<br>四面（北京终面 1小时左右 ）<br>首先说为啥要去北京。其实我也不知道，当时以为是内推挂了，没想到收到短信邀请参加现场面试，内推的姐姐也让准备一下HR面之类的，但是我当时就觉得肯定还有一轮技术面。而且当时已经知道要拥抱变化了，所以这个技术面肯定不好过。记得去北京的时候，准备了厚厚一摞的复习资料，全部都是自己的博客总结以及自己想的问题，事实证明基本命中了技术面的全部题。<br>面试的场面就不说了，略显冷清（大家都知道原因）。被叫号后领入一个大厅，跟面试官1V1，一个小桌，一个Apple（真想问问他苹果笔记本怎么样，忍住了），桌子上有几张纸，没有很紧张。<br>首先讲了自己的项目，而且在纸上画了画结构图，项目引出的问题<br>1 BIO与NIO的区别<br>2 为什么要用Mina框架<br>3 Mina框架的实现原理<br>项目讲了很久，总得来说这个过程是我来主导的，我有意在说出了一些点，然后他就问了我相关的东西。<br>然后让我在纸上也一个HashMap的实现，set get方法，不要求线程安全。因为真的看过hashmap源代码，没什么压力，不过hash传播算法确实没写出来，不过他也不太在乎。在我写的时候，他在看我的技术博客（博客地址是我写在开放性问题里面的）。写完之后他看了一下，也没说什么，不得不说写的挺乱的，没有特意练过笔写代码，只说一个判断可以进行短路优化。<br>后面他又问我一个博客上写的问题，volatile和synchronized的区别。<br>问题不止这些，确实记不住了。后面跟他聊天中我就知道自己过了，能看出来他比较欣赏我的技术水平吧，尤其是对一些细节的掌握<br>五面（HR面 20分钟左右吧）</p>
<p>HR面嘛，大家都知道就是聊天，然后她不断对你评估。说一些问题吧<br>1 自己做过的项目<br>2 自己在大学期间有哪些做到了0到1<br>3 如果去问同学，他们会对你有什么评价<br>4 遇到了什么困难<br>5 喜欢哪个城市 </p>
<p>总结</p>
<p>以上说了那么多，当然我要说这应该只有所问的题目的一半吧，因为确实忘了。我觉得大家如果实在想知道到底都问的是什么，可以看看其他人的面经，在我看来这些问题真的差不多。我最后没有拿到阿里的offer，这不能说自己在拥抱变化，只能说自己还不够优秀，下面讲一下如何准备面试吧：<br>（1） 平时多看书，面试前看面经。有人说这不是废话吗？但我敢说大部分只做到了后半句，甚至有人都不知道还可以有面经可以看。我承认面试可以突击，可以看看别人的面经问了什么，自己查一点答案就背。但是这样在面试官前面你首先就没有自信，你会觉得那是我背的，在不断回忆的过程中怕的是背错，而不是一个正确的回答问题的过程。你以为面试官真的看不出来嘛，那他对比一下也知道谁在背了。<br>（2） 好好包装自己的项目。确实不是每个人都有很好项目，但你应该知道面试中总考的点是什么。看我的面试经历，有多次提到NIO与BIO，这是一个热门考点，但我要说的是所有的NIO与BIO问题都是我引导面试官问我的。因为我在介绍Mina框架的时候，我有意的提到NIO，那么他们马上就会去问这个知识点。所谓的项目，我觉得面试官是想知道你在项目中学习了什么。不是说你学习了哪些编写代码的规范，而是说你学到了哪些他们感兴趣的点。<br>（3）养成写博客的习惯。阿里的简历选项中有一个让提交github地址的地方，悲剧了我没有。但是我仍然想让面试官了解我，那么只能通过开放性问题了。在一个显眼的位置写上自己的博客地址。曾经在一个腾讯的面经里面看到，面试官对面试者说我们看了你全部的技术博客。博客不是让面试官看到你技术有多牛，而是让他们看你是如何学习的。把你的学习的点滴写在博客上，哪怕只是Integer类的缓存，他们一旦get到这个点，就会觉得你的学习能力很强，会对你有一个很好的印象。PS：面试我的技术官都有看过我的博客，我相信它给我加分了。<br>（4）利用好“你想问我什么？”。这个问题一般出现在面试的结尾，不要以为自己没用的，你能了解到很多。记得我在终面的时候问那个面试官“你对我的技术有些建议？我未来应该朝哪个方向努力。”他对我的面试过程以及博客进行了点评，而且把前面的面试评价给我讲了讲，简单了提了一些建议。我觉得这建议胜过读几本书。据说阿里的终面面试官一般都是P10（可能不是哈），他们是牛P了，有多少人有这样的机会去接触到这些牛人，并且给你做指导呢？有这样的机会为什么不抓住呢。</p>
<p>大概就写这么多吧，写在牛客网因为它让我学到了很多东西，我应该回馈给大家。感谢牛客的CEO叶神能给大家提供这样一个平台，大家多刷题，都能拿到理想的offer！</p>
<p><strong><a href="http://www.nowcoder.com/discuss?type=4" target="_blank" rel="external">http://www.nowcoder.com/discuss?type=4</a></strong></p>
<p>去哪儿网面试题<br>一面： 面试官先看试卷上做的题目，然后开始问<br>一面主要问的还是数据结构，算法到是没有问太多具体如下：<br>1.HashMap和TreeMap的区别以及底层实现<br>主要考散列表和红黑树的知识（HashMao用的散列表，解决冲突的方式是拉链法，TreeMap底层用的红黑树，红黑树与2-3树是一一对应的，然后简单介绍了一下这些数据结构）</p>
<p>2.有一个Person类里面有三个属性，name，sex，age。现在有一个Person数组，要求按照Person的age属性排序<br>让Person实现comparable接口，在compareTo方法中使用age作为比较条件，然后使用快排即可（Arrays.sort（）方法）<br>紧接着问，两个对象的equals方法相等，他们的hashCode可不可以不相等？<br>可以，但是不能将元素插入到HashSet中，因为相同的元素会被散列到不同的地方</p>
<p>3.SQL语句，问题我不记得了，主要考group by，count聚集函数，和having</p>
<p>4.servlet是不是单例的，为什么？怎么设计程序证明它是单例还是多例？<br>这个问题我没有回答好，我回答是servlet是多例的，为了让请求可以并发</p>
<p>5.如果一个类继承servlet，这个类需要实现那些方法<br>get和post，其他的我不记得了</p>
<p>6.linux你了解多少<br>linux一直是我的软肋，我目前只能死记硬背一下简单命令（建议如实回答）</p>
<p>7.static的使用方式，final和finally的区别<br>static可以用来修饰类，成员或者方法，然后分别描述一下各自的作用即可<br>final同样可以用来修饰类，成员或者方法，然后分别描述一下各自的作用<br>finally主要用于try-catch中，用于资源的清理工作或者执行某些必须执行的代码</p>
<p>8.用过哪些开源的jar，简述一下作用<br>回答实际情况即可</p>
<p>9.Java的堆栈有哪些区别？<br>我简单的说了一下，然后把java的内存模型简单的说了 一下，面试官还算比较满意</p>
<p>10.编码实现一个最大元素为100的阻塞队列<br>这个java的api上有demo的，大家可以翻一下，写出来后面试官很满意</p>
<p>中间穿插了其他的一下基本问题吧，象征性的问了一下项目问题不算太难<br>大概面了50分钟吧，估计一面分数很高，因为我二面不是很好</p>
<p>接着大概等了一刻钟吧，二面开始<br>二面就没有一面这么顺利了<br>1.你认为你做的最好的那个项目是哪个？<br>只要如实回答，并给出理由即可<br>你做的事导师的项目吗，你对跟着导师做项目怎么看？<br>我回答说，不如出去实习。。然后给出理由</p>
<p>2.你认为你Java哪一方面学的比较好？<br>我回答是Java集合类，结果悲剧了<br>面试官问Set接口继承了Collection，为什么要有Set接口？Set接口中比Collection中多了哪些方法？<br>好吧，这个问题我回答的不好，大家可以各抒己见</p>
<p>3.你还有哪些方面比较好呢？<br>我本来想说多线程的，后来想想还是算了，我问面试官数据结构算不算，他说算<br>然后问了红黑树的问题，问我自己实现过哪些数据结构，我回答链表，栈，队列，然后问了一句，我刚刚写的那个阻塞队列算不算？<br>面试官说算，然后就开始看代码，接着问了一个问题？生产者在await的时候会发生死锁吗？<br>我回答说不会，因为await的时候会释放已经持有的锁资源<br>又问为什么不用读写锁呢？<br>答：读写锁一般用于单个对象的cache<br>为什么不能用于数组呢？<br>答：如果用于数组，那么将会允许多个消费者并发的从队列中取元素，那么有可能会出现多个消费者消费同一个产品的现象</p>
<p>4.你的代码量不少吧<br>我写过不少代码</p>
<p>5.如何培养自己的代码风格？<br>答的一般，我回答说一般都是看iteye上和csdn上一些大牛的代码风格，然后就是java api中的demo</p>
<p>6.你看过开元框架或者jvm的源代码么<br>我当时心里一沉，玩了，阿里的二面我就是挂在这个问题上了，但是我还是如实回答了<br>我使用较多，但是底层源码看的少</p>
<p>7.你还有什么问题要问我吗？<br>于是我很诚恳的问了一个问题？<br>老师，站在您的角度，您认为我有哪些方面的知识需要加强，或者说需要特别的学习<br>面试官说，平时最好能多看看jar中的源码，google有很多优秀的开源框架，这样可以养成很好的代码风格和编程习惯</p>
<p>然后让我出去等通知，大概等了20分钟吧，hr过来了给我一份公司的FAQ，让我看几分钟，然后我问了几个问题</p>
<p>然后他说问我的期望薪酬，我大概说了一下，然后他说其实我们已经给你定薪了，然后问我的意愿，好吧，我假装深沉的说了一句，我妹妹在北京工作，我先回去征求一下父母的意见，明天早上过来。。hr说没关系，他们这几天都在这里，就这样拿到offer了</p>
<p>面试已经告一段落了。从最初的一无所有，到国庆前后4.5个offer，只能说一切来的太突然。也不打算再找其他的了，毕竟还有很多同学没有心仪的offer。各位同学也不要担心，等到后期还有三方的才是大爷。由此，在牛客也来篇百度，阿里，去哪儿，美团，网易，京东，华为的面经吧。已经拿到百度，去哪儿，华为的offer，京东offer审核中不知道是什么状态。这篇面经会很长，把心理因素，所看书籍，以及面试技巧都写进去了，最重要的是有很多题。。。<br>先自我介绍一下：水硕一枚，对互联网比较感兴趣，所以面试的都是互联网公司。无实习经历，没有参加过任何比赛，只有3等奖学金。。。唯一比较拿的出手的项目是导师的与搜索有关的项目，这个项目还是自己争取拿到的（当时老师有两个选择：一个是知识库，一个是全文检索系统。我看第二个比较有技术含量，且我比较感兴趣，就建议导师选第二个。并花了1个月时间做了个demo，并成为了项目组长）。其他专业知识可能停留在考研时的水平。。。并且一直没有找准方向，不知道想做C++还是java（本人想做C++，奈何项目全部java），完完全全的水货。自我介绍完毕，面经开始。</p>
<p>【阿里巴巴内推实习】java研发工程师<br>一面跪（30分钟），当时项目正处在技术攻关期，根本没时间复习。所以打算先试试水，了解一下面试问哪些问题，然后找准复习方向。<br>问题1：项目遇到的最大困难等几个问题。<br>问题2：说说红黑树（瞬间变sb，还没复习）。<br>问题3：大文件读取并排序（题目没弄清楚，就开始盲目说算法，后来发现他可能考察的是java内存映射文件，不过没办法当时java编程思想都没看，什么都不知道）。<br>面后总结：阿里巴巴项目占的比重较大，语言也很重要，数据结构及算法很重要。根据这三点结合自己的项目，开始复习并选择了java，毕竟项目用的java。当时的复习计划：thinking in java（语言），程序员面试宝典（笔试），深入理解java虚拟机（还是语言），算法导论（算法及数据结构，神书），计算机网络（潘爱民版，神书），剑指offer（算法，神书），unix网络编程（兴趣），设计模式（项目），数学之美与解密搜索引擎技术实战（项目）。看完这几本书基本有底了。。。<br>【阿里巴巴校招内推】java研发工程师,HR面跪,呜呜<del>一生阿里黑了。。<br>HR面跪，这个地方要注意一下，校招内推和实习内推是冲突的，如果实习内推没过校招内推是直接reject的，多亏师兄找hr以及经理求情才能有这次机会。虽然最终没有拿到offer，但是收获了自信，也受到的沉重打击。<br>    一面 （这可能是所有面试发挥最好，1小时）<br>问题1：项目难点。说了一下用到java反射机制的地方以及多线程建索引。<br>问题2：项目中用到的最复杂数据结构，回答没有。。。然后他问TreeMap听过没有，为什么查询速度会很快<br>答：treemap底层实现是红黑树，红黑树是一种平衡二叉树，它的时间复杂度是O(H)，h为树的高度，而红黑树通过它五个性质保证了树的高度为O(logn)，所以它的查询速度快(注意此处，故意提到5个性质，之前内推实习问到红黑树)。果不其然。<br>问题3：红黑树的5个性质是什么，快速回答之。<br>问题4：Object类的方法有哪些。这个问题恰巧被寝室的问到过<br>答：getClass/hashCode/equals/clone/toString/notify/notifyAll/wait/finalize<br>问题5：你刚才提到了hashCode方法，如果不重写hashCode方法会导致什么问题<br>答：java编程思想上面有，object的hashcode方法是根据内存地址来hash的，如果你需要根据对象的某个属性来存取的话，就会找不到该对象，重写hashcode一般必须重写equals。。。<br>问题6：TCP建立连接之后怎么保持连接<br>答：之前没有了解过，不知道是通过心跳包来保持连接的，随便扯了下TCP的三路握手。。。囧</del><br>问题7：说一下java集合框架<br>答：balabalabala，最后提到并发库，concurrentHashMap（当时紧张，还忘了怎么拼）。<br>问题8：concurrentHashMap为什么性能高<br>答：分段锁，16个写锁，重复读锁。并说了一下hashtable的性能为什么低（整表加锁）。<br>问题9：了解存储过程么，说一下优缺点。<br>答：无语。。。缺点还真没想过，先说的优点，缓存提高性能、精简代码、增加安全性、降低网络流量。本想蒙混过关，结果追问缺点呢。。。呃，可能就是存储过程没写好不好用吧，而且不灵活。。。= =！ 面试官：好的，下一题。。。<br>问题9：数据库优化性能<br>答：这个在java面试宝典上面有，建立索引，建立分区，尽量使用固定长度的字段，限制字段长度；增加缓存使用连接池；减少SQL语句的比较次数，限制返回的条目数。。。还有一条想不起来，面试官提示：你刚从数据库，IO，语句方面说了可以优化，还有没有其他方面可以优化呢？ 突然想到了java方面，对于反复使用的语句，使用preparedStatement。追问：preparedStatement与普通的statement有什么不同。答：preparedStatement会预先编译语句，并缓存改善性能。（阿里面试官就是不错，不仅提示，还帮总结的）。<br>问题10：简述一下tcp/ip协议<br>问题11：应用层有哪些协议<br>问题12：听过DNS劫持么<br>答：听过。。。怎么预防，不知道，随便说了个MAC地址绑定。。。无语~~后来发现潘爱民版的计算机网络上面有。<br>问题13：中国最大的DNS提供商<br>答：不知道，之后查资料发现，DNS提供商有360，阿里巴巴…好吧。。。<br>问题14：http端口，tomcat端口<br>问题15：Http响应状态号，服务器错误状态号是多少。<br>答：只知道404 not found。后来查阅发现服务器错误是5XX，请求错误是4XX，重定向是3XX，成功是2XX，消息是1XX。<br>问题16：get和post的区别<br>答：从逻辑上get是安全的，post是不安全的。get一般用于获取数据，post可以用来提交数据，如表单。追问：get不能提交数据么，可以，不过需要跟在url后面，这样安全性会降低，如果使用url传递用户名，密码的话会非常不安全，因为全部为明文的。而且get有最大长度限制，因为url每种浏览器都有一个最大长度。<br>问题17：开放性问题，如果让你设计淘宝架构，用于支持双11的访问量，你怎么设计。<br>答：1、减少http请求，将js,css文件打包成一个文件。其实还有页面静态化，之前项目有涉及。<br>2、内容分发CDN，我回答的是根据用户的IP，将用户请求负载均衡到就近的数据中心。追问：如何负载均衡？可以根据IP hash生成，根据请求响应延时负载均衡。追问：这几种负载均衡属于哪种负载均衡，答不知道。他说属于软负载均衡。然后我问他还有哪种负载均衡策略。他说还有硬负载均衡。然后我再问，这样的话是不是用软件做负载均衡就是软负载，硬件做负载均衡就是硬负载。他说也可以这么理解，哈哈。最后提示我其实可以用DNS做负载均衡，这就是内容分发的思想了。<br>3、在每个数据中心中建立缓存。web代理的思想（详见计算机网络，潘爱民版，神书，师弟师妹不要错过）。<br>4、tomcat使用短连接，或者降低keep-alive时间。追问长连接和短连接的区别，哪个版本使用长连接。（此处也故意提高短连接，这是一个面试技巧，尽量提到相关的技术）。<br>5、数据库优化，具体方法之前问过。<br>问题18：还有什么补充的。说了一下项目用到的主从复制思想。<br>    二面 （比较水，只问了30分钟，我以为挂了，失败从此开始）<br>问了下项目经历，项目，索引是怎么存储的。作为项目组长人员怎么分工的。爬虫。jdk源码（说了个hashmap），Lucene源码。一面二面总结：可能一面表现太好，二面问的比较简单，发现计算机网络，数据库，以及java并发比较重要，jdk源码，以及项目源码也很重要。二面完了，8天，杳无音讯，我以为挂了。开始新的一轮复习：补了一下网络，数据库，effective java，java并发（java并发编程实战），看jdk源码，复习项目，看lucene源码。这个时候千万别放弃。。。因为阿里状态一直不会变，特别是有些一面明显挂了得同学，状态一直是面试中，所以这时候对阿里开始有点反感。再加上看到阿里有个搜索部，而我想做搜索。最最重要的是我知道自己的性格，如果阿里过了，我肯定是提不起劲复习的，因为我喜欢搜索，所以百度是我的理想选择。总之，这个时候心里就已经放弃阿里了，开始全身心投入源码学习中了。<br>    HR面（在心情失落的状态下看了几天书之后，晚上7点突然接到电话，30分钟）<br>因为之前已经放弃阿里了，接到电话还没有反应过来。。。态度一直比较冷淡。注定失败。失败了才开始后悔放弃的太早了。。问：本科到研究生的经历<br>因为二面介绍过，所以我几句话说完。。。面试官大呼，不要那么快。。。好吧，这就是失败的开始。这个地方要注意了，没有经验的师弟师妹肯定会觉得一面问过的问题，二面问相关的可以回答的粗略一点。实际上这种想法不好，首先二面面试官根本不知道一面问的什么问题，即便是有记录也是简短的1、2条，粗略的回答会让面试官觉得你不了解，或者不自信。<br>问：兴趣爱好<br>看书。。。好吧，只说了这一点，加上当时非常累，表现出不爱说话的样子，可能面试官觉得我比较孤僻。。。兴趣爱好最好加上一条运动，因为运动容易让人觉得乐观。<br>问：项目遇到的问题相关的几个问题<br>这个同样没有回答好。。。<br>问：你还有其他什么问题<br>问了个入职培训。。。这个同样是败笔，也许是前面表现不好，这个时候问什么都是败笔。。。<br>总结：因为太累了，把话语主动权叫给了HR是一大失败。后来发现，面试也要遵循28定理。面试官只说20%的话，自己最少要说80%的话。黄金法则：80/20—你要承担起80%的谈话而面试官只会说20%。白金法则：你必须试着控制面试的节奏和话题。钻石法则：对于没有把握的问题，抛回给面试官。注意这三个法则。。。在hr跪了之后，心情极度郁闷，甚至到了睡觉突然想到hr跪了就失眠的地步。。。这个时候同学有各种内推面试，内推offer，而我其他的一个也没有（美团，网易，蘑菇街内推简历没过），压力极大。。。这个时期可能是最艰难的时期，压力大，各种口腔溃疡，各种吃不下饭，都感觉有点内分泌失调。。。感觉再这样不行，之前看过村上春树关于跑步的散文，对跑步慕名已久，借此契机就每天晚上去跑步，发现效果不错，跑步的时候还能做总结，做计划。总算调节过来了。</p>
<p>9月正式校招开始，以下面试大部分是穿插进行的，为阅读方便我还是一个公司一个公司写吧，去哪儿最爽快，面完直接发offer。<br>笔试就不说了，直接说面试。</p>
<p>【华为提前批】收到offer，我是不是精神病？<br>    笔试<br>华为笔试还是要谈一谈，在编程题做完之后，就是华为鼎鼎有名的性格测试了。第一遍性格测试到后面太捉急了，别人全部测完，我还在那测，后面几题乱选的。提交，hr看了之后让再测一遍，并提示注意前后一致。然后做完第二遍直接让走。。。路上一度以为自己真的是不是性格有点不正常，阿里hr挂，这个性格测试又跪。。。<br>    一面<br>终于还是收到面试通知，第一次去大酒店面试，有点紧张，后来发现太水了。。。我就写了2个项目，让我画了这2个项目的架构图，问会一些什么，都没细问的，就过了。。。<br>    二面，综合面试<br>也基本上没问什么问题，问家里在哪，在成都待了多久，之类的。。。。最后问面试官缺点是什么。。。说我太瘦了！ = =！！华为只要性格测试过了，被刷的概率非常小。</p>
<p>【美团】最差的三面经历，三面跪<br>    一面（1小时，面试官挺好的，不过上午面完百度被虐，下午通知4点面试等到6点才开始，这时候已经意识模糊了，遇到智力题脑袋已经不能动了）<br>1、虚拟内存的目的。我说是为了解决内存不足和提高内存利用率，他说不是，然后我给他扯了一堆原理。最后勉强算过了。。。<br>2、DNS欺诈。计算机网络有，利用dns的缓存，因为DNS是基于udp的，它不需要建立连接，导致欺骗的发生。现在已经有安全的DNS协议，好像是DNSsec，基于加密的。然后跟他扯了很多对称加密，和非对称加密，公钥私钥的概念，最后他还问我这些从哪里看的= =。<br>3、说一下TCP，建立连接，超时重传，流量控制（滑动窗口），拥塞控制（慢启动，快速重传，加法增乘法减，快速恢复）。<br>4、为什么是三路握手。这个题目刚开始吓我一跳，仔细一想，二路握手不能确保连接已经建立，四路握手的效果和三路握手是一样的。<br>5、50% 15元 60% 20元 求打折最多的金额。这个智力题，因为已经不能思考了，一直让他提示，最后差不多是他直接讲出答案的。<br>6、打印文件结构，按树形结构。写代码。。。用递归实现，然后让用非递归实现，表示不太会。。。<br>7、项目遇到的难点。<br>    二面（1小时左右）<br>concurrentHashMap的原理及结构，16个分段锁，允许写锁与读锁同时存在。<br>blockingQueue一个性能优化问题，引入缓存的概念。感觉这题出的不好。<br>看了什么书，数学之美，讲了一些与搜索相关的知识，扯了点信息熵，相对熵，互信息，以及TF-IDF算法。<br>merge rebare: git merge 会生成一个新的合并节点，而rebase不会。。。没答上<br>项目架构。<br>数组循环移位。 剑指offer上面有。<br>项目bug、性能优化。<br>    三面（好像是美团外卖的leader，较胖。可能看我不顺眼吧~~回答问题看都不看我一眼）<br>觉得最难的设计模式<br>用过异步IO没有<br>说一下nio<br>如何动态加载架包<br>一直问我知道什么，我说jvm，jdk源码，java并发，计算机网络，操作系统，数据库，搜索引擎。。。结果一个也不问，还问了我两遍会什么，感觉没有他想要的兴趣点吧，他好像对SSH比较感兴趣，我只懂一点皮毛，会用而已（没有技术含量高的项目的一定要看看spring源码）。。。嗯，还问了本科，感觉BAT不看本科只看能力，其他公司反而看重学历。。。</p>
<p>【百度】第一个offer，吓死了。。。百度看中解决问题的思路以及编码能力<br>    一面<br>只问了几个问题，两道代码题全部没有写出来，结果居然让我过了。。。面试前问过其他面过一面的同学，但是没有尝试把代码写出来，结果面试第一题就是。<br>自我介绍完，我们写写个代码吧。。。呜呜呜呜呜~~<br>问：求1~n所有不能被素数相加得到的偶数。<br>这个题之前同学说了，没想到真出一样的题，瞬间感觉要哭了。。。没办法，只能硬上了，先说了思路，先求出1~n的所有素数，然后遍历1-n的偶数看能否由任意两个素数相加获得。面试官认可思路，开始写。。。写了好久，卡在求所有素数这了。。。其实之前在leetcode写过类似代码，但是第一次在纸上写代码完全没有经验，脑袋一片空白。面试官凑过来的时候，赶紧跟他说了一下思路。。。最后写完这个函数，面试官拿过草稿纸发现漏洞百出。。。<br>问：java集合类，比较简单。。。<br>问：OSI与TCP/IP模型，哪些层相互对应。<br>问：TCP分组，TCP IP包结构。IP包头和TCP包头，哪个在外面。<br>问：既然你对多线程比较了解，写个生产者消费者吧~~<br>呜呜<del>还嘴贱的问不能用blockingqueue？，因为用阻塞队列的话就可以避免协作了，面试官想了一下，说不能。然后问有几个缓存空间。。。答：5个。。。然后在那想了很久，代码还是没写出来，被java编程思想上面那个复杂但效率高的误导 ，其实完全可以只对一个对象加锁，但是效率就低了。。。最后面试官说没时间了，就到这里了。<br>最后问我有什么问题<br>我问他我这次的表现怎么样。。。他说编码能力太差了，两道算法题全部没有写出来，哪怕求素数那个函数写出来了也行。。。感觉就是跪了得节奏。。。然后我说是的，各种边界没有考虑到。他说不是边界问题，是逻辑都错了。。。好吧，我只能说，嗯，是的，主要是第一次在纸上写代码，完全没有习惯，最后道谢，满脸失落的离开。。。不知道是我的解释起作用了还是最后的卖可怜让面试官动了恻隐之心，一面居然让我过了。。。<br>    二面，比较舒服，面完就知道应该过了<br>1、一上来就是智力题。赛马问题，在牛客网有做过，30匹马，6条跑道，没有计时器，需要最少多少次比较才能找出最快的3匹马。思路：36分成6组分别比较并排序，然后找出每组最快的马比较并排序。<br>a1 a2 a3 a4 a5 a6<br>b1 b2 b3 b4 b5 b6<br>c1 c2 c3 c4 c5 c6<br>d1 d2 d3 d4 d5 d6<br>e1 e2 e3 e4 e5 e6<br>根据上表，a1肯定是最快的。a4,a5,a6,b3,b3,b5,b6,c2,c3,c4,c5,c6以及d,e全部不可能为前3名。所以最后比较一次既能得出结果。题目可能有点出路，具体多少匹马，几个跑道记不清了。<br>2、面试官可能看我回答的太容易了，继续问了一道智力题。给定12 ，-12， 7， -7， 5， -5这6个数字，求任意数A到B的最短路径。比如12到24只要一个12就能到。1个12就是最短路径。<br>这道题比较有意思，各位可以想想。最后想了个笨办法，分别求这6个数字的两两组合，三三组合。。。到NN组合。然后将A与B的差对12取余，在这些组合中查找该余数。。。方法效率低。。。面试官提示，如果相差2，最短路径是什么？ 回答并想了之后表示还是没找到头绪。。。最后直接告诉我，2出来了，3能不能出来，3出来了1出来没有？好吧</del>没想到2也能用。。。太失败了。<br>3、最长不重复子串（最长重复子串）<br>这道题刚开始我理解错了，以为是最长不重复公共子串。。。说了一下动态规划的方法，然后发现是我理解错了，然后他在解释题目的时候，他也混乱了。。。最后让写了一道最长重复子串。还是用暴力方法O（n^3），具体方法有很多。。。各位同学可以自行百度。顺便说一下常考的字符串题型：最长公共子序列（动态规划），最长公共子串（动态规划），最长回文子串（动态规划，后缀数组），最长重复子串（后缀数组），最长不重复子串（hash,动态规划，hash+动态规划）。花了一天研究字符串题型后，京东居然问了~~哈哈。<br>4、项目问题，问了个字典大小问题。。。还算错了。= =~。<br>5、最后问了自己面试缺点，说可能太紧张了，第二题没答出来。。。最后谈了点为什么百度开百度邮箱的问题。。。<br>    三面，面试官感冒了。。。成都天气阴沉沉的，刚来确实有点受不了<br>自我介绍完直接上系统设计。。。吓屎了。<br>大访问量系统站内搜索设计。（内容分发，dns做负载均衡，缓存，zookeeper）<br>7个人 1个月完成一个项目，人员怎么分工，怎么保证项目按时完成。<br>判断IDE的括号是否匹配，需要多方面考虑（失败，没有考虑注释，往项目名称考虑了）。<br>三个问题选一个：设计模式，接口设计原则，数据库范式。选一个熟悉点的，我选的设计模式，讲一下最难的。。。<br>继续三选一：SQL注入攻击、XSS，图片盗链。选的SQL注入。<br>索引新建的方法（增量索引、全量索引），如果在索引提交的频率很高怎么办。引入缓冲区，在索引不一定立刻更新，等一段时间再更新。追问：但是有些更新需要立刻能查到怎么办？ 可以将更新写入内存，之后再将索引更新写入磁盘。lucene采用的方法。</p>
<p>【网易互联网】offer，从高中开始玩梦幻，奈何网易游戏刷我简历网易一直比较喜欢，人文关怀做的比较好，内推投的数据挖掘，简历被刷了，无奈投的java，网易java对SSH要求是精通，本来是打算不去的，但是当时一个offer也没有，只能上了。。。<br>    一面，果然是SSH<br>1、事务的隔离级别，没答上。。。= =~<br>2、struts1.0和2.0的区别，没答上。。。<br>3、struts的Action，没答上。。。说了一下servlet<br>4、单例模式和多例模式的优缺点，随便扯了点<br>5、linux命令查看文件、查找文件<br>6、java集合<br>7、java IO框架<br>8、ConcurrentHashMap<br>    二面，问的比较广<br>1、服务器端建立连接过程<br>socket bind listen accept。。。然后就不知道了，他说还有。。。<br>2、fork的特性和execute的区别<br>一次调用2次返回。。。<br>3、文件加锁<br>文件锁对其他的操作系统进程是可见的。因为java的文件加锁直接映射到了本地操作系统的加锁工具。使用isShared设置共享或独占。对映射文件可以部分加锁。<br>4、synchronized与lock的区别<br>synchronized是jvm提供的加锁，悲观锁，lock是java语言实现的，而且是乐观锁。lock实现阻塞可中断，可以设置等待时间。公平锁，锁可以绑定多个条件。<br>5、lucene基本元素<br>6、单线程下ConcurrentHashMap与hashtable性能<br>这个问题有点意思，后来一想应该是hashtable性能高点，因为它只有一个可重入锁，另外一个有16个。<br>7、进程间文件描述符<br>进程间同一个文件描述符是相同的么？这个还真不知道。。。猜测应该是不同，求大神解答。。。<br>8、分布式系统设计<br>双11类似，服务器宕机了，怎么保证用户数据不丢失。session共享服务器。<br>9、统计站点访问量<br>刚开始说采用http数据包统计。。。后来转眼一看，刚才的session共享服务器，可以使用session啊。<br>10、一级缓存与二级缓存<br>11、数据库可以使用缓存服务器吗<br>12、git创建一个分支<br>13、niginx内部实现<br>14、框架的优点<br>开发效率高，扩展性高（hibernate换数据库）。在低水平的程序员面前效率高，因为内部会有一些优化。在高水平程序员面前效率低，因为高水平程序员会根据自己需求做优化。<br>15、负载均衡实现方式<br>    HR面，诚实不吃亏？<br>难道是hr看我太诚实了，给我offer？她问我百度给我offer我会选择网易吗？我说不会<del>问我女朋友找到哪的工作，我说北京。期间说网易说成百度</del>（自我介绍背太多了。。。情不自禁就。。。 = =）。面完我一度怀疑自己情商是否有问题，回来测了一下。。。</p>
<p>【去哪儿】offer，最爽快的面试经历<br>本人离面试地点有点远，8点半。。。好吧，6点多起床跑去，结果刷二维码签到出问题了，算我迟到，11点才安排面试。太惨了~~<br>    一面<br>hashmap和treemap的区别，hashmap内部实现（说了一下1.8把entry改成了node）<br>hashmap性能优化，resize，容量，负载因子。<br>递归写斐波那契数列。。。太太简单了。。。<br>为什么需要内核态和用户态，安全性，提供统一的系统调用。。。其他的就不知道了，求大神解答。<br>项目问题<br>cpu什么时候负载特别高。计算量大的任务，线程或进程频繁切换？大量复制？<br>    二面<br>问分布式设计，我说不知道，然后问项目怎么实现分布式的，我说主从复制设计，并说了一下设计。然后面试官说不就是这样么？不是挺简单的嘛= =。<br>数据库内联和外联<br>数据库外键，为什么要用外键而不能直接存一个对应表主键。想了一会说是数据一致性的问题。<br>get和post的区别。<br>get和post可以同时发送么。完全不知道。。。扯了很多。。。说了一下自己的看法，最后问他可不可以，他说可以。<br>笔试题性能优化，重写concurrentHashMap，将数组改成队列。并设置一个值返回最大值。感觉这道题回答的他比较满意。思维还是挺快的。<br>有使用redmine管理bug么？没有。。。然后说项目遇到很多bug，但都是解决了就算了，这个确实没有考虑到。<br>计划任务返回值如何处理，还是没有考虑到。<br>人员分工，怎么保证项目按时完成。分配任务，定时询问结果，帮其解决问题。<br>    HR面<br>直接发offer，还说二面面试官评分给的比较高，特意强调了会进他部门，二面面试官是做广告搜索的。待遇还挺高15*16。。。</p>
<p>【京东商城】offer待审核是个什么状态？<br>    一面，面试官太累了，说完问题就打瞌睡，我能怎么办。。。<br>1、lucene字典结构<br>把跳链表，FST，trie 树，三叉trie树。<br>2、字符串旋转的实现（太简单了，所以让再写一道）<br>3、最长公共子串<br>之前百度遇过，动态规划解决之。。。一说完题目，面试官秒睡。。。= =！无奈提高音量继续说。然后让我说原理，画了图，讲了两遍，边讲他边睡，无奈。。。可能看我比较耐心的讲了两遍不好意思了，才出了下一道题。<br>4、suggest自动补全功能，类似于百度输入提示功能。<br>一说完题目，又秒睡。。。好吧，面试官也确实辛苦，我就让他睡，自己在那里慢慢想，慢慢画，把trie 树和三叉trie树结构以及示例都弄出来后，他醒了，让我描述了一下，然后下一道题。出完题就说他太累了，出去走走。。。<br>5、好友提示，拼音，类似于QQ的好友搜索提示。<br>第一个想法还是使用trie树，不过有个缺点就是，好友变化了需要重建trie树。让我再想想。<br>想法二是字符串前缀匹配。效率低，还让想。<br>最后使用hash。但是感觉hash效率还是有点低。。。问他通常的做法是什么，他说就是hash。<br>    二面，问的最全的，挨着简历一条一条的问，问完说，还有没有我没问到的。。。= =！！我说没有，您是问的最全的面试官了。。<br>lucene倒排索引结构<br>字典怎么查询，存储。<br>凸多边形怎么用一条线把面积分成1:2（最初没有理解题意，然后给提示，直接告诉我方法了= =！）<br>中文分词（三种方法，机械匹配，统计方法，基于规则的方法）<br>网络tcp udp，拥塞控制，滑动窗口<br>nagle算法（顺便说了clark算法）<br>让画网络状态转移图（= =！没有记，只画了后面一点点）<br>unix网络编程epoll poll的区别，书上没有epoll直接说不了解。<br>排序TF-IDF，相关度排序<br>JVM内存管理（怎么学习的，项目例子，jconsole发现bug）。<br>Git<br>一致性hash原理。<br>负载均衡：DNS，hash，响应。<br>lucene怎么实现布尔查询（交并集）。</p>
<p>虽然目标是百度做搜索。。。但是百度做java的不多，而且搜索是用的C++，所以分到流程信息管理部了，不过也算得偿所愿了，希望以后内部调岗吧。以上即为本人全部面经，各位同学加油！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-知识点总结">1.知识点总结</h2><ul>
<li><h3 id="常见面试题整理">常见面试题整理</h3><p>1.Aio和Nio区别<br>  <strong>NIO:同步非阻塞；AIO:异步非阻塞</strong><br>  <strong>同步异]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tomcat源码知识点总结]]></title>
    <link href="http://zc14.github.io/2016/01/17/Tomcat%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://zc14.github.io/2016/01/17/Tomcat知识点总结/</id>
    <published>2016-01-17T01:38:32.000Z</published>
    <updated>2016-01-17T09:57:04.075Z</updated>
    <content type="html"><![CDATA[<h2 id="基于JMX的资源管理">基于JMX的资源管理</h2><p>   JMX可用于管理一个应用程序，一种实现，一个服务，一个设备，一个用户等。<br>   标准Bean–需要修改原来的类，实现一个MBean接口，灵活性不高，但是比较容易实现。<br>   模型Bean–灵活性高，Tomcat采用的就是这种方式。最大的挑战在于告诉ModelMBean对象托管资源的哪些属性和方法可以暴露给代理。这些方法写起来还是比较复杂的，为了简化工作，Apache基金会造就了<strong>Commons Modeler</strong>。通过解析配置文件xml的形式简化代码。</p>
<h2 id="StringManager-单例模式(内部类)">StringManager-单例模式(内部类)</h2><p>   ResourceBundle-实现国际化–每个核心包下面有三个properties文件，错误的粒度最小化</p>
<h2 id="使用字符数组提单字符串–提高效率。跟自己的想法又出入，正则。">使用字符数组提单字符串–提高效率。跟自己的想法又出入，正则。</h2><h2 id="coyote_tomcat默认的连接器">coyote tomcat默认的连接器</h2><h2 id="HTTP/1-1_特性_长连接/块编码/状态码100">HTTP/1.1 特性 长连接/块编码/状态码100</h2><h2 id="采用对象池来代替频繁的对象创建工作">采用对象池来代替频繁的对象创建工作</h2><h2 id="URLClassLoader">URLClassLoader</h2><p>   File file = new File(jar文件全路径);<br>   URL url = file.toURI().toURL();<br>   URLClassLoader loader = new URLClassLoader(new URL[]{url});<br>   Class tidyClazz = loader.loadClass(所需class的含包名的全名);</p>
<h2 id="代码分模块-降低耦合度_HttpConnector–Container">代码分模块-降低耦合度 HttpConnector–Container</h2><h2 id="容器Container是在哪儿与Connector建立连接的">容器Container是在哪儿与Connector建立连接的</h2><h2 id="老版本的Pipeline_与_Valve_在新版本中是怎么流转的">老版本的Pipeline 与 Valve 在新版本中是怎么流转的</h2><h2 id="组件生命周期-观察者模式">组件生命周期-观察者模式</h2><ul>
<li>管理org.apache.catalina.Lifecycle </li>
<li>事件监听器  org.apache.catalina.LifecycleListener </li>
<li>事件  org.apache.catalina.LifecycleEvent <ul>
<li>工具类 org.apache.catalina.util.LifecycleSupport<br>Tomcat组件可以嵌套，所以启动一个大容器，小容器也跟着启动。关闭上同样的</li>
</ul>
</li>
</ul>
<h2 id="自定义类的载入器">自定义类的载入器</h2><ol>
<li>安全 WEB-INF/classes 目录及其子目录</li>
<li>灵活，支持自动重载。老版本的设计理念<strong>类载入器使用一个额外的线程来不断得检查servlet类和其他类的文件的时间戳。</strong></li>
<li>org.apache.catalina.Loader/org.apache.catalina.loader.WebappLoader</li>
<li>提供缓存功能 protected final Map<string, resourceentry=""> resourceEntries = new ConcurrentHashMap&lt;&gt;()</string,></li>
</ol>
<h2 id="后台线程的统一管理_org-apache-catalina-core-StandardContext_—_backgroundProcess(),被org-apache-catalina-core-ContainerBase类中的一个专用线程周期性地调用。">后台线程的统一管理 org.apache.catalina.core.StandardContext — <strong>backgroundProcess()</strong>,被org.apache.catalina.core.ContainerBase类中的一个专用线程周期性地调用。</h2><h2 id="Session_管理">Session 管理</h2><ol>
<li>Session管理器组件负责管理Session对象。例如，创建和销毁Session对象。Session管理器是org.apache.catalina.Manager接口的实例。</li>
<li>用了外观模式StandardSessionFacade</li>
<li>session对象可以备份，也可以换出。org.apache.catalina.session.PersistentManagerBase-Store/FileStore/JDBCStore</li>
</ol>
<h2 id="Digester库的使用">Digester库的使用</h2><p>Apache基金会子项目，用于映射配置文件，创建对象</p>
<h2 id="钩子函数-回调函数，用于不正常退出造成的数据没处理完的情况_在tomcat的Catalina类中start方法就有体现">钩子函数-回调函数，用于不正常退出造成的数据没处理完的情况  在tomcat的Catalina类中start方法就有体现</h2><p>   <strong>Runtime.getRuntime().addShutdownHook(xxx implements Runnable);</strong></p>
<h2 id="统一启动/关闭服务的_服务器Server组件和服务Service组件">统一启动/关闭服务的 服务器Server组件和服务Service组件</h2><p>   org.apache.catalina.Server—org.apache.catalina.core.StandardServer<br>   org.apache.catalina.Service—org.apache.catalina.core.StandardService<br>   另外还有与生命周期有关的方法</p>
<h2 id="参考我的另外一篇文章，在为知笔记上，可以说总结的比较全。">参考我的另外一篇文章，在为知笔记上，可以说总结的比较全。</h2>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="基于JMX的资源管理">基于JMX的资源管理</h2><p>   JMX可用于管理一个应用程序，一种实现，一个服务，一个设备，一个用户等。<br>   标准Bean–需要修改原来的类，实现一个MBean接口，灵活性不高，但是比较容易实现。<br>   模型Bean]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tomcat8 源码解读]]></title>
    <link href="http://zc14.github.io/2016/01/16/Tomcat8-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://zc14.github.io/2016/01/16/Tomcat8-源码解读/</id>
    <published>2016-01-16T02:36:59.000Z</published>
    <updated>2016-01-16T10:51:29.814Z</updated>
    <content type="html"><![CDATA[<p>关于学习tomcat源码的一些知识总结<br><a id="more"></a></p>
<h2 id="总体介绍">总体介绍</h2><p>  <em><a href="http://tomcat.apache.org/tomcat-8.0-doc/config/http.html" target="_blank" rel="external">http://tomcat.apache.org/tomcat-8.0-doc/config/http.html</a></em><br>  1.AJP性能优于HTTP，网上有很多测试案例。所以正式环境优先使用二进制数据的AJP(需要Apache/ngnix配合使用)<br>  2.官方描述简单介绍</p>
<h3 id="[Connectors-HTTP]">[Connectors-HTTP]</h3><p><strong>Each incoming request requires a thread for the duration of that request.</strong><br><em>每个请求是会有一个对应的线程去进行处理。</em> If more simultaneous requests are received than can be handled by the currently available request processing threads, additional threads will be created up to the configured maximum (the value of the <strong>maxThreads</strong> attribute). If still more simultaneous requests are received, they are stacked up inside the server socket created by the Connector, up to the configured maximum (the value of the <strong>acceptCount</strong> attribute). Any further simultaneous requests will receive “connection refused” errors, until resources are available to process them.</p>
<h3 id="[Connectors-AJP]">[Connectors-AJP]</h3><p>The AJP Connector element represents a Connector component that communicates with a web connector via the AJP protocol. This is used for cases where you wish to invisibly integrate Tomcat into an existing (or new) Apache installation, and you want Apache to handle the <strong>static content</strong> contained in the web application, and/or utilize Apache’s SSL processing.可以看出AJP需要与Apache配合使用，访问静态资源文件有优势。Tomcat的作用更适合解析处理Servlet/Jsp。</p>
<h3 id="[Executor]">[Executor]</h3><p><strong>The Executor represents a thread pool that can be shared between components in Tomcat. Historically there has been a thread pool per connector created</strong> but this allows you to share a thread pool, between (primarily) connector but also other components when those get configured to support executors.Executor代表在tomcat组件之间共享的一个线程池。历史版本一个connector有一个自己的线程池。在tomcat6改变。<br>The executor has to implement the <strong>org.apache.catalina.Executor</strong> interface.<br>The executor is a <strong>nested element to the Service element</strong>. And in order for it to be picked up by the connectors, the Executor element has to appear prior to the Connector element in <em>server.xml</em>。<br>在Service接口中有对Executor提供方法操作声明：addExecutor/findExecutors/getExecutor/removeExecutor。<br><strong>线程池是在服务中配置的，在connector之间共享的。</strong>而且如果没有传递，会有一个默认的Executor(internalExecutor)在AbstractEndpoing类中供使用。</p>
<h2 id="首先一览众山小，介绍下tomcat架构中的几个组件">首先一览众山小，介绍下tomcat架构中的几个组件</h2><ul>
<li>Server  <em>服务器，web容器，Tomcat中最大的</em></li>
<li>Service <em>web容器能提供的服务</em></li>
<li>Connector <em>请求执行的通道，拿到新请求，扔给Container</em></li>
<li>Container <em>真正做事的地方，包含赫赫有名的四大组件</em><br>  1.Engine   <em>虚拟引擎</em><br>  2.Host     <em>虚拟主机</em><br>  3.Context  <em>web application</em><br>  4.Wrapper <em>servlet</em></li>
<li>Pipeline-Valve <em>责任链的完美诠释，各种StandardEngineValve，StandardHostValve，StandardContextValve，StandardWrpperValve</em></li>
<li>LifeCycle   <em>组件生命周期接口</em></li>
<li>JMX   <em>JavaBean动态管理</em></li>
<li>Realm  <em>权限模块</em></li>
</ul>
<p><strong>额外赠送serverStartupUML类图<a href="https://tomcat.apache.org/tomcat-8.0-doc/architecture/startup/serverStartup.pdf" target="_blank" rel="external">https://tomcat.apache.org/tomcat-8.0-doc/architecture/startup/serverStartup.pdf</a></strong><br>通过阅读此pdf，结合代码，总结一下tomcat在启动过程中需要做的几件事情：<br>1.加载配置文件catalina.properties<br>2.设置classLoader，从配置文件获取类的加载路径<br>3.利用classLoader，加载org.apache.catalina.startup.Catalina.<br>4.Catalina类加载，并解析servlet.xml</p>
<h2 id="休息一下，进入源码的解读">休息一下，进入源码的解读</h2><p>从标准的server开始<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Standard implementation of the &lt;b&gt;Server&lt;/b&gt; interface, available for use</span><br><span class="line"> * (but not required) when deploying and starting Catalina.</span><br><span class="line"> */</span></span><br><span class="line">public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardServer</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">LifecycleMBeanBase</span> <span class="title">implements</span> <span class="title">Server</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span><br><span class="line">     * The set of Services associated with this Server.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Service</span> services[] = <span class="keyword">new</span> <span class="type">Service</span>[<span class="number">0</span>];<span class="comment">//当前Server拥有的Service</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> servicesLock = <span class="keyword">new</span> <span class="type">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Add a new Service to the set of defined Services.</span><br><span class="line">     *</span><br><span class="line">     * @param service The Service to be added</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    public void addService(<span class="type">Service</span> service) &#123;</span><br><span class="line">	......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Standard implementation of the &lt;code&gt;Service&lt;/code&gt; interface.  The</span><br><span class="line"> * associated Container is generally an instance of Engine, but this is</span><br><span class="line"> * not required.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StandardService</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">LifecycleMBeanBase</span> <span class="title">implements</span> <span class="title">Service</span> &#123;</span></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">     * The &lt;code&gt;Server&lt;/code&gt; that owns this Service, if any.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Server</span> server = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/**</span><br><span class="line">     * The set of Connectors associated with this Service.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Connector</span> connectors[] = <span class="keyword">new</span> <span class="type">Connector</span>[<span class="number">0</span>];<span class="comment">//当前Service拥有的Connector</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> connectorsLock = <span class="keyword">new</span> <span class="type">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">ArrayList</span>&lt;<span class="type">Executor</span>&gt; executors = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();<span class="comment">//这个服务配置的线程池，可在多个Connector之间共享</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span><br><span class="line">     * The Container associated with this Service.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Container</span> container = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上文提到的官方启动UML类图,我们先从Connector开始入手<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Implementation of a Coyote connector.</span><br><span class="line"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Connector</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">LifecycleMBeanBase</span>  &#123;</span></span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/**</span><br><span class="line">     * Coyote Protocol handler class name.</span><br><span class="line">     * Defaults to the Coyote HTTP/1.1 protocolHandler.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> protocolHandlerClassName =</span><br><span class="line">        <span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span>;</span><br><span class="line"></span><br><span class="line">  public <span class="type">Connector</span>(<span class="type">String</span> protocol) &#123;</span><br><span class="line">        setProtocol(protocol);</span><br><span class="line">        <span class="comment">// Instantiate protocol handler</span></span><br><span class="line">        <span class="type">ProtocolHandler</span> p = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span>&lt;?&gt; clazz = <span class="type">Class</span>.forName(protocolHandlerClassName);</span><br><span class="line">            p = (<span class="type">ProtocolHandler</span>) clazz.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">Exception</span> e) &#123;</span><br><span class="line">            log.error(sm.getString(</span><br><span class="line">                    <span class="string">"coyoteConnector.protocolHandlerInstantiationFailed"</span>), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.protocolHandler = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="type">Globals</span>.<span class="type">STRICT_SERVLET_COMPLIANCE</span>) &#123;</span><br><span class="line">            <span class="type">URIEncoding</span> = <span class="string">"UTF-8"</span>;</span><br><span class="line">            <span class="type">URIEncodingLower</span> = <span class="type">URIEncoding</span>.toLowerCase(<span class="type">Locale</span>.<span class="type">ENGLISH</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Coyote protocol handler.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">ProtocolHandler</span> protocolHandler;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void initInternal() <span class="keyword">throws</span> <span class="type">LifecycleException</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize adapter</span></span><br><span class="line">        adapter = <span class="keyword">new</span> <span class="type">CoyoteAdapter</span>(<span class="keyword">this</span>);</span><br><span class="line">        protocolHandler.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure parseBodyMethodsSet has a default</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="literal">null</span> == parseBodyMethodsSet ) &#123;</span><br><span class="line">            setParseBodyMethods(getParseBodyMethods());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (protocolHandler.isAprRequired() &amp;&amp;</span><br><span class="line">                !<span class="type">AprLifecycleListener</span>.isAprAvailable()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">LifecycleException</span>(</span><br><span class="line">                    sm.getString(<span class="string">"coyoteConnector.protocolHandlerNoApr"</span>,</span><br><span class="line">                            getProtocolHandlerClassName()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            protocolHandler.init();<span class="comment">//方法核心ProtocolHandler.init</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">Exception</span> e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">LifecycleException</span></span><br><span class="line">                (sm.getString</span><br><span class="line">                 (<span class="string">"coyoteConnector.protocolHandlerInitializationFailed"</span>), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Begin processing requests via this Connector.</span><br><span class="line">     *</span><br><span class="line">     * @exception LifecycleException if a fatal startup error occurs</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void startInternal() <span class="keyword">throws</span> <span class="type">LifecycleException</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Validate settings before starting</span></span><br><span class="line">        <span class="keyword">if</span> (getPort() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">LifecycleException</span>(sm.getString(</span><br><span class="line">                    <span class="string">"coyoteConnector.invalidPort"</span>, <span class="type">Integer</span>.valueOf(getPort())));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setState(<span class="type">LifecycleState</span>.<span class="type">STARTING</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            protocolHandler.start();<span class="comment">//方法核心ProtocolHandler.start</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">Exception</span> e) &#123;</span><br><span class="line">            <span class="type">String</span> errPrefix = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.service != <span class="literal">null</span>) &#123;</span><br><span class="line">                errPrefix += <span class="string">"service.getName(): \""</span> + <span class="keyword">this</span>.service.getName() + <span class="string">"\"; "</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">LifecycleException</span></span><br><span class="line">                (errPrefix + <span class="string">" "</span> + sm.getString</span><br><span class="line">                 (<span class="string">"coyoteConnector.protocolHandlerStartFailed"</span>), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProtocolHandler是干嘛的，接着跟代码<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Abstract the protocol implementation, including threading, etc.</span><br><span class="line"> * Processor is single threaded and specific to stream-based protocols,</span><br><span class="line"> * will not fit Jk protocols like JNI.</span><br><span class="line"> *</span><br><span class="line"> * This is the main interface to be implemented by a coyote connector.</span><br><span class="line"> * Adapter is the main interface to be implemented by a coyote servlet</span><br><span class="line"> * container.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ProtocolHandler</span> &#123;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/**</span><br><span class="line">     * The adapter, used to call the connector.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdapter</span>(<span class="params">Adapter adapter</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * The executor, provide access to the underlying thread pool.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这边走到头了，返回上个类Connector，定位到protocolHandlerClassName = “org.apache.coyote.http11.Http11NioProtocol”，我们来看看Http11NioProtocol<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Abstract the protocol implementation, including threading, etc.</span><br><span class="line"> * Processor is single threaded and specific to stream-based protocols,</span><br><span class="line"> * will not fit Jk protocols like JNI.</span><br><span class="line"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Http11NioProtocol</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractHttp11JsseProtocol&lt;NioChannel&gt;</span> &#123;</span></span><br><span class="line">  public <span class="type">Http11NioProtocol</span>() &#123;</span><br><span class="line">        endpoint=<span class="keyword">new</span> <span class="type">NioEndpoint</span>();<span class="comment">//核心代码</span></span><br><span class="line">        cHandler = <span class="keyword">new</span> <span class="type">Http11ConnectionHandler</span>(<span class="keyword">this</span>);<span class="comment">//核心代码</span></span><br><span class="line">        ((<span class="type">NioEndpoint</span>) endpoint).setHandler(cHandler);</span><br><span class="line">        setSoLinger(<span class="type">Constants</span>.<span class="type">DEFAULT_CONNECTION_LINGER</span>);</span><br><span class="line">        setSoTimeout(<span class="type">Constants</span>.<span class="type">DEFAULT_CONNECTION_TIMEOUT</span>);</span><br><span class="line">        setTcpNoDelay(<span class="type">Constants</span>.<span class="type">DEFAULT_TCP_NO_DELAY</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过构造函数发现，在Http11NioProtocol中使用的是NioEndpoint，为这个endpoint指定的Handler是Http11ConnectionHandler类型。继续追踪父类<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHttp11JsseProtocol</span>&lt;<span class="title">S</span>&gt;</span><br><span class="line">        <span class="keyword">extends</span> <span class="title">AbstractHttp11Protocol</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不是不写注释，源码中并未添加对这个类的注解，可见这个类也不是核心，查看代码可知基本是setter和getter，接着跟<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHttp11Protocol&lt;S&gt;</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractProtocol&lt;S&gt;</span> &#123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProtocol</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">ProtocolHandler</span>,</span><br><span class="line">        <span class="title">MBeanRegistration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Endpoint that provides low-level network I/O - must be matched to the</span><br><span class="line">     * ProtocolHandler implementation (ProtocolHandler using BIO, requires BIO</span><br><span class="line">     * Endpoint etc.).</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> AbstractEndpoint&lt;S&gt; endpoint = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * The adapter provides the link between the ProtocolHandler and the</span><br><span class="line">     * connector.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Adapter adapter;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> MBeanServer mserver;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// ------------------------------------------------------- Lifecycle methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * <span class="doctag">NOTE:</span> There is no maintenance of state or checking for valid transitions</span><br><span class="line">     * within this class. It is expected that the connector will maintain state</span><br><span class="line">     * and prevent invalid state transitions.</span><br><span class="line">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getLog().isInfoEnabled())</span><br><span class="line">            getLog().info(sm.getString(<span class="string">"abstractProtocolHandler.init"</span>,</span><br><span class="line">                    getName()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oname == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Component not pre-registered so register it</span></span><br><span class="line">            oname = createObjectName();</span><br><span class="line">            <span class="keyword">if</span> (oname != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(<span class="keyword">this</span>, oname,</span><br><span class="line">                    <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.domain != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                tpOname = <span class="keyword">new</span> ObjectName(domain + <span class="string">":"</span> +</span><br><span class="line">                        <span class="string">"type=ThreadPool,name="</span> + getName());</span><br><span class="line">                Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(endpoint,</span><br><span class="line">                        tpOname, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                getLog().<span class="keyword">error</span>(sm.getString(</span><br><span class="line">                        <span class="string">"abstractProtocolHandler.mbeanRegistrationFailed"</span>,</span><br><span class="line">                        tpOname, getName()), e);</span><br><span class="line">            &#125;</span><br><span class="line">            rgOname=<span class="keyword">new</span> ObjectName(domain +</span><br><span class="line">                    <span class="string">":type=GlobalRequestProcessor,name="</span> + getName());</span><br><span class="line">            Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(</span><br><span class="line">                    getHandler().getGlobal(), rgOname, <span class="keyword">null</span> );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String endpointName = getName();</span><br><span class="line">        endpoint.setName(endpointName.substring(<span class="number">1</span>, endpointName.length()-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            endpoint.init();<span class="comment">//核心代码，endpoint.init</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            getLog().<span class="keyword">error</span>(sm.getString(<span class="string">"abstractProtocolHandler.initError"</span>,</span><br><span class="line">                    getName()), ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getLog().isInfoEnabled())</span><br><span class="line">            getLog().info(sm.getString(<span class="string">"abstractProtocolHandler.start"</span>,</span><br><span class="line">                    getName()));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            endpoint.start();<span class="comment">//核心代码，endpoint.start</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            getLog().<span class="keyword">error</span>(sm.getString(<span class="string">"abstractProtocolHandler.startError"</span>,</span><br><span class="line">                    getName()), ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码上看AbstractProtocol本身并不做太多请求解析处理相关的事情，它是把事情委托给了一个AbstractEndpoint对象来完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEndpoint</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * counter for nr of connections handled by an endpoint</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> LimitLatch connectionLimitLatch = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Threads used to accept new connections and pass them to worker threads.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Acceptor[] acceptors;<span class="comment">//意义很明确，接收新链接，扔给工作线程去执行。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//典型的模板方法，从createAcceptor()由子类去实现可以看出。骨架+钩子函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startAcceptorThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = getAcceptorThreadCount();</span><br><span class="line">        acceptors = <span class="keyword">new</span> Acceptor[count];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            acceptors[i] = createAcceptor();<span class="comment">//核心</span></span><br><span class="line">            String threadName = getName() + <span class="string">"-Acceptor-"</span> + i;</span><br><span class="line">            acceptors[i].setThreadName(threadName);</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(acceptors[i], threadName);</span><br><span class="line">            t.setPriority(getAcceptorThreadPriority());</span><br><span class="line">            t.setDaemon(getDaemon());<span class="comment">//true 守护线程</span></span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Hook to allow Endpoints to provide a specific Acceptor implementation.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Acceptor <span class="title">createAcceptor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxConnections = <span class="number">10000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Are we using an internal executor</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> internalExecutor = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * External Executor based thread pool.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> Executor executor = <span class="keyword">null</span>;<span class="comment">//此线程池可由外部指定，如果外部不指定，则由AbstractEndpoint自己来创建。由参数internalExecutor决定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExecutor</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">        <span class="keyword">this</span>.internalExecutor = (executor == <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> executor; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//AbstractEndpoint自己创建线程池的实现方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        internalExecutor = <span class="keyword">true</span>;</span><br><span class="line">        TaskQueue taskqueue = <span class="keyword">new</span> TaskQueue();</span><br><span class="line">        TaskThreadFactory tf = <span class="keyword">new</span> TaskThreadFactory(getName() + <span class="string">"-exec-"</span>, daemon, getThreadPriority());</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), <span class="number">60</span>, TimeUnit.SECONDS,taskqueue, tf);</span><br><span class="line">        taskqueue.setParent( (ThreadPoolExecutor) executor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Allows the server developer to specify the backlog that</span><br><span class="line">     * should be used for server sockets. By default, this value</span><br><span class="line">     * is 100.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> backlog = <span class="number">100</span>;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// ------------------------------------------------------- Lifecycle methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * <span class="doctag">NOTE:</span> There is no maintenance of state or checking for valid transitions</span><br><span class="line">     * within this class other than ensuring that bind/unbind are called in the</span><br><span class="line">     * right place. It is expected that the calling code will maintain state and</span><br><span class="line">     * prevent invalid state transitions.</span><br><span class="line">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        testServerCipherSuitesOrderSupport();</span><br><span class="line">        <span class="keyword">if</span> (bindOnInit) &#123;</span><br><span class="line">            bind();</span><br><span class="line">            bindState = BindState.BOUND_ON_INIT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bindState == BindState.UNBOUND) &#123;</span><br><span class="line">            bind();</span><br><span class="line">            bindState = BindState.BOUND_ON_START;</span><br><span class="line">        &#125;</span><br><span class="line">        startInternal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Http11NioProtocol的构造函数中指定的是使用NioEndpoint实例，因此这里通过分析AbstractEndpoint的子类NioEndpoint来做进一步的了解。这个是个加工厂，用于组装<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * NIO tailored thread pool, providing the following services:</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> * &lt;li&gt;Socket acceptor thread&lt;/li&gt;</span><br><span class="line"> * &lt;li&gt;Socket poller thread&lt;/li&gt;</span><br><span class="line"> * &lt;li&gt;Worker threads pool&lt;/li&gt;</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> *</span><br><span class="line"> * When switching to Java 5, there's an opportunity to use the virtual</span><br><span class="line"> * machine's thread pool.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEndpoint</span> <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------- Acceptor Inner Class</span></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * The background thread that listens for incoming TCP/IP connections and</span><br><span class="line">     * hands them off to an appropriate processor.</span><br><span class="line">     * Acceptor负责接收网络请求，建立连接。连接建立之后，将这个socket连接交给Poller。由Poller来负责执行数据的读取和业务执行</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span>.<span class="title">Acceptor</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span><br><span class="line">     * Process the specified connection.</span><br><span class="line">     * setSocketOptions方法是专门处理特定socket连接的方法，将一个SocketChannel对象包装成一个NioChannel之后，注册到Poller中</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">setSocketOptions</span><span class="params">(SocketChannel socket)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Process the connection</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//disable blocking, APR style, we are gonna be polling it</span></span><br><span class="line">            socket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            Socket sock = socket.socket();</span><br><span class="line">            socketProperties.setProperties(sock);</span><br><span class="line"></span><br><span class="line">            NioChannel channel = nioChannels.pop();</span><br><span class="line">            <span class="keyword">if</span> ( channel == <span class="keyword">null</span> ) &#123;</span><br><span class="line">                <span class="comment">// SSL setup</span></span><br><span class="line">                <span class="keyword">if</span> (sslContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// normal tcp setup</span></span><br><span class="line">                    NioBufferHandler bufhandler = <span class="keyword">new</span> NioBufferHandler(socketProperties.getAppReadBufSize(),</span><br><span class="line">                                                                       socketProperties.getAppWriteBufSize(),</span><br><span class="line">                                                                       socketProperties.getDirectBuffer());</span><br><span class="line"></span><br><span class="line">                    channel = <span class="keyword">new</span> NioChannel(socket, bufhandler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel.setIOChannel(socket);</span><br><span class="line">                <span class="keyword">if</span> ( channel <span class="keyword">instanceof</span> SecureNioChannel ) &#123;</span><br><span class="line">                    SSLEngine engine = createSSLEngine();</span><br><span class="line">                    ((SecureNioChannel)channel).reset(engine);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    channel.reset();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            getPoller0().register(channel);<span class="comment">//注册</span></span><br><span class="line">            <span class="comment">//getPoller0是从在startInternal方法中初始化的pollsers数组中取一个poller。然后通过Poller对象的register方法把这个channel注册到此Poller对象上。pollers数组的大小是根据当前的运行环境计算出来的，无法通过配置修改。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(t);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.<span class="keyword">error</span>(<span class="string">""</span>,t);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable tt) &#123;</span><br><span class="line">                ExceptionUtils.handleThrowable(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Tell to close the socket</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span><br><span class="line">     * Return an available poller in true round robin fashion 轮训调度方式</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Poller <span class="title">getPoller0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = Math.abs(pollerRotater.incrementAndGet()) % pollers.length;</span><br><span class="line">        <span class="keyword">return</span> pollers[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Poller class.</span><br><span class="line">     * 初始化pollers数组，同时启动pollers数组中的线程，让pollers开始工作。</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Selector selector;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> SynchronizedQueue&lt;PollerEvent&gt; events =</span><br><span class="line">                <span class="keyword">new</span> SynchronizedQueue&lt;&gt;();<span class="comment">//PollerEvent完成channel对selector的事件注册，具体可见代码</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">/**</span><br><span class="line">         * The background thread that listens for incoming TCP/IP connections and</span><br><span class="line">         * hands them off to an appropriate processor.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Loop until destroy() is called</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Loop if endpoint is paused</span></span><br><span class="line">                    <span class="keyword">while</span> (paused &amp;&amp; (!close) ) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="comment">// Ignore</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">boolean</span> hasEvents = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Time to terminate?</span></span><br><span class="line">                    <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                        events();</span><br><span class="line">                        timeout(<span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            selector.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                            log.<span class="keyword">error</span>(sm.getString(</span><br><span class="line">                                    <span class="string">"endpoint.nio.selectorCloseFail"</span>), ioe);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        hasEvents = events();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> ( !close ) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (wakeupCounter.getAndSet(-<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//if we are here, means we have other stuff to do</span></span><br><span class="line">                                <span class="comment">//do a non blocking select</span></span><br><span class="line">                                keyCount = selector.selectNow();</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                keyCount = selector.select(selectorTimeout);</span><br><span class="line">                            &#125;</span><br><span class="line">                            wakeupCounter.set(<span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                            events();</span><br><span class="line">                            timeout(<span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                selector.close();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                                log.<span class="keyword">error</span>(sm.getString(</span><br><span class="line">                                        <span class="string">"endpoint.nio.selectorCloseFail"</span>), ioe);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        ExceptionUtils.handleThrowable(x);</span><br><span class="line">                        log.<span class="keyword">error</span>(<span class="string">""</span>,x);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//either we timed out or we woke up, process events first</span></span><br><span class="line">                    <span class="keyword">if</span> ( keyCount == <span class="number">0</span> ) hasEvents = (hasEvents | events());</span><br><span class="line"><span class="comment">//正常状态下的数据处理，通过processKey来实现。获取对应的渠道的key，然后调用processKey方法</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">                        keyCount &gt; <span class="number">0</span> ? selector.selectedKeys().iterator() : <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// Walk through the collection of ready keys and dispatch</span></span><br><span class="line">                    <span class="comment">// any active event.</span></span><br><span class="line">                    <span class="keyword">while</span> (iterator != <span class="keyword">null</span> &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">                        SelectionKey sk = iterator.next();</span><br><span class="line">                        KeyAttachment attachment = (KeyAttachment)sk.attachment();</span><br><span class="line">                        <span class="comment">// Attachment may be null if another thread has called</span></span><br><span class="line">                        <span class="comment">// cancelledKey()</span></span><br><span class="line">                        <span class="keyword">if</span> (attachment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            iterator.remove();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            attachment.access();</span><br><span class="line">                            iterator.remove();</span><br><span class="line">                            processKey(sk, attachment);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//process timeouts</span></span><br><span class="line">                    timeout(keyCount,hasEvents);</span><br><span class="line">                    <span class="keyword">if</span> ( oomParachute &gt; <span class="number">0</span> &amp;&amp; oomParachuteData == <span class="keyword">null</span> ) checkParachute();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (OutOfMemoryError oom) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        oomParachuteData = <span class="keyword">null</span>;</span><br><span class="line">                        releaseCaches();</span><br><span class="line">                        log.<span class="keyword">error</span>(<span class="string">""</span>, oom);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> ( Throwable oomt ) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.err.println(oomParachuteMsg);</span><br><span class="line">                            oomt.printStackTrace();</span><br><span class="line">                        &#125;<span class="keyword">catch</span> (Throwable letsHopeWeDontGetHere)&#123;</span><br><span class="line">                            ExceptionUtils.handleThrowable(letsHopeWeDontGetHere);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">            stopLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//processKey的主要工作是调用NioEndpoint的processSocket来实现socket的读写</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">processKey</span><span class="params">(SelectionKey sk, KeyAttachment attachment)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> ( isWorkerAvailable() ) &#123;</span><br><span class="line">                                unreg(sk, attachment, sk.readyOps());</span><br><span class="line">                                <span class="keyword">boolean</span> closeSocket = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="comment">// Read goes before write</span></span><br><span class="line">                                <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (!processSocket(attachment, SocketStatus.OPEN_READ, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                                        closeSocket = <span class="keyword">true</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (!closeSocket &amp;&amp; sk.isWritable()) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (!processSocket(attachment, SocketStatus.OPEN_WRITE, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                                        closeSocket = <span class="keyword">true</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (closeSocket) &#123;</span><br><span class="line">                                    cancelledKey(sk,SocketStatus.DISCONNECT);</span><br><span class="line">                                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">processSocket</span><span class="params">(KeyAttachment attachment, SocketStatus status, <span class="keyword">boolean</span> dispatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (attachment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            SocketProcessor sc = processorCache.pop();</span><br><span class="line">            <span class="keyword">if</span> ( sc == <span class="keyword">null</span> ) sc = <span class="keyword">new</span> SocketProcessor(attachment, status);</span><br><span class="line">            <span class="function"><span class="keyword">else</span> sc.<span class="title">reset</span><span class="params">(attachment, status)</span></span>;</span><br><span class="line">            Executor executor = getExecutor();<span class="comment">//使用线程池--整个的流程client-&gt;Acceptor-&gt;Poller-&gt;Socket Processor（Executor）</span></span><br><span class="line">            <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                executor.execute(sc);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sc.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException ree) &#123;</span><br><span class="line">            log.warn(sm.getString(<span class="string">"endpoint.executor.fail"</span>, attachment.getSocket()), ree);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(t);</span><br><span class="line">            <span class="comment">// This means we got an OOM or similar creating a thread, or that</span></span><br><span class="line">            <span class="comment">// the pool and its queue are full</span></span><br><span class="line">            log.<span class="keyword">error</span>(sm.getString(<span class="string">"endpoint.process.fail"</span>), t);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ---------------------------------------------- SocketProcessor Inner Class</span></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * This class is the equivalent of the Worker, but will simply use in an</span><br><span class="line">     * external Executor thread pool.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketProcessor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Initialize the endpoint.监听端口</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        serverSock = ServerSocketChannel.open();</span><br><span class="line">        socketProperties.setProperties(serverSock.socket());</span><br><span class="line">        InetSocketAddress addr = (getAddress()!=<span class="keyword">null</span>?<span class="keyword">new</span> InetSocketAddress(getAddress(),getPort()):<span class="keyword">new</span> InetSocketAddress(getPort()));</span><br><span class="line">        serverSock.socket().bind(addr,getBacklog());</span><br><span class="line">        serverSock.configureBlocking(<span class="keyword">true</span>); <span class="comment">//mimic APR behavior</span></span><br><span class="line">        serverSock.socket().setSoTimeout(getSocketProperties().getSoTimeout());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize thread count defaults for acceptor, poller</span></span><br><span class="line">        <span class="keyword">if</span> (acceptorThreadCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">FIXME:</span> Doesn't seem to work that well with multiple accept threads</span></span><br><span class="line">            acceptorThreadCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pollerThreadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//minimum one poller thread</span></span><br><span class="line">            pollerThreadCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stopLatch = <span class="keyword">new</span> CountDownLatch(pollerThreadCount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize SSL if needed</span></span><br><span class="line">        <span class="keyword">if</span> (isSSLEnabled()) &#123;</span><br><span class="line">           ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oomParachute&gt;<span class="number">0</span>) reclaimParachute(<span class="keyword">true</span>);</span><br><span class="line">        selectorPool.open();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Start the NIO endpoint, creating acceptor, poller threads.</span><br><span class="line">     * 初始化线程池，创建和启动网络数据接收线程组，创建和启动poller线程组</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">            running = <span class="keyword">true</span>;</span><br><span class="line">            paused = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            processorCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                    socketProperties.getProcessorCache());</span><br><span class="line">            eventCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                            socketProperties.getEventCache());</span><br><span class="line">            nioChannels = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                    socketProperties.getBufferPool());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create worker collection</span></span><br><span class="line">            <span class="keyword">if</span> ( getExecutor() == <span class="keyword">null</span> ) &#123;</span><br><span class="line">                createExecutor();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            initializeConnectionLatch();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start poller threads</span></span><br><span class="line">            pollers = <span class="keyword">new</span> Poller[getPollerThreadCount()];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class="line">                pollers[i] = <span class="keyword">new</span> Poller();</span><br><span class="line">                Thread pollerThread = <span class="keyword">new</span> Thread(pollers[i], getName() + <span class="string">"-ClientPoller-"</span>+i);</span><br><span class="line">                pollerThread.setPriority(threadPriority);</span><br><span class="line">                pollerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                pollerThread.start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            startAcceptorThreads();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结一下：<br>[Acceptor]：<br>     负责监听并接收socket连接建立。由Acceptor来控制与服务端建立连接的客户端socket数目。具体的数目为一个服务可配置项，可以在启动服务时指定.默认的配置在AbstractEndpoint中，初始值为10000</p>
<p>[Poller]：<br>     负责处理已建立连接的socket，将channel封装后，提交至线程池（Executors）来处理。Poller线程的数目与运行时环境有关，通过计算得出，不可配置。</p>
<p>[Executors]：<br>     处理socket请求的线程池。线程池中线程的数目可在启动服务时配置。<br>socket.getPoller()返回这个channel所注册的Poller对象。getSelector()返回这个Poller对象的selector。注册之后，当这个socket的channel有数据到达，便能通过selector.select活selector.selectNow被返回，放入到Executor中进行处理。</p>
<p>继续<br>在Http11NioProtocol构造函数中有个Http11ConnectionHandler我们还没分析，下面来看看。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --------------------  Connection handler --------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Http11ConnectionHandler</span></span><br><span class="line">            <span class="keyword">extends</span> <span class="title">AbstractConnectionHandler</span>&lt;<span class="title">Long</span>,<span class="title">Http11AprProcessor</span>&gt; <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> Http11AprProtocol proto;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Processes HTTP requests.</span><br><span class="line"> *</span><br><span class="line"> * @author Remy Maucherat</span><br><span class="line"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Http11AprProcessor</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractHttp11Processor&lt;Long&gt;</span> &#123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getAdapter().service(request, response);，用于处理用户自定义Servlet请求的地方<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> abstract <span class="keyword">class</span> AbstractHttp11Processor&lt;S&gt; extends AbstractProcessor&lt;S&gt; &#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">     * Process pipelined HTTP requests using the specified input and output</span><br><span class="line">     * streams.</span><br><span class="line">     *</span><br><span class="line">     * @param socketWrapper Socket from which the HTTP requests will be read</span><br><span class="line">     *               and the HTTP responses will be written.</span><br><span class="line">     *</span><br><span class="line">     * @throws IOException error during an I/O operation</span><br><span class="line">     */</span></span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> SocketState <span class="title">process</span><span class="params">(SocketWrapper&lt;S&gt; socketWrapper)</span></span><br><span class="line">        throws IOException </span>&#123;</span><br><span class="line">        RequestInfo rp = request.getRequestProcessor();</span><br><span class="line">        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Setting up the I/O</span></span><br><span class="line">        setSocketWrapper(socketWrapper);</span><br><span class="line">        getInputBuffer().init(socketWrapper, endpoint);</span><br><span class="line">        getOutputBuffer().init(socketWrapper, endpoint);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Flags</span></span><br><span class="line">        keepAlive = <span class="literal">true</span>;</span><br><span class="line">        comet = <span class="literal">false</span>;</span><br><span class="line">        openSocket = <span class="literal">false</span>;</span><br><span class="line">        sendfileInProgress = <span class="literal">false</span>;</span><br><span class="line">        readComplete = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (endpoint.getUsePolling()) &#123;</span><br><span class="line">            keptAlive = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            keptAlive = socketWrapper.isKeptAlive();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (disableKeepAlive()) &#123;</span><br><span class="line">            socketWrapper.setKeepAliveLeft(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!getErrorState().isError() &amp;&amp; keepAlive &amp;&amp; !comet &amp;&amp; !isAsync() &amp;&amp;</span><br><span class="line">                httpUpgradeHandler == null &amp;&amp; !endpoint.isPaused()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Parsing the request header</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                setRequestLineReadTimeout();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!getInputBuffer().parseRequestLine(keptAlive)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (handleIncompleteRequestLineRead()) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (endpoint.isPaused()) &#123;</span><br><span class="line">                    <span class="comment">// 503 - Service unavailable</span></span><br><span class="line">                    response.setStatus(<span class="number">503</span>);</span><br><span class="line">                    setErrorState(ErrorState.CLOSE_CLEAN, null);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    keptAlive = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// Set this every time in case limit has been changed via JMX</span></span><br><span class="line">                    request.getMimeHeaders().setLimit(endpoint.getMaxHeaderCount());</span><br><span class="line">                    <span class="comment">// Currently only NIO will ever return false here</span></span><br><span class="line">                    <span class="keyword">if</span> (!getInputBuffer().parseHeaders()) &#123;</span><br><span class="line">                        <span class="comment">// We've read part of the request, don't recycle it</span></span><br><span class="line">                        <span class="comment">// instead associate it with the socket</span></span><br><span class="line">                        openSocket = <span class="literal">true</span>;</span><br><span class="line">                        readComplete = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!disableUploadTimeout) &#123;</span><br><span class="line">                        setSocketTimeout(connectionUploadTimeout);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getLog().isDebugEnabled()) &#123;</span><br><span class="line">                    getLog().debug(</span><br><span class="line">                            sm.getString(<span class="string">"http11processor.header.parse"</span>), e);</span><br><span class="line">                &#125;</span><br><span class="line">                setErrorState(ErrorState.CLOSE_NOW, e);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                ExceptionUtils.handleThrowable(t);</span><br><span class="line">                UserDataHelper.Mode logMode = userDataHelper.getNextMode();</span><br><span class="line">                <span class="keyword">if</span> (logMode != null) &#123;</span><br><span class="line">                    String message = sm.getString(</span><br><span class="line">                            <span class="string">"http11processor.header.parse"</span>);</span><br><span class="line">                    <span class="keyword">switch</span> (logMode) &#123;</span><br><span class="line">                        <span class="keyword">case</span> INFO_THEN_DEBUG:</span><br><span class="line">                            message += sm.getString(</span><br><span class="line">                                    <span class="string">"http11processor.fallToDebug"</span>);</span><br><span class="line">                            <span class="comment">//$FALL-THROUGH$</span></span><br><span class="line">                        <span class="keyword">case</span> INFO:</span><br><span class="line">                            getLog().info(message);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> DEBUG:</span><br><span class="line">                            getLog().debug(message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 400 - Bad Request</span></span><br><span class="line">                response.setStatus(<span class="number">400</span>);</span><br><span class="line">                setErrorState(ErrorState.CLOSE_CLEAN, t);</span><br><span class="line">                getAdapter().<span class="built_in">log</span>(request, response, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!getErrorState().isError()) &#123;</span><br><span class="line">                <span class="comment">// Setting up filters, and parse some request headers</span></span><br><span class="line">                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    prepareRequest();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    ExceptionUtils.handleThrowable(t);</span><br><span class="line">                    <span class="keyword">if</span> (getLog().isDebugEnabled()) &#123;</span><br><span class="line">                        getLog().debug(sm.getString(</span><br><span class="line">                                <span class="string">"http11processor.request.prepare"</span>), t);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 500 - Internal Server Error</span></span><br><span class="line">                    response.setStatus(<span class="number">500</span>);</span><br><span class="line">                    setErrorState(ErrorState.CLOSE_CLEAN, t);</span><br><span class="line">                    getAdapter().<span class="built_in">log</span>(request, response, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (maxKeepAliveRequests == <span class="number">1</span>) &#123;</span><br><span class="line">                keepAlive = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxKeepAliveRequests &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    socketWrapper.decrementKeepAlive() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                keepAlive = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the request in the adapter</span></span><br><span class="line">            <span class="keyword">if</span> (!getErrorState().isError()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);</span><br><span class="line">                    getAdapter().service(request, response);<span class="comment">//核心代码</span></span><br><span class="line">                    <span class="comment">// Handle when the response was committed before a serious</span></span><br><span class="line">                    <span class="comment">// error occurred.  Throwing a ServletException should both</span></span><br><span class="line">                    <span class="comment">// set the status to 500 and set the errorException.</span></span><br><span class="line">                    <span class="comment">// If we fail here, then the response is likely already</span></span><br><span class="line">                    <span class="comment">// committed, so we can't try and set headers.</span></span><br><span class="line">                    <span class="keyword">if</span>(keepAlive &amp;&amp; !getErrorState().isError() &amp;&amp; (</span><br><span class="line">                            response.getErrorException() != null ||</span><br><span class="line">                                    (!isAsync() &amp;&amp;</span><br><span class="line">                                    statusDropsConnection(response.getStatus())))) &#123;</span><br><span class="line">                        setErrorState(ErrorState.CLOSE_CLEAN, null);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setCometTimeouts(socketWrapper);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedIOException e) &#123;</span><br><span class="line">                    setErrorState(ErrorState.CLOSE_NOW, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (HeadersTooLargeException e) &#123;</span><br><span class="line">                    <span class="comment">// The response should not have been committed but check it</span></span><br><span class="line">                    <span class="comment">// anyway to be safe</span></span><br><span class="line">                    <span class="keyword">if</span> (response.isCommitted()) &#123;</span><br><span class="line">                        setErrorState(ErrorState.CLOSE_NOW, e);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        response.reset();</span><br><span class="line">                        response.setStatus(<span class="number">500</span>);</span><br><span class="line">                        setErrorState(ErrorState.CLOSE_CLEAN, e);</span><br><span class="line">                        response.setHeader(<span class="string">"Connection"</span>, <span class="string">"close"</span>); <span class="comment">// <span class="doctag">TODO:</span> Remove</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    ExceptionUtils.handleThrowable(t);</span><br><span class="line">                    getLog().error(sm.getString(</span><br><span class="line">                            <span class="string">"http11processor.request.process"</span>), t);</span><br><span class="line">                    <span class="comment">// 500 - Internal Server Error</span></span><br><span class="line">                    response.setStatus(<span class="number">500</span>);</span><br><span class="line">                    setErrorState(ErrorState.CLOSE_CLEAN, t);</span><br><span class="line">                    getAdapter().<span class="built_in">log</span>(request, response, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Finish the handling of the request</span></span><br><span class="line">            rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isAsync() &amp;&amp; !comet) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getErrorState().isError()) &#123;</span><br><span class="line">                    <span class="comment">// If we know we are closing the connection, don't drain</span></span><br><span class="line">                    <span class="comment">// input. This way uploading a 100GB file doesn't tie up the</span></span><br><span class="line">                    <span class="comment">// thread if the servlet has rejected it.</span></span><br><span class="line">                    getInputBuffer().setSwallowInput(<span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Need to check this again here in case the response was</span></span><br><span class="line">                    <span class="comment">// committed before the error that requires the connection</span></span><br><span class="line">                    <span class="comment">// to be closed occurred.</span></span><br><span class="line">                    checkExpectationAndResponseStatus();</span><br><span class="line">                &#125;</span><br><span class="line">                endRequest();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If there was an error, make sure the request is counted as</span></span><br><span class="line">            <span class="comment">// and error, and update the statistics counter</span></span><br><span class="line">            <span class="keyword">if</span> (getErrorState().isError()) &#123;</span><br><span class="line">                response.setStatus(<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isAsync() &amp;&amp; !comet || getErrorState().isError()) &#123;</span><br><span class="line">                request.updateCounters();</span><br><span class="line">                <span class="keyword">if</span> (getErrorState().isIoAllowed()) &#123;</span><br><span class="line">                    getInputBuffer().nextRequest();</span><br><span class="line">                    getOutputBuffer().nextRequest();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!disableUploadTimeout) &#123;</span><br><span class="line">                <span class="keyword">if</span>(endpoint.getSoTimeout() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    setSocketTimeout(endpoint.getSoTimeout());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    setSocketTimeout(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (breakKeepAliveLoop(socketWrapper)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getErrorState().isError() || endpoint.isPaused()) &#123;</span><br><span class="line">            <span class="keyword">return</span> SocketState.CLOSED;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAsync() || comet) &#123;</span><br><span class="line">            <span class="keyword">return</span> SocketState.LONG;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUpgrade()) &#123;</span><br><span class="line">            <span class="keyword">return</span> SocketState.UPGRADING;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sendfileInProgress) &#123;</span><br><span class="line">                <span class="keyword">return</span> SocketState.SENDFILE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (openSocket) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (readComplete) &#123;</span><br><span class="line">                        <span class="keyword">return</span> SocketState.OPEN;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> SocketState.LONG;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> SocketState.CLOSED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终执行代码的adapter是来自于AbstractHttp11Protocol。还记得在Connector的startInternal函数么，在那里使用的是protocolHandler就是org.apache.coyote.http11.Http11NioProtocol，它继承了AbstractHttp11Protocol，所以这个最终的adapter是来自Http11NioProtocol的setAdapter方法传递进来。而这个方法，在Connector的initInternal中被调用，并且实际上就是这个Connector对象本身。</p>
<p>总结一下Tomcat中的几个核心模块<br><strong>[Acceptor]</strong><br>负责用来管理连接到tomcat服务器的数量，来看看Acceptor在tomcat服务器中的应用，是如何实现连接管理的，socket连接建立成功之后，是如何实现内容的读写的（读写是交由Poller机制去完成）。</p>
<p><strong>[连接的传递]</strong><br>管理连接的建立差不多就是Acceptor的主要工作了，连接建立好之后，最后的工作就是交给Poller去实现数据的读写。在setSocketOptions中实现了SocketChannel对Poller的注册。</p>
<p><strong>[Connection Handler]</strong><br>处理socket连接的handler<br>content:  Http11ConnectionHandler、AbstractConnectionHandler、AbstractEndpoint.Handler<br>主要内容部分在AbstractConnectionHandler上，从在这个类中定义的方法上和成员变量上可以看出，它作为一个Handler，但实际上并不直接对socket进行处理。它的主要作用是提供了将Processor和connection进行关联的地方，在适合的地方调用Processor去处理connection。还一个作用是在ConnectionHandler中维护内部缓存来提升系统性能。</p>
<p>在AbstractConnectionHandler的process方法中，实现了对socket的状态检查，缓存数据读写等操作。虽然是在这里对socket进行了各种检查，但并不涉及socket数据的处理，对socket的实际处理，还是交给了Processor来完成。</p>
<p>通过抽象方法 createProcessor方法，来作为关联Processor的入口。通过getProtocol方法，来作为获取和此Connection Handler关联的protocol的入口。</p>
<p><strong>[Socket Processor]</strong><br>处理socket数据<br>content: Http11Processor、AbstractHttp11Processor、org.apache.coyote.AbstractProcessor、org.apache.coyote.Processor</p>
<p>Socket Processor是具体处理socket，读写socket数据的地方。</p>
<p>最上层的Processor接口定义了getExecutor、process、event、getRequest等接口，定义了socket processor的大致模型。<br>     getExecutor方法定义了获取处理socket的线程池入口<br>     process方法是处理socket的入口<br>     event处理socket事件的地方<br>     request获取请求来源的入口<br>次一层的AbstractProcessor定义了Socket Processor框架和其它模块的交互关系，从AbstractProcessor的属性中可以看出<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProcessor</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">ActionHook</span>, <span class="title">Processor</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> StringManager sm = StringManager.getManager(Constants.Package);</span><br><span class="line">        <span class="keyword">protected</span> Adapter adapter;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> AsyncStateMachine asyncStateMachine ;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> AbstractEndpoint&lt;S&gt; endpoint ;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> Request request ;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> Response response ;</span><br><span class="line">        <span class="keyword">protected</span> SocketWrapper&lt;S&gt; socketWrapper = <span class="keyword">null</span> ;</span><br></pre></td></tr></table></figure></p>
<p> 一个Adapter对象，用来和tomcat容器进行关联，这里是实现了和Connector的关联。<br>          Adapter的作用在其注释中描述如下“Adapter. This represents the entry point in a coyote -based servlet container.”<br>     一个AbstractEndpoint对象，用来和Endpoint模块进行关联，实现对基础网络I/O的屏蔽。</p>
<p>AbstractHttp11Processor中包含了更多的处理http请求相关的细节，包括使用的http协议、socket的维持状态、内容压缩等。同时，更重要的一点是，它实现了process方法，这是整个Socket Processor框架处理http请求的核心部分。从实现的process方法中，可以看出Socket Processor框架的工作原理。 process方法做了各种分支的检查，处理了http请求的各种状态。根据所处理的http请求的状态，设置request和response的状态，最后正常的http请求相关的业务，会交由Adapter的service去进行处理，转移到Connector上来执行。</p>
<p><strong>[Endpoint]</strong><br>Endpoint是基础的网络设施，通过Endpoint来实现网络连接和控制，它是服务器对外I/O操作的接入点。主要任务是管理对外的socket连接，同时将建立好的socket连接交到合适的工作线程中去。<br>content：org.apache.tomcat.util.net.AbstractEndpoint，org.apache.tomcat.util.net.NioEndpoint</p>
<p>对于AbstractEndpoint主要关注它的以下几个属性<br>     private Executor executor = null;   执行业务的线程池，如果外部没有指定线程池，就使用Endpoint内部的线程池<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Threads used <span class="keyword">to</span> accept <span class="keyword">new</span> connections <span class="keyword">and</span> pass them <span class="keyword">to</span> worker threads.</span><br><span class="line">*/</span><br><span class="line"> <span class="keyword">protected</span> Acceptor[] acceptors;  管理连接</span><br></pre></td></tr></table></figure></p>
<p>对于NioEndpoint主要关注它的一下几个属性<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Handling of accepted sockets.</span><br><span class="line"> */</span></span><br><span class="line">private <span class="operator"><span class="keyword">Handler</span> <span class="keyword">handler</span> = <span class="literal">null</span> ;</span> 处理socket连接的<span class="operator"><span class="keyword">handler</span>，属于业务处理部分，在executor线程池中执行</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * The socket poller.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> Poller[] pollers = <span class="literal">null</span> ;</span> 监听socket事件，调用<span class="operator"><span class="keyword">handler</span>进行socket处理。</span></span><br></pre></td></tr></table></figure></p>
<p>它的内部组成包括Poller线程组和Acceptor线程组。</p>
<p>Acceptor线程组负责接收来自外部的网络连接请求，并将建立好的连接，交到Poller线程组去处理。Acceptor的具体工作原理，可以从NioEndpoint$Acceptor.run方法中可以看出，(countUpOrAwaitConnection)控制接收的连接的数量，对接收的连接，(setSocketOptions)将其注册到Poller线程组中，如果在操作过程中遇到错误，则关闭连接。连接注册到Poller线程组后，Poller就能够读取连接中的数据，并进行处理。注册到Poller线程上的效果，是将socket封装后放入Poller线程内部维护的一个PollerEvent队列中，然后Poller线程运行时处理队列，将socket注册到这个Poller的Selector上。</p>
<p>Poller线程组负责对已建立连接的socket进行处理。从NioEndpoint$Poller.run方法中可以看出Poller线程的工作原理，基于Java NIO来进行网络的读写。在run方法中，通过selector.select系列方法来获取数据，然后经由processKey到processSocket方法，封装成一个SocketProcessor对象后，放在EndPoint的线程池中执行，但实际的业务处理部分，是通过Endpoint的Handler进行处理。</p>
<p>下面简要说下后面的处理流程<br><strong>SocketProcessor</strong> –&gt;  <strong>Http11ConnectionHandler</strong> –&gt;  <strong>Http11Processor</strong> –&gt;  <strong>CoyoteApapter</strong> –&gt;  <strong>StandardEngineValve</strong> –&gt;  <strong>StandHostValve</strong> –&gt;  <strong>StandardContextValve</strong> –&gt;  <strong>StandardWrapperValve</strong> –&gt;  <strong>Application Filter Chain</strong> –&gt;  <strong>Servlet</strong></p>
<p>文章参考来源：大神 <a href="http://blog.csdn.net/yanlinwang/article/category/1398223" target="_blank" rel="external">http://blog.csdn.net/yanlinwang/article/category/1398223</a><br><a href="http://blog.csdn.net/cutesource/article/category/631854" target="_blank" rel="external">http://blog.csdn.net/cutesource/article/category/631854</a><br>明天继续，总结下深入剖析Tomcat，Tomcat的深入了解告一段落，开启新的路程。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于学习tomcat源码的一些知识总结<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java TCP/IP Socket编程]]></title>
    <link href="http://zc14.github.io/2016/01/13/Java-TCP-IP-Socket%E7%BC%96%E7%A8%8B/"/>
    <id>http://zc14.github.io/2016/01/13/Java-TCP-IP-Socket编程/</id>
    <published>2016-01-13T05:37:00.000Z</published>
    <updated>2016-01-15T06:06:35.184Z</updated>
    <content type="html"><![CDATA[<p>Java TCP/IP Socket编程 读书笔记，一本好书，值得多看几遍<br><a id="more"></a></p>
<h2 id="1-网络构成">1.网络构成</h2><p> 主机+路由器+物理的网络线路（通信信道）</p>
<h2 id="2-协议的定义">2.协议的定义</h2><p> 协议相当于相互通信的程序间达成的一种约定，它规定了分组报文的结构、交换方式、包含的意义以及怎样对报文所包含的信息进行解析。</p>
<h2 id="3-TCP/IP网络">3.TCP/IP网络</h2><p> IP–IP地址<br> TCP/UDP–端口</p>
<h2 id="4-信息处理流程">4.信息处理流程</h2><p> 应用程序-套接字-TCP/UDP-IP-通信信道- IP - 通信信道 -IP-TCP/UDP-套接字-应用程序<br> 主机                    -以太网等|路由器|        -主机           </p>
<h2 id="5-IP网络层_TCP/UDP传输层">5.IP网络层 TCP/UDP传输层</h2><h2 id="6-TCP协议和UDP协议也成为端到端协议，因为它们将数据从一个应用程序传输到另一个应用程序，而IP协议只是将数据从一个主机传输到另一个主机。">6.TCP协议和UDP协议也成为端到端协议，因为它们将数据从一个应用程序传输到另一个应用程序，而IP协议只是将数据从一个主机传输到另一个主机。</h2><h2 id="7-TCP协议是一个面向连接的协议3次握手，保证数据传输的可信赖性。_UDP是一种尽力而为的数据报服务，报文丢失，顺序错乱等问题要面对。">7.TCP协议是一个面向连接的协议3次握手，保证数据传输的可信赖性。 UDP是一种尽力而为的数据报服务，报文丢失，顺序错乱等问题要面对。</h2><h2 id="8-内网地址_10-/_192-168-/172-（16-31）-–&gt;NAT(网络地址转换)–&gt;连接到外网。多播地址224-239">8.内网地址 10./ 192.168./172.（16-31）.–&gt;NAT(网络地址转换)–&gt;连接到外网。多播地址224-239</h2><h2 id="9-Socket套接字是一种抽象层，应用程序通过它来发送和接收数据。主要的Socket类型为流套接字(Stream_socket)和数据报套接字(datagram_socket)-">9.Socket套接字是一种抽象层，应用程序通过它来发送和接收数据。主要的Socket类型为流套接字(Stream socket)和数据报套接字(datagram socket).</h2><h2 id="10-TCP协议下Client_-_Socket-InputStream/OutputStream_byte[]_;_Server_-_ServerSocket_-_socket">10.TCP协议下Client - Socket-InputStream/OutputStream byte[] ; Server - ServerSocket - socket</h2><h2 id="11-UDP协议_1&gt;在IP协议基础上添加了另一层地址(端口)，2&gt;对数据传输过程中可能产生的错误进行了检测，并抛弃已经损坏的数据。_UDP套接字比TCP的优势：保留边界信息。尽力而为，效率高，节约流量，灵活性，便于扩展。_DatagramSocket和DatagramPacket">11.UDP协议 1&gt;在IP协议基础上添加了另一层地址(端口)，2&gt;对数据传输过程中可能产生的错误进行了检测，并抛弃已经损坏的数据。 UDP套接字比TCP的优势：保留边界信息。尽力而为，效率高，节约流量，灵活性，便于扩展。 DatagramSocket和DatagramPacket</h2><h2 id="12-UDP_DatagramSocket_send()_和_receive()，发送/接收_DatagramPacket-需要设置阻塞时间socket-setSoTimeout，重试次数。失败后重试，一次次递减。">12.UDP DatagramSocket send() 和 receive()，发送/接收 DatagramPacket.需要设置阻塞时间socket.setSoTimeout，重试次数。失败后重试，一次次递减。</h2><h2 id="13-_UDP有长度限制_65535">13. UDP有长度限制 65535</h2><p>一个DatagramPacket实例中所运行传输的最大数据量为65507个字节，即UDP数据报文所能负载的最多数据，因此，使用一个有65600字节左右缓存数组的数据总是安全的。</p>
<h2 id="14-TCP/IP协议的唯一约束是信息必须在块(chunk)中发送和接收数据,而块的长度必须是8的倍数。">14.TCP/IP协议的唯一约束是信息必须在块(chunk)中发送和接收数据,而块的长度必须是8的倍数。</h2><h2 id="15-阻塞-TCP-成帧技术–解决接收端如何定位消息的首尾位置的问题。1&gt;基于定界符（填充技术，用于特殊字符传递问题，缺点是要扫描所有内容）2&gt;显示长度（必须知道消息长度）">15.阻塞-TCP-成帧技术–解决接收端如何定位消息的首尾位置的问题。1&gt;基于定界符（填充技术，用于特殊字符传递问题，缺点是要扫描所有内容）2&gt;显示长度（必须知道消息长度）</h2><h2 id="16-服务器端不能一次只处理一个客户的请求，那也太弱了。_1&gt;一客户一线程-2&gt;线程池_for循环，每个循环中new_Thread">16.服务器端不能一次只处理一个客户的请求，那也太弱了。 1&gt;一客户一线程.2&gt;线程池 for循环，每个循环中new Thread</h2><p>run()方法中 无限循环 while(true){ serverSocket.accept(),传递给Runnable中执行 }.<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(PORT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; threadPoolSize;i++)&#123;</span><br><span class="line">  Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        	<span class="keyword">try</span>&#123;</span><br><span class="line">              Socket clientSocket = serverSocket.accept();</span><br><span class="line">              EchoProtocol.handleEchoClient(clientSocket);<span class="comment">//EchoProtocol实现Runnable接口</span></span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException ex)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3&gt;线程池的优化版本-系统管理调度：Executor接口<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">ServerSocket serverSocket</span> = new ServerSocket(PORT);</span><br><span class="line"><span class="constant">Executor service</span> = Executors.newCachedThreadPool();<span class="comment">//dispatch </span></span><br><span class="line">while(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="constant">	Socket clientSocket</span> = serverSocket.accept();</span><br><span class="line">    <span class="class"><span class="keyword">service</span>.<span class="title">execute</span>(new EchoProtocol(clientSocket));</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="17-多接收者_1&gt;广播broadcast_IPv4的本地广播地址(255-255-255-255),本地广播信息绝不会被路由器转发。2&gt;IPv4中的多播multicast地址范围是224-0-0-0到239-255-255-255">17.多接收者 1&gt;广播broadcast IPv4的本地广播地址(255.255.255.255),本地广播信息绝不会被路由器转发。2&gt;IPv4中的多播multicast地址范围是224.0.0.0到239.255.255.255</h2><h2 id="18-多播MulticastSocket(是DatagramSocket的一个子类)，设置多播数据报文生命周期TTL。MulticastSocket_joinGroup-">18.多播MulticastSocket(是DatagramSocket的一个子类)，设置多播数据报文生命周期TTL。MulticastSocket joinGroup.</h2><h2 id="19-NIO非阻塞状态">19.NIO非阻塞状态</h2><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> clientChannel = <span class="type">SocketChannel</span>.<span class="keyword">open</span><span class="literal">()</span>;</span><br><span class="line">clientChannel.configureBlocking(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h2 id="20-Selector_可以用于避免使用非阻塞式客户端中很浪费资源的忙等。">20.Selector 可以用于避免使用非阻塞式客户端中很浪费资源的忙等。</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Selector</span> <span class="keyword">selector</span> = <span class="keyword">Selector</span>.open();</span><br><span class="line"></span><br><span class="line">ServerSocketChannel channel = ServerSocketChannel.open();</span><br><span class="line">channel.<span class="keyword">register</span>(<span class="keyword">selector</span>,SelectionKey.OP+ACCEPT);<span class="comment">//注册事件</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java TCP/IP Socket编程 读书笔记，一本好书，值得多看几遍<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入剖析Tomcat]]></title>
    <link href="http://zc14.github.io/2016/01/06/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Tomcat/"/>
    <id>http://zc14.github.io/2016/01/06/深入剖析Tomcat/</id>
    <published>2016-01-06T01:20:00.000Z</published>
    <updated>2016-01-16T14:12:01.401Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
<pre><code>Tomcat源码阅读文献
</code></pre><h2 id="A-一个简单的Web服务器–构建Web服务">A.一个简单的Web服务器–构建Web服务</h2><h3 id="1-HTTP协议">1.HTTP协议</h3><ol>
<li><p>请求<br><strong>请求方法  统一资源标识符URI  协议/版本</strong><br><strong>请求头</strong><br><strong>空行</strong><br><strong>实体</strong><br>[Demo]</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST <span class="regexp">/Platfform/</span>login.jsp HTTP/<span class="number">1.1</span></span><br><span class="line"><span class="string">Accept:</span> text<span class="regexp">/plain;text/</span>html</span><br><span class="line">Accept-<span class="string">Language:</span> en-gb</span><br><span class="line"><span class="string">Connection:</span> Keep-Alive</span><br><span class="line"><span class="string">Host:</span> localhost</span><br><span class="line">      </span><br><span class="line">username=jack&amp;password=<span class="number">1234</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>相应<br><strong>协议/版本  状态码  描述</strong><br><strong>响应头</strong><br><strong>空行</strong><br><strong>响应实体段</strong><br>[Demo]</p>
 <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Server: Microsoft-IIS/<span class="number">4.0</span></span><br><span class="line">Date:M<span class="keyword">on</span>,<span class="number">6</span> Jan <span class="number">2015</span></span><br><span class="line">Content-Type:text/html</span><br><span class="line">Content-Length:<span class="number">85</span></span><br><span class="line">       </span><br><span class="line"><span class="variable">&lt;html&gt;</span></span><br><span class="line">  <span class="variable">&lt;head&gt;</span></span><br><span class="line">     <span class="variable">&lt;title&gt;</span>hello world<span class="variable">&lt;/title&gt;</span></span><br><span class="line">  <span class="variable">&lt;/head&gt;</span></span><br><span class="line">  <span class="variable">&lt;body&gt;</span>Welcome <span class="keyword">to</span> Tomcat World<span class="variable">&lt;/body&gt;</span></span><br><span class="line"><span class="variable">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-Socket类_和_ServerSocket类">2.Socket类 和 ServerSocket类</h3><h3 id="3-构建应用程序">3.构建应用程序</h3><p>1.HttpServer接收请求(ServerSocket)<br>2.创建Socket对象(ServerSocket.accept())<br>3.创建输入输出流InputStream/OutputStream(socket.getInputStream()/socket.getOutputStream())<br>4.创建Request/Response对象<br>5.Request对象负责截取URI(自定义parse方法-用到indexOf()和substring)，传递给Response。<br>6.Response响应，构建HTTP相应格式信息，OutputStream给客户端。</p>
</li>
</ol>
<h2 id="B-一个简单的servlet容器–用于解析servlet">B.一个简单的servlet容器–用于解析servlet</h2><h3 id="servet编程要使用javax-servlet和javax-servlet-http两个接口下的类">servet编程要使用javax.servlet和javax.servlet.http两个接口下的类</h3><p><strong>URLClassLoader是ClassLoader的子类，它用于从指向 JAR 文件和目录的 URL 的搜索路径加载类和资源。也就是说，通过URLClassLoader就可以加载指定jar中的class到内存中。</strong></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(jar文件全路径);</span><br><span class="line">URL url = <span class="keyword">file</span>.toURI().toURL();</span><br><span class="line">URLClassLoader loader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[] &#123; url &#125;);</span><br><span class="line"><span class="keyword">Class</span> tidyClazz = loader.loadClass(所需<span class="keyword">class</span>的含包名的全名);</span><br></pre></td></tr></table></figure>
<h3 id="应用程序">应用程序</h3><p>   HttpServer—入口，ServletSocket–Socket–Input/Output<br>   Request—&gt;implements ServletRequest请求<br>   Response—&gt;implements ServletResponse响应–PrintWriter<br>   StaticResourceProcessor—静态html资源文件解析<br>   ServletProcessor—servlet类解析<br>   Cnstants—常量类</p>
]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>
<pre><code>Tomcat源码阅读文献
</code></pre><h2 id="A-一个简单的Web服务器–构建Web服务">A.一个简单的Web服务器–构建Web服务</h2><h3 id="1-HTTP协议">1.HTTP协议</]]>
    </summary>
    
      <category term="Tomcat" scheme="http://zc14.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java并发编程的艺术]]></title>
    <link href="http://zc14.github.io/2015/12/27/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <id>http://zc14.github.io/2015/12/27/Java并发编程的艺术/</id>
    <published>2015-12-27T03:27:03.000Z</published>
    <updated>2015-12-27T07:25:30.415Z</updated>
    <content type="html"><![CDATA[<p>Java并发编程的艺术读书笔记<br><a id="more"></a></p>
<h2 id="数据库连接池">数据库连接池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个简单的数据库连接池示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> LinkedList&lt;Connection&gt; pool = <span class="keyword">new</span> LinkedList&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> initialSize)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (initialSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initialSize; i++) &#123;</span><br><span class="line">				pool.addLast(ConnectionDriver.createConnection());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">				<span class="comment">// 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接</span></span><br><span class="line">				pool.addLast(connection);</span><br><span class="line">				pool.notifyAll();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在mills内无法获取到连接，将会返回null</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Connection <span class="title">fetchConnection</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">			<span class="comment">// 完全超时</span></span><br><span class="line">			<span class="keyword">if</span> (mills &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">while</span> (pool.isEmpty()) &#123;</span><br><span class="line">					pool.wait();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> pool.removeFirst();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line">				<span class="keyword">long</span> remaining = mills;</span><br><span class="line">				<span class="keyword">while</span> (pool.isEmpty() &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					pool.wait(remaining);</span><br><span class="line">					remaining = future - System.currentTimeMillis();</span><br><span class="line">				&#125;</span><br><span class="line">				Connection result = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">if</span> (!pool.isEmpty()) &#123;</span><br><span class="line">					result = pool.removeFirst();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实的实现应该是由数据库驱动提供方法来实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionDriver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">				<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (method.getName().equals(<span class="string">"commit"</span>)) &#123;</span><br><span class="line">				TimeUnit.MICROSECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个Connection的代理，在commit时休眠100毫秒</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Connection <span class="title">createConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (Connection) Proxy.newProxyInstance(</span><br><span class="line">				ConnectionDriver.class.getClassLoader(),</span><br><span class="line">				<span class="keyword">new</span> Class&lt;?&gt;[] &#123; Connection.class &#125;, <span class="keyword">new</span> ConnectionHandler());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPoolTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> ConnectionPool pool = <span class="keyword">new</span> ConnectionPool(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">// 保证所有ConnectionRunner能够同时开始</span></span><br><span class="line">	<span class="keyword">static</span> CountDownLatch start = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// main线程将会等待所有的ConnectionRunner结束后才能继续执行</span></span><br><span class="line">	<span class="keyword">static</span> CountDownLatch end;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 线程数量，可以修改线程数量进行观察</span></span><br><span class="line">		<span class="keyword">int</span> threadCount = <span class="number">5000</span>;</span><br><span class="line">		end = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line">		AtomicInteger got = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">		AtomicInteger notGot = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">			Thread thread = <span class="keyword">new</span> Thread(</span><br><span class="line">					<span class="keyword">new</span> ConnectionRunner(count, got, notGot),</span><br><span class="line">					<span class="string">"ConnectionRunnerThread"</span>);</span><br><span class="line">			thread.start();</span><br><span class="line">		&#125;</span><br><span class="line">		start.countDown();</span><br><span class="line">		end.await();</span><br><span class="line">		System.out.println(<span class="string">"total invoke: "</span> + (threadCount * count));</span><br><span class="line">		System.out.println(<span class="string">"got connection: "</span> + got);</span><br><span class="line">		System.out.println(<span class="string">"not got connection: "</span> + notGot);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> count;</span><br><span class="line">		AtomicInteger got;</span><br><span class="line">		AtomicInteger notGot;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">ConnectionRunner</span><span class="params">(<span class="keyword">int</span> count, AtomicInteger got,</span><br><span class="line">				AtomicInteger notGot)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.count = count;</span><br><span class="line">			<span class="keyword">this</span>.got = got;</span><br><span class="line">			<span class="keyword">this</span>.notGot = notGot;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				start.await();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="comment">// 从线程池中获取连接，如果1000ms内无法获取到，将会返回null</span></span><br><span class="line">					<span class="comment">// 分别统计连接获取的数量got和未获取到连接的数量notGot</span></span><br><span class="line">					Connection connection = pool.fetchConnection(<span class="number">1000</span>);</span><br><span class="line">					<span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							connection.createStatement();</span><br><span class="line">							connection.commit();</span><br><span class="line">						&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">							pool.releaseConnection(connection);</span><br><span class="line">							got.incrementAndGet();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						notGot.incrementAndGet();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">				&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">					count--;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			end.countDown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程池">线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程池技术</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行一个Job，这个Job需要实现Runnable</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭线程池</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 增加工作者线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 减少工作者线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 得到正在等待执行的任务数量</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; <span class="keyword">implements</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//线程池最大限制数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_WORKER_NUMBERS  = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//线程池默认的数量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WORKER_NUMBERS = <span class="number">5</span>;</span><br><span class="line">	<span class="comment">//线程池最小的数量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_WORKER_NUMBERS = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//这是一个工作列表，将会向里面插入工作</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Job&gt; jobs = <span class="keyword">new</span> LinkedList&lt;Job&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//工作者列表</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;Worker&gt; workers = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Worker&gt;());</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//工作者线程的数量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//线程编号生成</span></span><br><span class="line">	<span class="keyword">private</span> AtomicLong threadNum = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		initializeWorkers(DEFAULT_WORKER_NUMBERS);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">		workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS : num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num;</span><br><span class="line">		initializeWorkers(workerNum);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(job != <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//添加一个工作，然后进行通知</span></span><br><span class="line">			<span class="keyword">synchronized</span>(jobs)&#123;</span><br><span class="line">				jobs.addLast(job);</span><br><span class="line">				jobs.notify();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Worker worker: workers)&#123;</span><br><span class="line">			worker.shutdown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(jobs)&#123;</span><br><span class="line">			<span class="comment">//限制新增的Worker数量不能超过最大值</span></span><br><span class="line">			<span class="keyword">if</span>( num + <span class="keyword">this</span>.workerNum &gt; MAX_WORKER_NUMBERS)&#123;</span><br><span class="line">				num = MAX_WORKER_NUMBERS - <span class="keyword">this</span>.workerNum;</span><br><span class="line">			&#125;</span><br><span class="line">			initializeWorkers(num);</span><br><span class="line">			<span class="keyword">this</span>.workerNum += num;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(jobs)&#123;</span><br><span class="line">			<span class="keyword">if</span>(num &gt;= <span class="keyword">this</span>.workerNum)&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"beyond workNum"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//按照给定的数量停止Worker</span></span><br><span class="line">			<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(count &lt; num)&#123;</span><br><span class="line">				Worker worker = workers.get(count);</span><br><span class="line">				<span class="keyword">if</span>(workers.remove(worker))&#123;</span><br><span class="line">					worker.shutdown();</span><br><span class="line">					count++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.workerNum -= count;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> jobs.size();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化线程工作者</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWorkers</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num;i++)&#123;</span><br><span class="line">			Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">			workers.add(worker);</span><br><span class="line">			Thread thread = <span class="keyword">new</span> Thread(worker,<span class="string">"ThreadPool-Worker-"</span>+threadNum.incrementAndGet());</span><br><span class="line">			thread.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//工作者，负责消费任务</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="comment">//是否工作</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(running)&#123;</span><br><span class="line">				Job job = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">synchronized</span>(jobs)&#123;</span><br><span class="line">					<span class="comment">//如果工作者列表是空的，那么就wait</span></span><br><span class="line">					<span class="keyword">while</span>(jobs.isEmpty())&#123;</span><br><span class="line">						<span class="keyword">try</span>&#123;</span><br><span class="line">							jobs.wait();</span><br><span class="line">						&#125;<span class="keyword">catch</span>(InterruptedException ex)&#123;</span><br><span class="line">							<span class="comment">//感知到外部对WorkerThread的中断操作，返回</span></span><br><span class="line">							Thread.currentThread().interrupt();</span><br><span class="line">							<span class="keyword">return</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">//取出一个Job</span></span><br><span class="line">					job = jobs.removeFirst();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(job != <span class="keyword">null</span>)&#123;</span><br><span class="line">					<span class="keyword">try</span>&#123;</span><br><span class="line">						job.run();</span><br><span class="line">					&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">						<span class="comment">//忽略job执行中的Exception</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">			running = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个基于线程池技术的简单Web服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理HttpRequest的线程池</span></span><br><span class="line">	<span class="keyword">static</span> ThreadPool&lt;HttpRequestHandler&gt; threadPool = <span class="keyword">new</span> DefaultThreadPool&lt;HttpRequestHandler&gt;(</span><br><span class="line">			<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// SimpleHttpServer的根路径</span></span><br><span class="line">	<span class="keyword">static</span> String basePath;</span><br><span class="line">	<span class="keyword">static</span> ServerSocket serverSocket;</span><br><span class="line">	<span class="comment">// 服务监听端口</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (port &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			SimpleHttpServer.port = port;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBasePath</span><span class="params">(String basePath)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (basePath != <span class="keyword">null</span> &amp;&amp; <span class="keyword">new</span> File(basePath).exists()</span><br><span class="line">				&amp;&amp; <span class="keyword">new</span> File(basePath).isDirectory()) &#123;</span><br><span class="line">			SimpleHttpServer.basePath = basePath;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动SimpleHttpServer</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">		Socket socket = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 接收一个客户端Socket，生成一个HttpRequestHandler，放入线程池执行</span></span><br><span class="line">			threadPool.execute(<span class="keyword">new</span> HttpRequestHandler(socket));</span><br><span class="line">		&#125;</span><br><span class="line">		serverSocket.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequestHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">HttpRequestHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.socket = socket;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			String line = <span class="keyword">null</span>;</span><br><span class="line">			BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">			BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">			PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">			InputStream in = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(</span><br><span class="line">						socket.getInputStream()));</span><br><span class="line">				String header = reader.readLine();</span><br><span class="line">				<span class="comment">// 由相对路径计算出绝对路径</span></span><br><span class="line">				String filePath = basePath + header.split(<span class="string">" "</span>)[<span class="number">1</span>];</span><br><span class="line">				out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">				<span class="comment">// 如果请求资源的后缀为jpg或者ico，则读取资源并输出</span></span><br><span class="line">				<span class="keyword">if</span> (filePath.endsWith(<span class="string">"jpg"</span>) || filePath.endsWith(<span class="string">"ico"</span>)) &#123;</span><br><span class="line">					in = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">					ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">					<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">						baos.write(i);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">byte</span>[] array = baos.toByteArray();</span><br><span class="line">					out.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">					out.println(<span class="string">"Content-Type: image/jpeg"</span>);</span><br><span class="line">					out.println(<span class="string">"Content-Length: "</span> + array.length);</span><br><span class="line">					out.println(<span class="string">""</span>);</span><br><span class="line">					socket.getOutputStream().write(array, <span class="number">0</span>, array.length);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(</span><br><span class="line">							<span class="keyword">new</span> FileInputStream(filePath)));</span><br><span class="line">					out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">					out.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">					out.println(<span class="string">"Content-Type: text/html; charset=UTF-8"</span>);</span><br><span class="line">					out.println(<span class="string">""</span>);</span><br><span class="line">					<span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">						out.println(line);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				out.flush();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">				out.println(<span class="string">"HTTP/1.1 500"</span>);</span><br><span class="line">				out.println(<span class="string">""</span>);</span><br><span class="line">				out.flush();</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				close(br, in, reader, out, socket);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭流或者Socket</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... closeables)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (closeables != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Closeable closeable : closeables) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					closeable.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">					<span class="comment">// 忽略</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于线程池实现的简单web服务器">基于线程池实现的简单web服务器</h2><h2 id="Java中的锁_Lock/Condition">Java中的锁 Lock/Condition</h2><h2 id="Java_并发容器和框架">Java 并发容器和框架</h2><h3 id="ConcurrentHashMap">ConcurrentHashMap</h3><p>   ConcurrentHashMap - 多个segment组成。采用了可重入锁ReentrantLock HashEntry。<br>   为了提高效率，ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。</p>
<h3 id="COncurrentLinkedQueue">COncurrentLinkedQueue</h3><p>   线程安全的队列。两种实现方式：1使用阻塞算法（锁）。2使用非阻塞算法（CAS）。</p>
<h3 id="Java中的阻塞队列">Java中的阻塞队列</h3><p>   ArrayBlockingQueue<br>   …</p>
<h3 id="Fork/Join框架">Fork/Join框架</h3><pre><code>工作窃取算法 <span class="literal">A</span>线程执行完自己的任务，从队列尾部窃取B线程中未执行的任务。
</code></pre><h2 id="Java中的并发工具类">Java中的并发工具类</h2><h3 id="等待多线程完成的CountDownLatch">等待多线程完成的CountDownLatch</h3><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch c = new CountDownLatch()<span class="comment">;</span></span><br><span class="line">c.countDown()<span class="comment">;</span></span><br><span class="line">c.await()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<pre><code>迅雷下载。
</code></pre><h3 id="同步屏障CyclicBarrier">同步屏障CyclicBarrier</h3><pre><code>张孝祥老师的例子-团队建设。去游玩。 集合-到达目的地-吃午饭-继续逛-集合-回家。等到最后一个满足条件，才去执行下一步。
</code></pre><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//银行流水处理服务类</span><br><span class="line">public class <span class="type">BankWaterService</span> implements <span class="type">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">	// 创建<span class="number">4</span>个屏障，处理完之后执行当前类的run方法</span><br><span class="line">	private <span class="type">CyclicBarrier</span> c = new <span class="type">CyclicBarrier</span>(<span class="number">4</span>, this);</span><br><span class="line"></span><br><span class="line">	// 假设只有<span class="number">4</span>个sheet，所以启动<span class="number">4</span>个线程</span><br><span class="line">	private <span class="type">Executor</span> executor = <span class="type">Executors</span>.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	// 保存每个sheet计算出来的银行流水结果</span><br><span class="line">	private <span class="type">ConcurrentHashMap</span>&lt;<span class="type">String</span>, <span class="type">Integer</span>&gt; sheetBankWaterCount = new <span class="type">ConcurrentHashMap</span>&lt;<span class="type">String</span>, <span class="type">Integer</span>&gt;();</span><br><span class="line"></span><br><span class="line">	private <span class="type">void</span> count() &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">			executor.execute(new <span class="type">Runnable</span>() &#123;</span><br><span class="line">				@<span class="type">Override</span></span><br><span class="line">				public <span class="type">void</span> run() &#123;</span><br><span class="line">					// 计算当前sheet的银行流水数据，计算代码省略</span><br><span class="line">					sheetBankWaterCount</span><br><span class="line">							.put(<span class="type">Thread</span>.currentThread().getName(), <span class="number">1</span>);</span><br><span class="line">					// 银行流水计算完成，插入一个屏障</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						c.await();</span><br><span class="line">					&#125; catch (<span class="type">InterruptedException</span> | <span class="type">BrokenBarrierException</span> e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@<span class="type">Override</span></span><br><span class="line">	public <span class="type">void</span> run() &#123;</span><br><span class="line">		<span class="type">int</span> <span class="literal">result</span> = <span class="number">0</span>;</span><br><span class="line">		// 汇总每个sheet计算出的结果</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">Entry</span>&lt;<span class="type">String</span>, <span class="type">Integer</span>&gt; sheet : sheetBankWaterCount.entrySet()) &#123;</span><br><span class="line">			<span class="literal">result</span> += sheet.getValue();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 将计算结果输出</span><br><span class="line">		sheetBankWaterCount.put(<span class="string">"result"</span>, <span class="literal">result</span>);</span><br><span class="line">		<span class="type">System</span>.<span class="keyword">out</span>.println(<span class="literal">result</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">		<span class="type">BankWaterService</span> bankWaterCount = new <span class="type">BankWaterService</span>();</span><br><span class="line">		bankWaterCount.count();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="控制并发线程数的Semaphore">控制并发线程数的Semaphore</h3><pre><code>银行排队。
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> SemaphoreTest &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">			threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				@<span class="function">Override</span><br><span class="line">				<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						s.acquire();</span><br><span class="line">						Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">						System.out.println(<span class="string">"save data"</span>);</span><br><span class="line">						s.release();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		threadPool.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程间交换数据的Exchanger">线程间交换数据的Exchanger</h3><p>张孝祥老师的例子- 模拟毒品交易</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; exgr       = <span class="keyword">new</span> Exchanger&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService         threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String A = <span class="string">"银行流水A"</span>;<span class="comment">// A录入银行流水数据</span></span><br><span class="line">                    exgr.exchange(A);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String B = <span class="string">"银行流水B"</span>;<span class="comment">// B录入银行流水数据</span></span><br><span class="line">                    String A = exgr.exchange(<span class="string">"B"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span> + A + <span class="string">"，B录入是："</span> + B);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java中的线程池">Java中的线程池</h2><pre><code>ThreadPoolExrcutor
</code></pre><h2 id="Executor框架">Executor框架</h2><p>   FutureTask<br>   ThreadPoolExrcutor<br>   ScheduledThreadPoolExecutor</p>
<h2 id="Java并发编程实战">Java并发编程实战</h2><p>   生产者或消费者模式<br>   <strong>通过一个容器来解决生产者和消费者的强耦合，生产者和消费者不直接通信，通过一个阻塞队列来平衡二者。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[并发编程]]>
    
    </summary>
    
      <category term="并发编程" scheme="http://zc14.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[异常]]></title>
    <link href="http://zc14.github.io/2015/12/23/%E5%BC%82%E5%B8%B8/"/>
    <id>http://zc14.github.io/2015/12/23/异常/</id>
    <published>2015-12-23T05:20:46.000Z</published>
    <updated>2015-12-27T07:26:33.428Z</updated>
    <content type="html"><![CDATA[<p>哪条语句执行，哪条不执行，看仔细了<br><a id="more"></a><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class ExceptionsTest &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">String</span> input = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">String</span> capitalized = capitalize(input);</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"$$$$"</span>+capitalized);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"~~~~"</span>+e.toString());</span><br><span class="line">			<span class="comment">//throw new RuntimeException("goodbye");</span></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.<span class="built_in">println</span>(capitalize(<span class="string">"name"</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> capitalize(<span class="keyword">String</span> s) <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == s) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Your passed a null argument"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Character firstChar = s.charAt(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">String</span> theRest = s.substring(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> firstChar.toString().toUpperCase() + theRest;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><em><br>~~~~java.lang.NullPointerException: Your passed a null argument<br>Name
</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>哪条语句执行，哪条不执行，看仔细了<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[初始化加载顺序]]></title>
    <link href="http://zc14.github.io/2015/12/23/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
    <id>http://zc14.github.io/2015/12/23/初始化加载顺序/</id>
    <published>2015-12-23T02:00:40.000Z</published>
    <updated>2015-12-27T07:28:14.220Z</updated>
    <content type="html"><![CDATA[<p>普通代码块，静态代码块执行顺序，次数<br><a id="more"></a><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InitTest03</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InitTest03</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		init();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InitTest03</span>(<span class="params"><span class="keyword">int</span> x</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.x = x;</span><br><span class="line">		init();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		y = x * <span class="number">2</span>;</span><br><span class="line">		System.<span class="keyword">out</span>.println(y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"static initialization"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		y = x * <span class="number">4</span>;</span><br><span class="line">		System.<span class="keyword">out</span>.println(y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">		InitTest03 test = <span class="keyword">new</span> InitTest03();</span><br><span class="line">		InitTest03 moreTest = <span class="keyword">new</span> InitTest03();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>static initialization<br>12<br>6<br>12<br>6
</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>普通代码块，静态代码块执行顺序，次数<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[回调函数]]></title>
    <link href="http://zc14.github.io/2015/12/22/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <id>http://zc14.github.io/2015/12/22/回调函数/</id>
    <published>2015-12-22T07:35:36.000Z</published>
    <updated>2015-12-27T07:23:23.310Z</updated>
    <content type="html"><![CDATA[<p>学习模板方法的时候发现的。<br>java中的回调函数，是通过匿名内部类来实现的。<br>Spring也是这么用的，好好学习下。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">handler</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJdbcQueryTemplate</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(String sql,ResultHandler&lt;T&gt; <span class="keyword">handler</span>)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="keyword">handler</span>.<span class="title">handler</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">Test</span>&#123;</span><br><span class="line">  public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="literal">result</span> = new <span class="type">SimpleJdbcQueryTemplate</span>().query(</span><br><span class="line">      new <span class="type">ResultHandler</span>&lt;<span class="type">Boolean</span>&gt;()&#123;</span><br><span class="line">        public <span class="type">String</span> query()&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"一个小小的测试。"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="literal">result</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>学习模板方法的时候发现的。<br>java中的回调函数，是通过匿名内部类来实现的。<br>Spring也是这么用的，好好学习下。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java解惑]]></title>
    <link href="http://zc14.github.io/2015/12/20/Java%E8%A7%A3%E6%83%91/"/>
    <id>http://zc14.github.io/2015/12/20/Java解惑/</id>
    <published>2015-12-20T06:52:24.000Z</published>
    <updated>2015-12-27T07:31:11.368Z</updated>
    <content type="html"><![CDATA[<p>一些小小注意点<br><a id="more"></a></p>
<h1 id="表达式之谜">表达式之谜</h1><h2 id="谜题1_奇偶性">谜题1 奇偶性</h2><pre><code>i%<span class="number">2</span> == <span class="number">0</span> 
优化 (i &amp; <span class="number">1</span>) == <span class="number">0</span>
</code></pre><h2 id="谜题2_找零时刻">谜题2 找零时刻</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">2.00</span> - <span class="number">1.10</span>);</span><br><span class="line"><span class="comment">//输出结果：0.8999999999999999</span></span><br></pre></td></tr></table></figure>
<p>原因:<strong>并不是所有的小数都可以用二进制浮点数精确表示。在需要精确答案的地方，要避免使用float和double;对于货币计算，要使用int，long或BigDecimal。</strong><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> System.out.<span class="built_in">println</span>(<span class="keyword">new</span> BigDecimal(<span class="number">.1</span>));</span><br><span class="line"> <span class="comment">//输出结果：0.1000000000000000055511151231257827021181583404541015625</span></span><br><span class="line"></span><br><span class="line"> 一定要用BigDecimal(<span class="keyword">String</span>)构造器，而千万不要用BigDecimal(<span class="keyword">double</span>)</span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="keyword">new</span> BigDecimal(<span class="string">"2.00"</span>).subtract(<span class="keyword">new</span> BigDecimal(<span class="string">"1.10"</span>)));</span><br><span class="line"><span class="comment">//输出结果：0.90</span></span><br></pre></td></tr></table></figure></p>
<h2 id="谜题3_长整除">谜题3 长整除</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final <span class="keyword">long</span> MICROS_PER_DAY = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line">       final <span class="keyword">long</span> MILLIS_PER_DAY = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">       System.out.println(MICROS_PER_DAY / MILLIS_PER_DAY);</span><br><span class="line"><span class="comment">//输出结果：5，而不是预期的1000</span></span><br></pre></td></tr></table></figure>
<p><strong>当你要操作很大的数字时，千万要提防溢出—-它可是一个缄默的杀手</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final <span class="keyword">long</span> MICROS_PER_DAY = <span class="number">24L</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line">       final <span class="keyword">long</span> MILLIS_PER_DAY = <span class="number">24L</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">       System.out.println(MICROS_PER_DAY / MILLIS_PER_DAY);</span><br><span class="line"><span class="comment">//输出结果：1000</span></span><br></pre></td></tr></table></figure></p>
<h2 id="谜题4_初级问题">谜题4 初级问题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">12345</span> + <span class="number">5432l</span>);</span><br><span class="line"><span class="comment">//输出结果：17777</span></span><br></pre></td></tr></table></figure>
<p><strong>在long类型字面常量中，一定要用大写的L，千万不要用小写的l</strong></p>
<h2 id="谜题5_十六进制的趣事">谜题5 十六进制的趣事</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">Long</span><span class="class">.toHexString</span>(0<span class="tag">x100000000L</span> + 0<span class="tag">xcafebabe</span>));</span><br></pre></td></tr></table></figure>
<p><strong>如果十六进制和八进制字面常量的最高位被置位了，那么他们就是负数。通常最好是避免混合类型的计算。</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">Long</span><span class="class">.toHexString</span>(0<span class="tag">x100000000L</span> + 0<span class="tag">xcafebabeL</span>));</span><br></pre></td></tr></table></figure>
<h2 id="谜题6_多重转型">谜题6 多重转型</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.<span class="keyword">out</span>.println((<span class="keyword">int</span>) (<span class="keyword">char</span>) (<span class="keyword">byte</span>) -<span class="number">1</span>);</span><br><span class="line"><span class="comment">//输出结果： 65535  32-&gt;8-&gt;16-&gt;32</span></span><br><span class="line">不能用一个<span class="keyword">char</span>表示一个负的<span class="keyword">byte</span>数值。</span><br></pre></td></tr></table></figure>
<p><strong>如果最初的数值类型是有符号的，就执行符号扩展；如果它是char，那么不管它将要被转换成什么类型，都执行零扩展。</strong></p>
<h2 id="谜题7_互换内容">谜题7 互换内容</h2><p>不重要</p>
<h2 id="谜题8_Dos_Equais">谜题8 Dos Equais</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">char</span> x = <span class="string">'X'</span>;</span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> System.out.print(<span class="literal">true</span>  ? x : <span class="number">0</span>);</span><br><span class="line"> System.out.print(<span class="literal">false</span> ? i : x); </span><br><span class="line">输出结果：X88</span><br></pre></td></tr></table></figure>
<p><strong>如果一个操作数的类型是T，T表示byte，short或char，而另一个操作类型是int。他的值可以用类型T表示，那么三目运算符的类型就是T。</strong></p>
<h2 id="谜题9_半斤">谜题9 半斤</h2><h2 id="谜题10_八两">谜题10 八两</h2><h2 id="谜题11_最后的笑声">谜题11 最后的笑声</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LastLaugh</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"H"</span> + <span class="string">"a"</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">'H'</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">'H'</span> + <span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Ha</span><br><span class="line">H</span><br><span class="line"><span class="number">169</span></span><br></pre></td></tr></table></figure>
<p><strong>当且仅当+操作符的操作数中至少有一个是String类型时，才会执行字符串连接操作</strong></p>
<h2 id="谜题12_ABC">谜题12 ABC</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Abc</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        String letters = <span class="string">"ABC"</span>;</span><br><span class="line">        <span class="keyword">char</span>[] numbers = &#123; <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span> &#125;;</span><br><span class="line">        System.<span class="keyword">out</span>.println(letters + <span class="string">" easy as "</span> + numbers);</span><br><span class="line">	System.<span class="keyword">out</span>.println(letters + <span class="string">" easy as "</span> + String.valueOf(numbers));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">ABC easy <span class="keyword">as</span> [C@<span class="number">659e0</span>bfd</span><br><span class="line">ABC easy <span class="keyword">as</span> <span class="number">123</span></span><br></pre></td></tr></table></figure>
<p><strong>char数组不是字符串。要想将一个char数组转换成一个字符串，就要调用String.valueof(char[])方法</strong></p>
<h2 id="谜题13_动物庄园">谜题13 动物庄园</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class AnimalFarm &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">String</span> len = <span class="string">"10"</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">String</span> pig = <span class="string">"length: 10"</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">String</span> dog = <span class="string">"length: "</span> + pig.length();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">String</span> monkey = <span class="string">"length: "</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">String</span> duck = <span class="string">"length: "</span> + len;</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Animals are equal: "</span> + pig == dog);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Animals are equal: "</span> + (pig == dog));</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Animals are equal: "</span> + (pig == monkey));</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Animals are equal: "</span> + (pig == duck));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">Animals are equal: <span class="keyword">false</span></span><br><span class="line">Animals are equal: <span class="keyword">true</span></span><br><span class="line">Animals are equal: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p><strong>在使用字符串连接操作符时，总是将重要的操作数用括号括起来。</strong></p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">``</span>`</span><br></pre></td></tr></table></figure>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">``</span>`</span><br></pre></td></tr></table></figure>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">``</span>`</span><br></pre></td></tr></table></figure>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">``</span>`</span><br></pre></td></tr></table></figure>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">``</span>`</span><br></pre></td></tr></table></figure>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">``</span>`</span><br></pre></td></tr></table></figure>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">``</span>`</span><br></pre></td></tr></table></figure>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">``</span>`</span><br></pre></td></tr></table></figure>
<pre><code>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>一些小小注意点<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[金典-概念与算法]]></title>
    <link href="http://zc14.github.io/2015/12/15/%E9%87%91%E5%85%B8-%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://zc14.github.io/2015/12/15/金典-概念与算法/</id>
    <published>2015-12-15T05:09:03.000Z</published>
    <updated>2015-12-16T07:53:00.211Z</updated>
    <content type="html"><![CDATA[<h1 id="概念与算法">概念与算法</h1><h2 id="位操作">位操作</h2><ol>
<li>手工位运算<br>1000 - 0110  （0010）<br>1011 &amp; (~0 &lt;&lt; 2) （1000）</li>
<li><p>位操作原理与技巧<br>|”^”操作|”&amp;”操作|<br>|:—-:|:—-:|<br>|x^0 = x|x&amp;0 = 0|<br>|x^1 = ~x|x&amp;1 = x|<br>|x^x = 0|x&amp;x = x|</p>
</li>
<li><p>常见位操作：获取，设置，清除及更新位数据</p>
<ul>
<li><p>获取</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">getBit</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((num &amp; (<span class="number">1</span> &lt;&lt; i)) !=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <em>该方法将1左移i位，得到形如00010000的值。接着，对这个值与num执行“位与”操作，从而将i位之外的所有位清零。<br>最后，检查该结果是否为零。不为零说明i位为1，否则，i位为0.</em></p>
</li>
<li><p>置位</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setBit</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>该方法先将1左移i位，得到形如00010000的值。接着，对这个值和num执行“位或”操作，这样只会改变i位的数据。<br>改掩码i位除外的位均为零，故而不会影响num的其余位。</em></p>
</li>
<li><p>清零</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clearBit</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mask = ~(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">  <span class="keyword">return</span> num &amp; mask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将num最高位至i位(含)清零的做法如下：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clearBitsMSBthroughtI</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mask = (<span class="number">1</span> &lt;&lt; i) -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> num &amp; mask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将i位至0位(含)清零的做法如下：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clearBitsIthrought0</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mask = ~((<span class="number">1</span> &lt;&lt; (i+<span class="number">1</span>)) -<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> num &amp; mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>该方法与setBit刚好相反。首先，将1左移i位得到形如00010000的值，对这个值取反进而得到类似11101111的掩码。<br>接着，对该掩码和num执行“位与”操作。这样只会清零num的i位，其余位保持不变。</em></p>
</li>
<li>更新<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateBit</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> i,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mask = ~(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">  <span class="keyword">return</span> ( num &amp; mask) | (v &lt;&lt; i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><em>此方法将setBit与clearBit合二为一。首先，用诸如11101111的掩码将num的第i位清零。<br>接着，将待写入值v左移i位，得到一个i位为v但其余位都为0的数。最后，对之前得到的两个结果执行“位或”操作，<br>v为1则将num的i位更新为1，否则该位仍为0.
</em></p>
</li>
</ol>
<h2 id="智力题">智力题</h2><ol>
<li>大声说出你的思路</li>
<li><p>总结规律与模式<br><em>给定两条绳子，每条绳子燃烧殆尽正好要用1个小时。怎样用这两条绳子准确计量15分钟？</em></p>
</li>
<li><p>略作变通</p>
</li>
<li>触类旁通</li>
</ol>
<h2 id="数学与概率">数学与概率</h2><ol>
<li><p>素数<br>每一个数都可以分解成素数乘积。<br><em>84 = 2的2次方 x 3的1次方 x 5的0次方 x 7的1次方 x 11的0次方 x 13的0次方 x 17的0次方…..</em></p>
<ul>
<li><p>素数检查</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">primeSlighrlyBetter</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> <span class="built_in">sqrt</span> = (<span class="keyword">int</span>) Math.<span class="built_in">sqrt</span>(n);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;=<span class="built_in">sqrt</span>;i++)&#123;</span><br><span class="line">   <span class="keyword">if</span>( n %i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成素数序列：埃拉托斯特腻筛法<br>能非常高效地生成素数序列，原理是剔除所有可被素数整除的非素数。<br>原理：一开始列出到max为止的所有数字。首先，划掉所有可被2整除的数(2保留)。<br>然后，找到下一个素数(也即下一个不会被划掉的数)，并划掉所有可被它整除的数。划掉所有可被2，3，5，7，11等素数整除的数，最终课得到2到max之间的素数序列。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[] sieveOfEratosthenes(<span class="keyword">int</span> max)&#123;</span><br><span class="line">  <span class="keyword">boolean</span>[] flags = <span class="keyword">new</span> <span class="keyword">boolean</span>[max +<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  init(flags);<span class="comment">//将flags中0，1元素除外的所有元素设为true</span></span><br><span class="line">  <span class="keyword">int</span> prime = <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(prime &lt;= max)&#123;</span><br><span class="line">   <span class="comment">/*划掉余下为prime倍数的数字*/</span></span><br><span class="line">   crossOff(flags,prime);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/*找出下一个为true的值*/</span></span><br><span class="line">   prime = getNextPrime(flags,prime);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>(prime &gt;= flags.length)&#123;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> crossOff(<span class="keyword">boolean</span>[] flags,<span class="keyword">int</span> prime)&#123;</span><br><span class="line"> <span class="comment">/*划掉余下为prime倍数的数字，我们可以从(prime*prime)开始，因为如果k*prime且k &lt; prime,这个值早就在之前的迭代里被划掉了。*/</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = prime * prime;i &lt; flags.length;i +=prime)&#123;</span><br><span class="line">   flags[i] = <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> getNextPrime(<span class="keyword">boolean</span>[] flags,<span class="keyword">int</span> prime)&#123;</span><br><span class="line"> <span class="keyword">int</span> <span class="keyword">next</span> = prime +<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span>(<span class="keyword">next</span> &lt; flags.length &amp;&amp; !flags[<span class="keyword">next</span>])&#123;</span><br><span class="line">   <span class="keyword">next</span>++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>概率</p>
<ul>
<li>A与B都发生的概率<br>P(A与B都发生) = P(B发生，在A发生的情况下) <em> P(A发生)
</em>假设要在1到10之间挑选一个数。挑中一个偶数且这个数载1到5之间的概率有多大？*1/5</li>
<li>A或B发生的概率<br>P(A或B发生) = P(A发生) + P(B发生) - P(A与B都发生)<br><em>假设我们要在1到10之间挑选一个数。挑中的数为偶数或这个数1到5之间的概率有多大？</em>4/5</li>
<li><p>独立<br>若A与B相互独立(也即，一个事件的发生，推不出另一个事件的发生)。那么P(A与B都发生) = P(A)P(B)。这条规则直接推倒自P(A与B都发生) = P(A)P(B).</p>
</li>
<li><p>互斥<br>若A与B互斥(也即，若一个事件发生，则另一个事件就不可能发生)，则P(A或B发生) = P(A) + P(B)。这是因为P(A与B都发生) = 0，所以，删除了之前P(A或B发生)算式中的P(A与B都发生)一项。</p>
</li>
</ul>
</li>
</ol>
<h2 id="面向对象设计">面向对象设计</h2><ol>
<li>如何解答面向对象设计问题<ul>
<li>处理不明确的地方</li>
<li>定义核心对象</li>
<li>分析对象关系</li>
<li>研究对象的动作</li>
</ul>
</li>
<li>设计模式<ul>
<li>单例设计模式<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Restaurant</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Restaurant _instance = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">Resuaurant</span>(<span class="params"></span>)</span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Restaurant <span class="title">getInstance</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">      _instance = <span class="keyword">new</span> Restaurant();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li>工厂方法设计模式<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> CardGame&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> CardGame createCardGame(GameType <span class="class"><span class="keyword">type</span>)&#123;</span></span><br><span class="line">     <span class="keyword">if</span>(<span class="class"><span class="keyword">type</span> </span>== GameType.Poker)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> PokerGame();</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="class"><span class="keyword">type</span> </span>== GameType.BlackJack)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlackJackGame();</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="递归和动态规划">递归和动态规划</h2><p>   当你听到问题是这么开头的：”设计一个算法，计算第n个……”,”编写代码列出前n个…….”,”实现一个方法，计算所有…..”等等，那么，这基本上就是一个递归问题。</p>
<ol>
<li>解决之道<br>从较小的子问题逐渐逼近原始问题。很多时候，只要在f(n-1)的解法中加入，移除某系东西或者稍作修改就能算出f(n).</li>
<li><p>动态规划<br>区别于递归，动态规划要对中间结果执行“缓存”操作，以备后续使用。<br><em>动态规划法简单实例：斐波那契数列</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改之前------------------------------</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(i == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span>(i == <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> fibonacci(i-<span class="number">1</span>) + fibonacci(i-<span class="number">2</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//修改之后------------------------------</span></span><br><span class="line"> <span class="keyword">int</span>[] fib = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(fib[i] != <span class="number">0</span>) <span class="keyword">return</span> fib[i];<span class="comment">//返回先前缓存的结果</span></span><br><span class="line">  fib[i] = fibonacci(i-<span class="number">1</span>) + fibonacci(i-<span class="number">2</span>);<span class="comment">//缓存结果</span></span><br><span class="line">  <span class="keyword">return</span> fib[i];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>递归和迭代解法<br>递归算法的空间效率很低。每次递归调用都会在栈上增加一层，也就是说，若算法包含O(n)次递归调用，就要使用O(n)内存。不得了！</li>
</ol>
</li>
</ol>
<h2 id="扩展性与存储限制">扩展性与存储限制</h2><ol>
<li>循序渐进法<ul>
<li>大胆假设</li>
<li>切合实际</li>
<li>解决问题</li>
</ul>
</li>
<li>你需要知道的：信息，策略与问题</li>
<li>示例：查找所有包含某一组词的文件<br><em>给定数百万份文件，如何找出所有包含某一组词的文件？我们不关心这些词出现的顺序，但它们必须是完整的单词。也就是说，“book”与“bookkeeper”不是一回事。</em><br><strong>在着手解决问题之前，我们需要考虑findWords程序只用一次，还是要反复调用。假设需要多次调用findWords程序来扫描这些文件，那么，我们可以接受预处理的开销。</strong><ul>
<li>步骤1<br>先忘记我们有数以百万计的文件，假装只有几十个文件。在这种情况下，如何实现findWords呢？<br>一种方法是预处理每个文件，并创建一个散列表的索引。这个散列表会将词映射到含有这个词的一组文件。<br>“books” -&gt;{doc2,doc3,doc6,doc8}<br>“many” -&gt;{doc1,doc3,doc7,doc8,doc9}<br>若要查找 “many books”,只需要对”books”和”many”的值进行交集运算，于是得到结果{doc3,doc8}</li>
<li>步骤2<br>现在，回到最初的问题。若有数百万份文件，会有什么问题？首先，我们可能需要将文件分散到多台机器上。<br>文件分散到多台机器上会引出以下几个很关键的关注点。<br>  1）如何划分改散列表。（按关键字划分）某台机器上存放油包含某个单词的全部文件。<br>  2）划分数据完成，我们可能需要在一台机器上对文件进行处理，并将结果推送他其他机器上。<br>  3）我们需要找到一种方法获知哪台机器拥有哪些数据。</li>
<li>步骤3<br>为了找到匹配某一组字符串的所有文件，我们会先对这一组字符串进行排序，然后给每一台机器发送与字符对应的查找请求。例如，若带查找字符串为“after builds boat amaze banana”，一号机器开始查找包含“after” 与 “amaze” 的文件，并对这些文件执行交集运算。三号机器则处理{“banana”，“boat”，“builds”}这几个关键字，同样也会对文件进行交集运算。<br>最后，发送请求的机器在对一号机器及三号机器返回的结果作交集运算。<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">            “after builds boat amaze banana”</span><br><span class="line"> </span><br><span class="line"> Machine <span class="number">1</span>：“after amaze”       Machine <span class="number">3</span>：“builds boat banana”</span><br><span class="line"> </span><br><span class="line">“after” -&gt;<span class="annotation">doc</span><span class="number">1</span>,<span class="annotation">doc</span><span class="number">5</span>,<span class="annotation">doc</span><span class="number">7</span>       “builds” -&gt;<span class="annotation">doc</span><span class="number">3</span>,<span class="annotation">doc</span><span class="number">4</span>,<span class="annotation">doc</span><span class="number">5</span></span><br><span class="line">“amaze” -&gt;<span class="annotation">doc</span><span class="number">2</span>,<span class="annotation">doc</span><span class="number">5</span>,<span class="annotation">doc</span><span class="number">7</span>       “boat”   -&gt;<span class="annotation">doc</span><span class="number">2</span>,<span class="annotation">doc</span><span class="number">3</span>,<span class="annotation">doc</span><span class="number">5</span></span><br><span class="line">                               “banana” -&gt;<span class="annotation">doc</span><span class="number">3</span>,<span class="annotation">doc</span><span class="number">3</span>,<span class="annotation">doc</span><span class="number">5</span></span><br><span class="line">      </span><br><span class="line">      &#123;<span class="annotation">doc</span><span class="number">5</span>,<span class="annotation">doc</span><span class="number">7</span>&#125;               &#123;<span class="annotation">doc</span><span class="number">3</span>,<span class="annotation">doc</span><span class="number">5</span>&#125;</span><br><span class="line">      </span><br><span class="line">                  solution = <span class="annotation">doc</span><span class="number">5</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="排序与查找">排序与查找</h2><ol>
<li><p>排序算法<br>面试中常见的排序算法三种算法：归并排序(Merge Sort) 快速排序(Quick Sort) 基数排序(Radix Sort,桶排序)</p>
<ul>
<li>冒泡排序|执行时间： 平均情况与最差情况为O(n²)，存储空间：O(1).<br>冒泡排序（Bubble Sort）是先从数组第一个元素开始，依次比较相邻两个数，若前者比后者大，就将两者交换位置，然后处理下一对，依此类推，不断扫描数组，直到完成排序。</li>
<li>选择排序|执行时间：平均情况与最差情况为O(n²)，存储空间：O(1).<br>选择排序(Selecction Sort)有点小儿科：简单而低效。我们会线性逐一扫描数组元素，从中挑出最小的元素，将它移到最前面(也就是与最前面的元素交换)。然后，再次线性扫描数组，找到第二小的元素，并移到前面。如此反复，直到全部元素各归其位。</li>
<li><p>归并排序|执行时间：平均情况与最差情况为O(nlog(n))，存储空间：看情况。☆☆☆☆☆<br>归并排序是将数组分成两半，这两半分别排序后，再归并在一起。排序某一半时，继续沿用同样的排序算法，最终，你将归并两个只含有一个元素的数组。这个算法的重担都落在“归并”的部分上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">  	<span class="keyword">int</span> middle = (low + high) /<span class="number">2</span>;</span><br><span class="line">      mergesort(<span class="built_in">array</span>,low,middle);<span class="comment">//排序左半部分</span></span><br><span class="line">      mergesort(<span class="built_in">array</span>,middle+<span class="number">1</span>,high);<span class="comment">//排序右半部分</span></span><br><span class="line">      merge(<span class="built_in">array</span>,low,middle,high);<span class="comment">//归并</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>,<span class="keyword">int</span> low,<span class="keyword">int</span> middle,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] helper = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">array</span>.length];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*将数组左右两半拷贝到helper数组中*/</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = low;i &lt;=high;i++)&#123;</span><br><span class="line">  helper[i] = <span class="built_in">array</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> helperLeft = low;</span><br><span class="line">  <span class="keyword">int</span> helperRight = middle + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> current = low;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   *迭代访问helper数组。比较左，右两半的元素，并将较小的元素复制到原先的数组中。</span><br><span class="line">   */</span></span><br><span class="line">   <span class="keyword">while</span>(helperLeft &lt;= middle &amp;&amp; helperRight &lt;=high)&#123;</span><br><span class="line">     <span class="keyword">if</span>(helper[helperLeft] &lt;= helper[helperRight])&#123;</span><br><span class="line">       <span class="built_in">array</span>[current] = helper[helperLeft];</span><br><span class="line">       helperLeft++;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果右边的元素小于左边的元素</span></span><br><span class="line">       <span class="built_in">array</span>[current] = helper[helperRight];</span><br><span class="line">       helperRight++;</span><br><span class="line">     &#125;</span><br><span class="line">     count++;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/*</span><br><span class="line">    *将数组左半部分剩余元素复制到目标数组中</span><br><span class="line">    */</span></span><br><span class="line">    <span class="keyword">int</span> remaining = middle -- helperLeft;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=remaining;i++)&#123;</span><br><span class="line">      <span class="built_in">array</span>[current + i] = helper[helperLeft + i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] helper = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">array</span>.length];</span><br><span class="line">  mergesort(<span class="built_in">array</span>,helper,<span class="number">0</span>,<span class="built_in">array</span>.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>merge方法会将目标数组的所有元素拷贝到临时数组helper中，并记下数组左,右两半的其实位置(helperLefth和helperRight)。然后，迭代访问helper数组，将左右两半中较小的元素，复制到目标数组中。最后，再将余下所有元素复制回目标数数组。</p>
</li>
<li><p>快速排序|执行时间：平均情况为O(nlog(n))，最差情况为O(n²)，存储空间：O(log(n)).☆☆☆☆☆<br>快速排序是随机挑选一个元素，对数组进行分割，以将所有比它小的元素排在前面，比它大的元素则排在后面。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">quickSort</span>(int arr[],int <span class="keyword">left</span>,int <span class="keyword">right</span>)&#123;</span><br><span class="line">  int index = <span class="built_in">partition</span>(arr,<span class="keyword">left</span>,<span class="keyword">right</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">left</span> &lt; index -<span class="number">1</span>)&#123; <span class="comment">//排序左半部分</span></span><br><span class="line">     <span class="built_in">quickSort</span>(arr,<span class="keyword">left</span>,index - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(index &lt; <span class="keyword">right</span>)&#123; <span class="comment">//排序右半部分</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr,index,<span class="keyword">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="built_in">partition</span>(int arr[],int <span class="keyword">left</span>,int <span class="keyword">right</span>)&#123;</span><br><span class="line">  int pivot = arr[(<span class="keyword">left</span> + <span class="keyword">right</span>)/<span class="number">2</span>];<span class="comment">//挑出一个基准点</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">left</span> &lt;= <span class="keyword">right</span>) &#123;</span><br><span class="line">    <span class="comment">//找出左边中应被放到右边的元素</span></span><br><span class="line">    <span class="keyword">while</span>(arr[<span class="keyword">left</span>] &lt; pivot) <span class="keyword">left</span>++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找出右边中应被放到左边的元素</span></span><br><span class="line">    <span class="keyword">while</span>(arr[<span class="keyword">right</span>] &gt; pivot) <span class="keyword">right</span>--;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换元素，同时调整左右索引值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">left</span> &lt;= <span class="keyword">right</span>)&#123;</span><br><span class="line">      <span class="built_in">swap</span>(arr,<span class="keyword">left</span>,<span class="keyword">right</span>);<span class="comment">//交换元素</span></span><br><span class="line">      <span class="keyword">left</span>++;</span><br><span class="line">      <span class="keyword">right</span>--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">left</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基数排序|执行时间：O(kn) ☆☆☆☆☆<br>基数排序是个整数(或其他一些数据类型)排序算法，充分利用整数的位数有限这一事实。使用基数排序时，我们会迭代访问数字的每一位，按各个位对这些数字分组。<br>比如说，假设有一个整数数组，我们可以先按个位对这些数字进行分组，于是，个位为0的数字就会分在同一个组里。然后，再按十位进行分组，如此反复执行同样的过程，逐级按更高位进行排序，直到最后整个数组变为有序数组。</p>
</li>
</ul>
</li>
<li><p>查找算法<br>二分查找☆☆☆☆☆ <strong>需要有序</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> mid;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">    mid = (low + high) /<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid] &lt; x)&#123;</span><br><span class="line">      low = mid +<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &gt; x)&#123;</span><br><span class="line">    high = mid -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearchRecursive</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> x,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(low &gt; high) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//错误</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> mid = (low + high) /<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span>(a[mid] &lt; x)&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearchRecursive(a,x,mid + <span class="number">1</span>,high);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &gt; x)&#123;</span><br><span class="line">   <span class="keyword">return</span> binarySearchRecursive(a,x,low,mid -<span class="number">1</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mid;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概念与算法">概念与算法</h1><h2 id="位操作">位操作</h2><ol>
<li>手工位运算<br>1000 - 0110  （0010）<br>1011 &amp; (~0 &lt;&lt; 2) （1000）</li>
<li><p>位操作原理与技]]>
    </summary>
    
      <category term="金典" scheme="http://zc14.github.io/tags/%E9%87%91%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[金典-数据结构]]></title>
    <link href="http://zc14.github.io/2015/12/13/%E9%87%91%E5%85%B8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://zc14.github.io/2015/12/13/金典-数据结构/</id>
    <published>2015-12-13T13:02:04.000Z</published>
    <updated>2015-12-27T07:32:53.270Z</updated>
    <content type="html"><![CDATA[<p>一些面试常用的数据结构<br><a id="more"></a></p>
<h1 id="数据结构">数据结构</h1><h2 id="数组与字符串">数组与字符串</h2><ol>
<li><p>散列表<br>散列表是一种将键(key)映射为值(value)从而实现快速查找的数据结构。<br><strong>核心：底层数组和散列函数(hash function)</strong>.问题：数组过小，碰撞冲突。<br>除了创建按索引hash(key)%array_length的数组元素指向的链表中。要通过某个键来查找对象，就必须根据散列值找到对应的链表，然后在链表中查找对应的键。<br>另外，我们还可以采用<strong>二叉查找树</strong>来实现散列表。只要我们让这棵树保持平衡，就能保证数据能查找用时为O(log n).原因很简单，我们不必一开始就分配一个大数组。</p>
</li>
<li><p>ArrayList(动态数组)</p>
</li>
<li><p>StringBuffer</p>
</li>
</ol>
<h2 id="链表">链表</h2><ol>
<li>创建链表<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Node</span><span class="identifier"></span><span class="title">&#123;</span><br><span class="line">  Node</span> next = null;</span><br><span class="line">  int data;</span><br><span class="line">  </span><br><span class="line">  public <span class="keyword">Node</span><span class="identifier"></span><span class="title">(int</span> d)&#123;</span><br><span class="line">    data = d;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  void appendToTail(int d)&#123;</span><br><span class="line">    <span class="keyword">Node</span><span class="identifier"> </span><span class="title">end</span> = new <span class="keyword">Node</span><span class="identifier"></span><span class="title">(d</span>);</span><br><span class="line">    <span class="keyword">Node</span><span class="identifier"> </span><span class="title">n</span> = this;</span><br><span class="line">    while(n.next != null)&#123;</span><br><span class="line">      n = n.next;</span><br><span class="line">    &#125;</span><br><span class="line">    n.next = end;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>删除单向链表中的节点<br>给定一个节点n，我们先找到它的前驱结点prev,并将prev.next设置为n.next.<br>如果是双向链表，我们还要更新n.next.将n.next.prev置为n.prev.当然，我们必须注意：</p>
<ul>
<li>检查空指针。</li>
<li>必要时更新表头head和表尾tail指针。<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Node deleteNode(Node head,int <span class="keyword">d</span>)&#123;</span><br><span class="line">  Node <span class="keyword">n</span> = head;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">n</span>.data == <span class="keyword">d</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> head.next; <span class="comment">/*表头指向下一结点*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">n</span>.next != null) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">n</span>.next.data == <span class="keyword">d</span>)&#123;</span><br><span class="line">      <span class="keyword">n</span>.next  = <span class="keyword">n</span>.next.next;</span><br><span class="line">      <span class="keyword">return</span> head; <span class="comment">/*表头不变*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">n</span> = <span class="keyword">n</span>.next;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>快行指针技巧<br>快行指针值得是同时用两个指针来迭代访问链表，只不过其中一个比另一个超前一些。”快”指针往往先行几步，或与”慢”指针相差固定的步数。<br><em>举个例子，假定有一个链表a1-&gt;a2-&gt;…..-&gt;an-&gt;b1-&gt;b2……-&gt;bn,你想将其重新排列成a1-&gt;b1-&gt;a2-&gt;b2-&gt;…..an-&gt;bn.另外，你不知道该链表的长度(但确定它有偶数个元素)。</em><br>你可以用两个指针，其中p1（快指针）每次都向前移动两步，而同时p2只移动一步。当p1到达链表末尾时，p2刚好位于链表中间位置。然后，再让p1与p2一步步从尾向头反向移动，并将p2指向的结点插入到p1所指结点后面。</p>
</li>
<li><p>递归问题<br>解决链表问题碰壁时，不妨试试递归法能否奏效。</p>
</li>
</ol>
<h2 id="栈与队列">栈与队列</h2><ol>
<li><p>实现一个栈<br>栈(LIFO)</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">  Node top;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">Object</span> pop()&#123;</span><br><span class="line">    <span class="keyword">if</span>(top != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="built_in">Object</span> item = top.data;</span><br><span class="line">      top = top.next;</span><br><span class="line">      <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> push(<span class="built_in">Object</span> item)&#123;</span><br><span class="line">    Node t = <span class="keyword">new</span> Mode(item);</span><br><span class="line">    t.next = top;</span><br><span class="line">    top = t;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">Object</span> peek()&#123;</span><br><span class="line">    <span class="keyword">return</span> top.data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现一个队列<br>队列采用先进先出(FIFO)顺序。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">class</span> Queue&#123;</span><br><span class="line">  Node <span class="keyword">first</span> ,<span class="keyword">last</span>;</span><br><span class="line">  </span><br><span class="line">  void enqueue(Object <span class="property">item</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">first</span> == null) &#123;</span><br><span class="line">      <span class="keyword">last</span> = new Node(<span class="property">item</span>);</span><br><span class="line">      <span class="keyword">first</span> = <span class="keyword">last</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="keyword">last</span>.next = new Node(<span class="property">item</span>);</span><br><span class="line">     <span class="keyword">last</span> = <span class="keyword">last</span>.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> Object dequeue()&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="keyword">first</span> != null)&#123;</span><br><span class="line">     Object <span class="property">item</span> = <span class="keyword">first</span>.data;</span><br><span class="line">     <span class="keyword">first</span> = <span class="keyword">first</span>.next;</span><br><span class="line"><span class="command">     return</span> <span class="property">item</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="command">   return</span> null;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="树与图">树与图</h2><ol>
<li><p>需要注意的潜在问题</p>
<ul>
<li>二叉树与二叉查找树<br>二叉查找树的附加条件：对于任意结点，左子结点&lt;=当前结点，后者 由&lt;=所有右子结点</li>
<li>平衡与不平衡<br>如果树是不平衡的，你应当从平均情况和最坏情况所需时间来描述自己的算法。注意，树的平衡有多种方法，平衡一棵树只意味着子树的深度差不会超过一定值，并不表示左子树和右子树的深度完全相同。</li>
<li>完满和完整<br>一棵树必须正好有2n次方-1个结点才能满足这个条件</li>
</ul>
</li>
<li><p>二叉树遍历 尤其是中序遍历考察的比较多</p>
</li>
<li><p>树的平衡：红黑树 和平衡二叉树。面试问的比较少</p>
</li>
<li><p>单词查找树(trie)<br>tire树是n层树的一种变体，其中每个节点存储有字符。整棵树的每条路径自上而下表示一个单词。</p>
</li>
<li><p>图的遍历<br>广度优先搜索(BFS)和深度优先搜索(DFS)</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>一些面试常用的数据结构<br>]]>
    
    </summary>
    
      <category term="金典" scheme="http://zc14.github.io/tags/%E9%87%91%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[准备]]></title>
    <link href="http://zc14.github.io/2015/12/13/%E5%87%86%E5%A4%87/"/>
    <id>http://zc14.github.io/2015/12/13/准备/</id>
    <published>2015-12-13T09:43:44.000Z</published>
    <updated>2015-12-13T12:51:32.600Z</updated>
    <content type="html"><![CDATA[<ol>
<li>没有什么比<strong>为兴趣而工作</strong>更能打动招聘人员的了。</li>
<li>公司最青睐的人才必须具备两个特性：一是天资聪颖，二是扎实的编程功底。</li>
<li>还要提前规划好职业发展路径。</li>
<li>建立好的人际网络。好的人际网络不仅意味着你广交朋友(广度),还要与他们保持紧密的联系(深度).尽量与朋友保持<strong>真诚</strong>与<strong>深厚</strong>的关系。</li>
<li>要学会主动跟人打招呼。</li>
<li>最重要的是乐于助人。</li>
</ol>
<h2 id="简历的书写">简历的书写</h2><ul>
<li>简历尽量短<br>[demo]:使用Y实现了X，从而达到了Z效果。<em>通过实施分布式缓存功能减少了75%的对象渲染时间，从而使得用户登录速度加快了10%。</em> <strong>原则：描述做过的事情，怎么做的，以及结果如何。理想的做法是尽可能地量化结果。</strong></li>
<li>编程语言：Java(非常熟练)，C++(熟练)，JavaScript(有过使用经验)。</li>
<li>你有哪些缺点 <strong>应该提到真实，合乎情理的缺点，然后话锋一转，强调自己如何克服这些缺点。</strong> <em>1.有时候，我可能对细节不够重视。好的一面是我反应迅速，执行力强，但不免会粗心大意而犯错。有鉴于此，我总是会找其他同事帮忙检查自己的工作，确保不出问题。</em> <em>2.通过记录笔记/blog的形式，深化记忆</em></li>
<li>项目中最难处理的问题是什么。  离职人员没有交接，造成问题定位困难（手机客户端，umapp端）。修改日志。</li>
<li>你应该问面试官哪些问题 1）真实的问题 <em>你每天有多少时间花在写代码上？</em> <em>你一周要开几次会？</em> 2）有见地的问题 <em>我注意到你们使用了X技术，请问你们是如何处理Y问题的？</em> 3）富有激情的问题 <em>我对可扩展性很感兴趣。请问你从事过分布式系统的工作吗？有哪些机会可以学习这方面的知识？</em> <em>我对X技术不是太熟悉，不过听上去是个不错的解决方案。你能给我多讲讲它的工作原理吗？</em></li>
<li><strong>VS</strong> <em>我几乎包揽了团队中所有的累活和难活。[骄傲自大，面试大忌]</em> <em>我实施了文件系统，因为XXXX原因，这是整个项目中最难的一部分。</em></li>
</ul>
<h2 id="行为面试题">行为面试题</h2><table>
<thead>
<tr>
<th style="text-align:right">常见问题</th>
<th style="text-align:right">项目1</th>
<th style="text-align:right">项目</th>
<th style="text-align:right">项目3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">最难的部分</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:right">有什么收获</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:right">最有意思的部分</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:right">最难解决的bug</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:right">最享受的过程</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:right">与团队成员的冲突</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
</tbody>
</table>
<p><strong>编写小故事，填写表格。面试前复习。最好小故事浓缩成几个字，便于记忆</strong></p>
<h2 id="基本知识点">基本知识点</h2><table>
<thead>
<tr>
<th style="text-align:right">数据结构</th>
<th style="text-align:right">算法</th>
<th style="text-align:right">概念</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">链表</td>
<td style="text-align:right">广度优先遍历</td>
<td style="text-align:right">位操作</td>
</tr>
<tr>
<td style="text-align:right">二叉树</td>
<td style="text-align:right">深度优先遍历</td>
<td style="text-align:right">单例设计模式</td>
</tr>
<tr>
<td style="text-align:right">单词查找树(trie)</td>
<td style="text-align:right">二分查找法</td>
<td style="text-align:right">工厂设计模式</td>
</tr>
<tr>
<td style="text-align:right">栈</td>
<td style="text-align:right">归并排序</td>
<td style="text-align:right">内存(栈和堆)</td>
</tr>
<tr>
<td style="text-align:right">队列</td>
<td style="text-align:right">快速排序</td>
<td style="text-align:right">递归</td>
</tr>
<tr>
<td style="text-align:right">向量/数组列表</td>
<td style="text-align:right">树的插入</td>
<td style="text-align:right">大O时间</td>
</tr>
<tr>
<td style="text-align:right">散列表</td>
<td style="text-align:right"></td>
</tr>
</tbody>
</table>
<h2 id="算法题的五种解法">算法题的五种解法</h2><ol>
<li><p>举例法<br><em>给定一个具体时间，计算时针与分针之间的角度。</em><br>[解]：下面以3：27为例。确定3点的时针位置和27分的分针位置，我们可以画出一个时钟。<br>在一下的解法中，h表示小时，m表示分钟。同时，我们假定h的范围[0-23].<br>从这些例子我们可以得出以下规则：</p>
<ul>
<li>分针的角度（从12点整开始算起）：360 x m/60;                              162</li>
<li>时针的角度（从12点整开始算起）：360 x (h%12)/12 + 360 x (m/60) x (1/12)   90 +13.5</li>
<li>时针和分针之间的角度： （30h-5.5m）%360. 148.5    14.58</li>
</ul>
</li>
<li><p>模式匹配法<br><em>一个有序数组的元素经过循环移动，元素的顺序可能是“3 4 5 6 7 1 2”。怎么才能找出数组中最小的那个元素？假设数组中的元素各不相同。</em><br>二分查找，部分有序。找出拐点即可。</p>
</li>
<li><p>简化推广法<br><em>从一本杂志里剪下一些单词可以拼凑成一封勒索信。怎样才能断定勒索信(以字符串表示)是否由某本杂志(即另一个字符串)里的单词组成。</em><br>可以先简化问题：暂时不考虑单词，只当它是字符。<br>推广这个算法，创建一个散列表，将单词映射到其词频上。</p>
</li>
<li><p>简单构造法–最后往往演变成递归法。（数学中的数学归纳法）<br><em>设计一种算法，打印某个字符串所有可能的排列组合。为简单起见，假设字符串中没有重复字符。</em><br>以字符串”abcdefg”为例：<br>只有”a”的情况，结果为：{“a”}<br>然后是”ab”，结果为：{“ab”,”ba”}<br>再然后是”abc”，结果会是什么呢？<br>此时，问题开始变得有点意思了。得到P(ab)的答案，怎么才能生成P(abc)呢？很简单，新字符是c。我们只需要在前一种情况的答案也即字符组合的任意位置加一个c就可以了。也就是：<br>P(abc) = 将”c”字符插入 P(ab)得到的所有字符串的任意位置。<br>亦即：P(abc) = 将”c”字符插入{“ab”,”ba”}这两个字符串中的任意位置。<br>也就是：P(abc) = merge({“cab”,”acb”,”abc”},{“cba”,”bca”,”bac”})<br>最后得出的结果：P(abc) = {“cab”,”acb”,”abc”,”cba”,”bca”,”bac”}.</p>
</li>
<li><p>数据结构头脑风暴<br><em>随机生成一些数字，并保存到一个(可扩展的)数组中。如何跟踪数组的中位数？</em><br>链表？<br>数组？<br>二叉树？<br>堆？</p>
</li>
</ol>
<h2 id="许多公司都想找到能写出“优美，整洁”代码的人才。">许多公司都想找到能写出“优美，整洁”代码的人才。</h2><ol>
<li>正确</li>
<li>高效</li>
<li>简洁</li>
<li>易读</li>
<li>可维护性</li>
</ol>
<p><em>编写一个函数检查某个二进制数(以字符串形式传入)是否等于以字符串表示的十六进制数。</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li>没有什么比<strong>为兴趣而工作</strong>更能打动招聘人员的了。</li>
<li>公司最青睐的人才必须具备两个特性：一是天资聪颖，二是扎实的编程功底。</li>
<li>还要提前规划好职业发展路径。</li>
<li>建立好的人际网络。好的人际网]]>
    </summary>
    
      <category term="面试" scheme="http://zc14.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法学习]]></title>
    <link href="http://zc14.github.io/2015/12/09/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://zc14.github.io/2015/12/09/算法学习/</id>
    <published>2015-12-09T05:26:15.000Z</published>
    <updated>2015-12-09T09:04:18.444Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="学习算法是非常有趣和令人激动的">学习算法是非常有趣和令人激动的</h1><h1 id="最大公约数-(欧几里得算法)">最大公约数-(欧几里得算法)</h1>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="link_reference">自然语言描述</span>]:<span class="link_url">计算两个非负整数p和q的最大公约数:若q是0，则最大公约数为p。否则，将p除以q得到余数r，p和q的最大公约数即为q和r的最大公约数。</span></span><br></pre></td></tr></table></figure>
<h2 id="基础">基础</h2><h2 id="排序">排序</h2><h2 id="查找">查找</h2><h2 id="图">图</h2><h2 id="字符串">字符串</h2><h2 id="背景">背景</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="学习算法是非常有趣和令人激动的">学习算法是非常有趣和令人激动的</h1><h1 id="最大公约数-(欧几里得算法)">最大公约数-(欧几里得算法)</h1>  <figure class="highlight markdown"><t]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[markdown快速入门]]></title>
    <link href="http://zc14.github.io/2015/12/06/markdown/"/>
    <id>http://zc14.github.io/2015/12/06/markdown/</id>
    <published>2015-12-06T13:48:23.000Z</published>
    <updated>2015-12-06T14:07:16.198Z</updated>
    <content type="html"><![CDATA[<p>简单学习markdown<br><a id="more"></a></p>
<h1 id="一级标题">一级标题</h1><h2 id="二级标题">二级标题</h2><h3 id="三级标题">三级标题</h3><h4 id="四级标题">四级标题</h4><h5 id="五级标题">五级标题</h5><h6 id="六级标题">六级标题</h6><p><strong>加粗</strong><br><em>斜体</em><br>这个是<code>行内代码</code>，好玩</p>
<ol>
<li>你好</li>
<li>我好</li>
<li>大家好</li>
</ol>
<p>[TOC]</p>
<ul>
<li>无序1</li>
<li>无序2</li>
<li>无序3</li>
</ul>
<hr>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hello</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"hello world"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>fffffff</del></p>
<p>==kkkkkkkkk==<br>| 姓名 | 学号 |<br>|——–|——–|<br>|      张三  |       002 |</p>
<!--注释-->]]></content>
    <summary type="html">
    <![CDATA[简单学习markdown]]>
    
    </summary>
    
      <category term="markdown" scheme="http://zc14.github.io/tags/markdown/"/>
    
      <category term="markdown" scheme="http://zc14.github.io/categories/markdown/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[临时笔记]]></title>
    <link href="http://zc14.github.io/2015/12/06/%E4%B8%B4%E6%97%B6%E7%AC%94%E8%AE%B0/"/>
    <id>http://zc14.github.io/2015/12/06/临时笔记/</id>
    <published>2015-12-06T07:53:01.000Z</published>
    <updated>2015-12-11T12:51:21.953Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="记录临时学习内容">记录临时学习内容</h1><h2 id="Java的设计优化_提高性能的5种[设计模式]_^-^">Java的设计优化 提高性能的5种[设计模式] ^.^</h2><h3 id="单例模式">单例模式</h3><h3 id="代理模式">代理模式</h3>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">静态代理： 抽象接口/真实对象/代理对象--可用于[延迟加载]</span><br><span class="line">动态代理： jdk/cglib</span><br><span class="line">           apache commons ArrayUtils.<span class="function"><span class="title">contains</span><span class="params">(xx,xx)</span></span> ,可以增加某些操作的日志过滤</span><br></pre></td></tr></table></figure>
<p>  <strong>待完成题目</strong> <em>运用spring拦截器，进行用户操作行为的记录[user/ip/method/time]</em></p>
<h3 id="享元模式">享元模式</h3>  <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">核心：克隆 或者 从享元工厂的<span class="preprocessor">Map</span>中获取</span><br></pre></td></tr></table></figure>
<h3 id="装饰者模式">装饰者模式</h3>  <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">核心：动态添加对象的功能，如java中的<span class="built_in">io</span>类</span><br></pre></td></tr></table></figure>
<h3 id="观察者模式">观察者模式</h3>  <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主题<span class="keyword">Subject </span>抽象/具体 (添加/删除/循环通知)</span><br><span class="line">观察者Observer update</span><br></pre></td></tr></table></figure>
<p>  <strong>待完成题目</strong> <em>考试系统-学生/考试</em></p>
<h2 id="缓存的应用">缓存的应用</h2>   <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(局部缓存/全局缓存)</span><br><span class="line">jsp标签实现页面级的局部缓存 - OSCache</span><br><span class="line">局部缓存在开发中 不如 全局缓存用的多</span><br><span class="line">全局缓存<span class="comment">--过滤器filter</span></span><br></pre></td></tr></table></figure>
<h2 id="Java程序优化">Java程序优化</h2><ul>
<li>集合类的相关[插入/删除]性能对比</li>
<li>集合类的相关[查找]性能对比</li>
</ul>
<h2 id="常用的提高性能方式">常用的提高性能方式</h2><ol>
<li>工具类多用静态方法</li>
<li>重量级对象的创建使用Clone(√)方法代替new关键字,注意深克隆和浅克隆，apache commons的是深度克隆</li>
<li>io操作尽可能的使用Buffer，性能提高不少</li>
<li>对于数据复制，尽量使用System.arrayCopy()</li>
<li>bool运算(&amp;&amp;)(√) 和 位运算,做逻辑判断的时候，前者效率高于后者</li>
<li>普通循环赋值 和 分批次循环赋值(√)  后者效率高</li>
<li>提取表达式，比如for循环时候的变量定义等</li>
<li>array 下标/switch/if else的效率</li>
<li>位运算代替乘法</li>
<li>局部变量(√) 和 成员变量,前者效率较高</li>
<li>一维数组(√) 性能 高于 二维数组</li>
</ol>
<h2 id="NIO">NIO</h2><ul>
<li>文件内存映射，效率很高</li>
<li>Channel/Buffer</li>
<li>Fork/Join</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="记录临时学习内容">记录临时学习内容</h1><h2 id="Java的设计优化_提高性能的5种[设计模式]_^-^">Java的设计优化 提高性能的5种[设计模式] ^.^</h2><h3 id="单例模式">单例模式</h3><h3 ]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://zc14.github.io/2015/12/06/hello-world/"/>
    <id>http://zc14.github.io/2015/12/06/hello-world/</id>
    <published>2015-12-06T06:32:43.000Z</published>
    <updated>2015-12-06T07:49:07.676Z</updated>
    <content type="html"><![CDATA[<p>开始新的征程.</p>
<h2 id="主标题">主标题</h2><h3 id="副标题1">副标题1</h3><h3 id="副标题2">副标题2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ 命令行语句</span><br></pre></td></tr></table></figure>
<p>更多信息: <a href="http://zc14.github.io/">More</a></p>
]]></content>
    <summary type="html">
    <![CDATA[入门页面，认识下简单的样式]]>
    
    </summary>
    
      <category term="开始" scheme="http://zc14.github.io/tags/%E5%BC%80%E5%A7%8B/"/>
    
      <category term="hello" scheme="http://zc14.github.io/categories/hello/"/>
    
  </entry>
  
</feed>
